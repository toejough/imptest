// Code generated by impgen. DO NOT EDIT.

package timeconflict_test

import _imptest "github.com/toejough/imptest/imptest"
import _reflect "reflect"
import _testing "testing"
import _time "time"
import timeconflict "github.com/toejough/imptest/UAT/11-package-name-conflicts"
import time "time"

// SchedulerImp is the test controller for mocking the interface.
// Create with NewSchedulerImp(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := NewSchedulerImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type SchedulerImp struct {
	*_imptest.Controller[*SchedulerImpCall]
	Mock         *SchedulerImpMock
	ExpectCallIs *SchedulerImpExpectCallIs
	currentCall  *SchedulerImpCall
}

// NewSchedulerImp creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := NewSchedulerImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func NewSchedulerImp(t *_testing.T) *SchedulerImp {
	imp := &SchedulerImp{
		Controller: _imptest.NewController[*SchedulerImpCall](t),
	}
	imp.Mock = &SchedulerImpMock{imp: imp}
	imp.ExpectCallIs = &SchedulerImpExpectCallIs{imp: imp}
	return imp
}

// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *SchedulerImp) GetCurrentCall() *SchedulerImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *SchedulerImpCall) bool { return true })
	return i.currentCall
}

// Within configures a timeout for expectations and returns a SchedulerImpTimed for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*_time.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *SchedulerImp) Within(d _time.Duration) *SchedulerImpTimed {
	return &SchedulerImpTimed{
		ExpectCallIs: &SchedulerImpExpectCallIs{imp: i, timeout: d},
	}
}

// SchedulerImpCall represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{Method}() to access typed call details.
type SchedulerImpCall struct {
	scheduleAt  *SchedulerImpScheduleAtCall
	delay       *SchedulerImpDelayCall
	nextRun     *SchedulerImpNextRunCall
	getInterval *SchedulerImpGetIntervalCall
}

// AsDelay returns the call cast to SchedulerImpDelayCall for accessing call details.
// Returns nil if the call was not to Delay.
func (c *SchedulerImpCall) AsDelay() *SchedulerImpDelayCall {
	return c.delay
}

// AsGetInterval returns the call cast to SchedulerImpGetIntervalCall for accessing call details.
// Returns nil if the call was not to GetInterval.
func (c *SchedulerImpCall) AsGetInterval() *SchedulerImpGetIntervalCall {
	return c.getInterval
}

// AsNextRun returns the call cast to SchedulerImpNextRunCall for accessing call details.
// Returns nil if the call was not to NextRun.
func (c *SchedulerImpCall) AsNextRun() *SchedulerImpNextRunCall {
	return c.nextRun
}

// AsScheduleAt returns the call cast to SchedulerImpScheduleAtCall for accessing call details.
// Returns nil if the call was not to ScheduleAt.
func (c *SchedulerImpCall) AsScheduleAt() *SchedulerImpScheduleAtCall {
	return c.scheduleAt
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *SchedulerImpCall) Done() bool {
	if c.scheduleAt != nil {
		return c.scheduleAt.done
	}
	if c.delay != nil {
		return c.delay.done
	}
	if c.nextRun != nil {
		return c.nextRun.done
	}
	if c.getInterval != nil {
		return c.getInterval.done
	}
	return false
}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *SchedulerImpCall) Name() string {
	if c.scheduleAt != nil {
		return "ScheduleAt"
	}
	if c.delay != nil {
		return "Delay"
	}
	if c.nextRun != nil {
		return "NextRun"
	}
	if c.getInterval != nil {
		return "GetInterval"
	}
	return ""
}

// SchedulerImpDelayBuilder provides a fluent API for setting expectations on Delay calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type SchedulerImpDelayBuilder struct {
	imp     *SchedulerImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Delay call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *SchedulerImpDelayBuilder) ExpectArgsAre(taskID string, duration time.Duration) *SchedulerImpDelayCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		if callToCheck.Name() != "Delay" {
			return false
		}
		methodCall := callToCheck.AsDelay()
		if methodCall.taskID != taskID {
			return false
		}
		if !_reflect.DeepEqual(methodCall.duration, duration) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsDelay()
}

// ExpectArgsShould waits for a Delay call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *SchedulerImpDelayBuilder) ExpectArgsShould(taskID any, duration any) *SchedulerImpDelayCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		if callToCheck.Name() != "Delay" {
			return false
		}
		methodCall := callToCheck.AsDelay()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.taskID, taskID)
		if !ok {
			return false
		}
		ok, _ = _imptest.MatchValue(methodCall.duration, duration)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsDelay()
}

// InjectPanic waits for a Delay call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *SchedulerImpDelayBuilder) InjectPanic(msg any) *SchedulerImpDelayCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		return callToCheck.Name() == "Delay"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsDelay()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Delay call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *SchedulerImpDelayBuilder) InjectResult(result error) *SchedulerImpDelayCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		return callToCheck.Name() == "Delay"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsDelay()
	methodCall.InjectResult(result)
	return methodCall
}

// SchedulerImpDelayCall represents a captured call to the Delay method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type SchedulerImpDelayCall struct {
	responseChan chan SchedulerImpDelayCallResponse
	done         bool
	taskID       string
	duration     time.Duration
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *SchedulerImpDelayCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- SchedulerImpDelayCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *SchedulerImpDelayCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- SchedulerImpDelayCallResponse{Type: "return", Result0: result}
}

// SchedulerImpDelayCallResponse holds the response configuration for the Delay method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type SchedulerImpDelayCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// SchedulerImpExpectCallIs provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent SchedulerImp to configure timeouts.
type SchedulerImpExpectCallIs struct {
	imp     *SchedulerImp
	timeout _time.Duration
}

// Delay returns a builder for setting expectations on Delay method calls.
func (e *SchedulerImpExpectCallIs) Delay() *SchedulerImpDelayBuilder {
	return &SchedulerImpDelayBuilder{imp: e.imp, timeout: e.timeout}
}

// GetInterval returns a builder for setting expectations on GetInterval method calls.
func (e *SchedulerImpExpectCallIs) GetInterval() *SchedulerImpGetIntervalBuilder {
	return &SchedulerImpGetIntervalBuilder{imp: e.imp, timeout: e.timeout}
}

// NextRun returns a builder for setting expectations on NextRun method calls.
func (e *SchedulerImpExpectCallIs) NextRun() *SchedulerImpNextRunBuilder {
	return &SchedulerImpNextRunBuilder{imp: e.imp, timeout: e.timeout}
}

// ScheduleAt returns a builder for setting expectations on ScheduleAt method calls.
func (e *SchedulerImpExpectCallIs) ScheduleAt() *SchedulerImpScheduleAtBuilder {
	return &SchedulerImpScheduleAtBuilder{imp: e.imp, timeout: e.timeout}
}

// SchedulerImpGetIntervalBuilder provides a fluent API for setting expectations on GetInterval calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type SchedulerImpGetIntervalBuilder struct {
	imp     *SchedulerImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a GetInterval call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *SchedulerImpGetIntervalBuilder) ExpectArgsAre(taskID string) *SchedulerImpGetIntervalCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		if callToCheck.Name() != "GetInterval" {
			return false
		}
		methodCall := callToCheck.AsGetInterval()
		if methodCall.taskID != taskID {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsGetInterval()
}

// ExpectArgsShould waits for a GetInterval call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *SchedulerImpGetIntervalBuilder) ExpectArgsShould(taskID any) *SchedulerImpGetIntervalCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		if callToCheck.Name() != "GetInterval" {
			return false
		}
		methodCall := callToCheck.AsGetInterval()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.taskID, taskID)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsGetInterval()
}

// InjectPanic waits for a GetInterval call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *SchedulerImpGetIntervalBuilder) InjectPanic(msg any) *SchedulerImpGetIntervalCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		return callToCheck.Name() == "GetInterval"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsGetInterval()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a GetInterval call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *SchedulerImpGetIntervalBuilder) InjectResult(result time.Duration) *SchedulerImpGetIntervalCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		return callToCheck.Name() == "GetInterval"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsGetInterval()
	methodCall.InjectResult(result)
	return methodCall
}

// SchedulerImpGetIntervalCall represents a captured call to the GetInterval method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type SchedulerImpGetIntervalCall struct {
	responseChan chan SchedulerImpGetIntervalCallResponse
	done         bool
	taskID       string
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *SchedulerImpGetIntervalCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- SchedulerImpGetIntervalCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *SchedulerImpGetIntervalCall) InjectResult(result time.Duration) {
	c.done = true
	c.responseChan <- SchedulerImpGetIntervalCallResponse{Type: "return", Result0: result}
}

// SchedulerImpGetIntervalCallResponse holds the response configuration for the GetInterval method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type SchedulerImpGetIntervalCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    time.Duration
	PanicValue any
}

// SchedulerImpMock provides the mock implementation of the interface.
// Pass SchedulerImpMock to code under test that expects the interface implementation.
// Use the parent SchedulerImp controller to set expectations and inject responses.
type SchedulerImpMock struct {
	imp *SchedulerImp
}

// Delay implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *SchedulerImpMock) Delay(taskID string, duration time.Duration) error {
	responseChan := make(chan SchedulerImpDelayCallResponse, 1)

	call := &SchedulerImpDelayCall{
		responseChan: responseChan,
		taskID:       taskID,
		duration:     duration,
	}

	callEvent := &SchedulerImpCall{
		delay: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// GetInterval implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *SchedulerImpMock) GetInterval(taskID string) time.Duration {
	responseChan := make(chan SchedulerImpGetIntervalCallResponse, 1)

	call := &SchedulerImpGetIntervalCall{
		responseChan: responseChan,
		taskID:       taskID,
	}

	callEvent := &SchedulerImpCall{
		getInterval: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// NextRun implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *SchedulerImpMock) NextRun() (time.Time, error) {
	responseChan := make(chan SchedulerImpNextRunCallResponse, 1)

	call := &SchedulerImpNextRunCall{
		responseChan: responseChan,
	}

	callEvent := &SchedulerImpCall{
		nextRun: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// ScheduleAt implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *SchedulerImpMock) ScheduleAt(taskID string, when time.Time) error {
	responseChan := make(chan SchedulerImpScheduleAtCallResponse, 1)

	call := &SchedulerImpScheduleAtCall{
		responseChan: responseChan,
		taskID:       taskID,
		when:         when,
	}

	callEvent := &SchedulerImpCall{
		scheduleAt: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// SchedulerImpNextRunBuilder provides a fluent API for setting expectations on NextRun calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type SchedulerImpNextRunBuilder struct {
	imp     *SchedulerImp
	timeout _time.Duration
}

// InjectPanic waits for a NextRun call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *SchedulerImpNextRunBuilder) InjectPanic(msg any) *SchedulerImpNextRunCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		return callToCheck.Name() == "NextRun"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsNextRun()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a NextRun call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *SchedulerImpNextRunBuilder) InjectResults(r0 time.Time, r1 error) *SchedulerImpNextRunCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		return callToCheck.Name() == "NextRun"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsNextRun()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// SchedulerImpNextRunCall represents a captured call to the NextRun method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type SchedulerImpNextRunCall struct {
	responseChan chan SchedulerImpNextRunCallResponse
	done         bool
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *SchedulerImpNextRunCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- SchedulerImpNextRunCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *SchedulerImpNextRunCall) InjectResults(r0 time.Time, r1 error) {
	c.done = true
	resp := SchedulerImpNextRunCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// SchedulerImpNextRunCallResponse holds the response configuration for the NextRun method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type SchedulerImpNextRunCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    time.Time
	Result1    error
	PanicValue any
}

// SchedulerImpScheduleAtBuilder provides a fluent API for setting expectations on ScheduleAt calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type SchedulerImpScheduleAtBuilder struct {
	imp     *SchedulerImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a ScheduleAt call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *SchedulerImpScheduleAtBuilder) ExpectArgsAre(taskID string, when time.Time) *SchedulerImpScheduleAtCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		if callToCheck.Name() != "ScheduleAt" {
			return false
		}
		methodCall := callToCheck.AsScheduleAt()
		if methodCall.taskID != taskID {
			return false
		}
		if !_reflect.DeepEqual(methodCall.when, when) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsScheduleAt()
}

// ExpectArgsShould waits for a ScheduleAt call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *SchedulerImpScheduleAtBuilder) ExpectArgsShould(taskID any, when any) *SchedulerImpScheduleAtCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		if callToCheck.Name() != "ScheduleAt" {
			return false
		}
		methodCall := callToCheck.AsScheduleAt()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.taskID, taskID)
		if !ok {
			return false
		}
		ok, _ = _imptest.MatchValue(methodCall.when, when)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsScheduleAt()
}

// InjectPanic waits for a ScheduleAt call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *SchedulerImpScheduleAtBuilder) InjectPanic(msg any) *SchedulerImpScheduleAtCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		return callToCheck.Name() == "ScheduleAt"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsScheduleAt()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a ScheduleAt call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *SchedulerImpScheduleAtBuilder) InjectResult(result error) *SchedulerImpScheduleAtCall {
	validator := func(callToCheck *SchedulerImpCall) bool {
		return callToCheck.Name() == "ScheduleAt"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsScheduleAt()
	methodCall.InjectResult(result)
	return methodCall
}

// SchedulerImpScheduleAtCall represents a captured call to the ScheduleAt method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type SchedulerImpScheduleAtCall struct {
	responseChan chan SchedulerImpScheduleAtCallResponse
	done         bool
	taskID       string
	when         time.Time
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *SchedulerImpScheduleAtCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- SchedulerImpScheduleAtCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *SchedulerImpScheduleAtCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- SchedulerImpScheduleAtCallResponse{Type: "return", Result0: result}
}

// SchedulerImpScheduleAtCallResponse holds the response configuration for the ScheduleAt method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type SchedulerImpScheduleAtCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// SchedulerImpTimed provides timeout-configured expectation methods.
// Access via SchedulerImp.Within(duration) to set a timeout for expectations.
type SchedulerImpTimed struct {
	ExpectCallIs *SchedulerImpExpectCallIs
}

// unexported variables.
var (
	// Compile-time verification that SchedulerImpMock implements timeconflict.Scheduler.
	_ timeconflict.Scheduler = (*SchedulerImpMock)(nil)
)
