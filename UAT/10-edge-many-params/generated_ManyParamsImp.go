// Code generated by impgen. DO NOT EDIT.

package many_params

import "github.com/toejough/imptest/imptest"
import "testing"
import "time"

type ManyParamsImpMock struct {
	imp *ManyParamsImp
}

type ManyParamsImp struct {
	*imptest.Controller[*ManyParamsImpCall]
	Mock         *ManyParamsImpMock
	ExpectCallIs *ManyParamsImpExpectCallIs
	currentCall  *ManyParamsImpCall
}

type ManyParamsImpProcessCall struct {
	responseChan chan ManyParamsImpProcessCallResponse
	done         bool
	a            int
	b            int
	c            int
	d            int
	e            int
	f            int
	g            int
	h            int
	i            int
	j            int
}

type ManyParamsImpProcessCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    string
	PanicValue any
}

func (c *ManyParamsImpProcessCall) InjectResult(result string) {
	c.done = true
	c.responseChan <- ManyParamsImpProcessCallResponse{Type: "return", Result0: result}
}
func (c *ManyParamsImpProcessCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- ManyParamsImpProcessCallResponse{Type: "panic", PanicValue: msg}
}

func (m *ManyParamsImpMock) Process(a int, b int, c int, d int, e int, f int, g int, h int, i int, j int) string {
	responseChan := make(chan ManyParamsImpProcessCallResponse, 1)

	call := &ManyParamsImpProcessCall{
		responseChan: responseChan,
		a:            a,
		b:            b,
		c:            c,
		d:            d,
		e:            e,
		f:            f,
		g:            g,
		h:            h,
		i:            i,
		j:            j,
	}

	callEvent := &ManyParamsImpCall{
		Process: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

type ManyParamsImpCall struct {
	Process *ManyParamsImpProcessCall
}

func (c *ManyParamsImpCall) Name() string {
	if c.Process != nil {
		return "Process"
	}
	return ""
}

func (c *ManyParamsImpCall) Done() bool {
	if c.Process != nil {
		return c.Process.done
	}
	return false
}

func (c *ManyParamsImpCall) AsProcess() *ManyParamsImpProcessCall {
	return c.Process
}

type ManyParamsImpExpectCallIs struct {
	imp     *ManyParamsImp
	timeout time.Duration
}

type ManyParamsImpProcessBuilder struct {
	imp     *ManyParamsImp
	timeout time.Duration
}

func (e *ManyParamsImpExpectCallIs) Process() *ManyParamsImpProcessBuilder {
	return &ManyParamsImpProcessBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *ManyParamsImpProcessBuilder) ExpectArgsAre(a int, b int, c int, d int, e int, f int, g int, h int, i int, j int) *ManyParamsImpProcessCall {
	validator := func(callToCheck *ManyParamsImpCall) bool {
		if callToCheck.Name() != "Process" {
			return false
		}
		methodCall := callToCheck.AsProcess()
		if methodCall.a != a {
			return false
		}
		if methodCall.b != b {
			return false
		}
		if methodCall.c != c {
			return false
		}
		if methodCall.d != d {
			return false
		}
		if methodCall.e != e {
			return false
		}
		if methodCall.f != f {
			return false
		}
		if methodCall.g != g {
			return false
		}
		if methodCall.h != h {
			return false
		}
		if methodCall.i != i {
			return false
		}
		if methodCall.j != j {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsProcess()
}

func (bldr *ManyParamsImpProcessBuilder) ExpectArgsShould(a any, b any, c any, d any, e any, f any, g any, h any, i any, j any) *ManyParamsImpProcessCall {
	validator := func(callToCheck *ManyParamsImpCall) bool {
		if callToCheck.Name() != "Process" {
			return false
		}
		methodCall := callToCheck.AsProcess()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.a, a)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.b, b)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.c, c)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.d, d)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.e, e)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.f, f)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.g, g)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.h, h)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.i, i)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.j, j)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsProcess()
}

func (bldr *ManyParamsImpProcessBuilder) InjectResult(result string) *ManyParamsImpProcessCall {
	validator := func(callToCheck *ManyParamsImpCall) bool {
		return callToCheck.Name() == "Process"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsProcess()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *ManyParamsImpProcessBuilder) InjectPanic(msg any) *ManyParamsImpProcessCall {
	validator := func(callToCheck *ManyParamsImpCall) bool {
		return callToCheck.Name() == "Process"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsProcess()
	methodCall.InjectPanic(msg)
	return methodCall
}

type ManyParamsImpTimed struct {
	ExpectCallIs *ManyParamsImpExpectCallIs
}

func (i *ManyParamsImp) Within(d time.Duration) *ManyParamsImpTimed {
	return &ManyParamsImpTimed{
		ExpectCallIs: &ManyParamsImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *ManyParamsImp) GetCurrentCall() *ManyParamsImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *ManyParamsImpCall) bool { return true })
	return i.currentCall
}

func NewManyParamsImp(t *testing.T) *ManyParamsImp {
	imp := &ManyParamsImp{
		Controller: imptest.NewController[*ManyParamsImpCall](t),
	}
	imp.Mock = &ManyParamsImpMock{imp: imp}
	imp.ExpectCallIs = &ManyParamsImpExpectCallIs{imp: imp}
	return imp
}
