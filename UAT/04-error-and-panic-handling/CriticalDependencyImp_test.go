// Code generated by impgen. DO NOT EDIT.

package safety_test

import "sync"
import "testing"
import "time"

type CriticalDependencyImpMock struct {
	imp *CriticalDependencyImp
}

type CriticalDependencyImp struct {
	t            *testing.T
	Mock         *CriticalDependencyImpMock
	callChan     chan *CriticalDependencyImpCall
	ExpectCallIs *CriticalDependencyImpExpectCallIs
	currentCall  *CriticalDependencyImpCall
	callQueue    []*CriticalDependencyImpCall
	queueLock    sync.Mutex
}

type CriticalDependencyImpDoWorkCall struct {
	responseChan chan CriticalDependencyImpDoWorkCallResponse
	done         bool
}

type CriticalDependencyImpDoWorkCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue any
}

func (c *CriticalDependencyImpDoWorkCall) Resolve() {
	c.done = true
	c.responseChan <- CriticalDependencyImpDoWorkCallResponse{Type: "resolve"}
}
func (c *CriticalDependencyImpDoWorkCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- CriticalDependencyImpDoWorkCallResponse{Type: "panic", PanicValue: msg}
}

func (m *CriticalDependencyImpMock) DoWork() {
	responseChan := make(chan CriticalDependencyImpDoWorkCallResponse, 1)

	call := &CriticalDependencyImpDoWorkCall{
		responseChan: responseChan,
	}

	callEvent := &CriticalDependencyImpCall{
		DoWork: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

type CriticalDependencyImpCall struct {
	DoWork *CriticalDependencyImpDoWorkCall
}

func (c *CriticalDependencyImpCall) Name() string {
	if c.DoWork != nil {
		return "DoWork"
	}
	return ""
}

func (c *CriticalDependencyImpCall) Done() bool {
	if c.DoWork != nil {
		return c.DoWork.done
	}
	return false
}

func (c *CriticalDependencyImpCall) AsDoWork() *CriticalDependencyImpDoWorkCall { return c.DoWork }

type CriticalDependencyImpExpectCallIs struct {
	imp     *CriticalDependencyImp
	timeout time.Duration
}

type CriticalDependencyImpDoWorkBuilder struct {
	imp     *CriticalDependencyImp
	timeout time.Duration
}

func (e *CriticalDependencyImpExpectCallIs) DoWork() *CriticalDependencyImpDoWorkBuilder {
	return &CriticalDependencyImpDoWorkBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *CriticalDependencyImpDoWorkBuilder) ExpectArgsAre() *CriticalDependencyImpDoWorkCall {
	validator := func(c *CriticalDependencyImpCall) bool {
		if c.Name() != "DoWork" {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsDoWork()
}

func (bldr *CriticalDependencyImpDoWorkBuilder) ExpectArgsShould() *CriticalDependencyImpDoWorkCall {
	validator := func(c *CriticalDependencyImpCall) bool {
		if c.Name() != "DoWork" {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsDoWork()
}

func (bldr *CriticalDependencyImpDoWorkBuilder) Resolve() *CriticalDependencyImpDoWorkCall {
	validator := func(c *CriticalDependencyImpCall) bool {
		return c.Name() == "DoWork"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsDoWork()
	methodCall.Resolve()
	return methodCall
}

func (bldr *CriticalDependencyImpDoWorkBuilder) InjectPanic(msg any) *CriticalDependencyImpDoWorkCall {
	validator := func(c *CriticalDependencyImpCall) bool {
		return c.Name() == "DoWork"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsDoWork()
	methodCall.InjectPanic(msg)
	return methodCall
}

type CriticalDependencyImpTimed struct {
	ExpectCallIs *CriticalDependencyImpExpectCallIs
}

func (i *CriticalDependencyImp) Within(d time.Duration) *CriticalDependencyImpTimed {
	return &CriticalDependencyImpTimed{
		ExpectCallIs: &CriticalDependencyImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *CriticalDependencyImp) GetCall(
	d time.Duration, validator func(*CriticalDependencyImpCall) bool,
) *CriticalDependencyImpCall {
	i.queueLock.Lock()

	// Check queue first while holding lock
	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			i.queueLock.Unlock()
			return call
		}
	}

	// Release lock before blocking on channel to avoid deadlock
	i.queueLock.Unlock()

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it - need lock to access shared queue
			i.queueLock.Lock()
			i.callQueue = append(i.callQueue, call)
			i.queueLock.Unlock()
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *CriticalDependencyImp) GetCurrentCall() *CriticalDependencyImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *CriticalDependencyImpCall) bool { return true })
	return i.currentCall
}

func NewCriticalDependencyImp(t *testing.T) *CriticalDependencyImp {
	imp := &CriticalDependencyImp{
		t:        t,
		callChan: make(chan *CriticalDependencyImpCall, 1),
	}
	imp.Mock = &CriticalDependencyImpMock{imp: imp}
	imp.ExpectCallIs = &CriticalDependencyImpExpectCallIs{imp: imp}
	return imp
}
