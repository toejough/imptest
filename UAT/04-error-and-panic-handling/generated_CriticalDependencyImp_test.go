// Code generated by impgen. DO NOT EDIT.

package safety_test

import "github.com/toejough/imptest/imptest"
import "testing"
import "time"

type CriticalDependencyImpMock struct {
	imp *CriticalDependencyImp
}

type CriticalDependencyImp struct {
	*imptest.Controller[*CriticalDependencyImpCall]
	Mock         *CriticalDependencyImpMock
	ExpectCallIs *CriticalDependencyImpExpectCallIs
	currentCall  *CriticalDependencyImpCall
}

type CriticalDependencyImpDoWorkCall struct {
	responseChan chan CriticalDependencyImpDoWorkCallResponse
	done         bool
}

type CriticalDependencyImpDoWorkCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue any
}

func (c *CriticalDependencyImpDoWorkCall) Resolve() {
	c.done = true
	c.responseChan <- CriticalDependencyImpDoWorkCallResponse{Type: "resolve"}
}
func (c *CriticalDependencyImpDoWorkCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- CriticalDependencyImpDoWorkCallResponse{Type: "panic", PanicValue: msg}
}

func (m *CriticalDependencyImpMock) DoWork() {
	responseChan := make(chan CriticalDependencyImpDoWorkCallResponse, 1)

	call := &CriticalDependencyImpDoWorkCall{
		responseChan: responseChan,
	}

	callEvent := &CriticalDependencyImpCall{
		DoWork: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

type CriticalDependencyImpCall struct {
	DoWork *CriticalDependencyImpDoWorkCall
}

func (c *CriticalDependencyImpCall) Name() string {
	if c.DoWork != nil {
		return "DoWork"
	}
	return ""
}

func (c *CriticalDependencyImpCall) Done() bool {
	if c.DoWork != nil {
		return c.DoWork.done
	}
	return false
}

func (c *CriticalDependencyImpCall) AsDoWork() *CriticalDependencyImpDoWorkCall {
	return c.DoWork
}

type CriticalDependencyImpExpectCallIs struct {
	imp     *CriticalDependencyImp
	timeout time.Duration
}

type CriticalDependencyImpDoWorkBuilder struct {
	imp     *CriticalDependencyImp
	timeout time.Duration
}

func (e *CriticalDependencyImpExpectCallIs) DoWork() *CriticalDependencyImpDoWorkBuilder {
	return &CriticalDependencyImpDoWorkBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *CriticalDependencyImpDoWorkBuilder) Resolve() *CriticalDependencyImpDoWorkCall {
	validator := func(c *CriticalDependencyImpCall) bool {
		return c.Name() == "DoWork"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsDoWork()
	methodCall.Resolve()
	return methodCall
}

func (bldr *CriticalDependencyImpDoWorkBuilder) InjectPanic(msg any) *CriticalDependencyImpDoWorkCall {
	validator := func(c *CriticalDependencyImpCall) bool {
		return c.Name() == "DoWork"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsDoWork()
	methodCall.InjectPanic(msg)
	return methodCall
}

type CriticalDependencyImpTimed struct {
	ExpectCallIs *CriticalDependencyImpExpectCallIs
}

func (i *CriticalDependencyImp) Within(d time.Duration) *CriticalDependencyImpTimed {
	return &CriticalDependencyImpTimed{
		ExpectCallIs: &CriticalDependencyImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *CriticalDependencyImp) GetCurrentCall() *CriticalDependencyImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *CriticalDependencyImpCall) bool { return true })
	return i.currentCall
}

func NewCriticalDependencyImp(t *testing.T) *CriticalDependencyImp {
	imp := &CriticalDependencyImp{
		Controller: imptest.NewController[*CriticalDependencyImpCall](t),
	}
	imp.Mock = &CriticalDependencyImpMock{imp: imp}
	imp.ExpectCallIs = &CriticalDependencyImpExpectCallIs{imp: imp}
	return imp
}
