// Code generated by impgen. DO NOT EDIT.

package visitor_test

import _fmt "fmt"
import _imptest "github.com/toejough/imptest/imptest"
import _reflect "reflect"
import _testing "testing"
import _time "time"
import visitor "github.com/toejough/imptest/UAT/15-callback-visitor"
import fs "io/fs"

// TreeWalkerImp is the test controller for mocking the interface.
// Create with NewTreeWalkerImp(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := NewTreeWalkerImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type TreeWalkerImp struct {
	*_imptest.Controller[*TreeWalkerImpCall]
	Mock         *TreeWalkerImpMock
	ExpectCallIs *TreeWalkerImpExpectCallIs
	currentCall  *TreeWalkerImpCall
}

// NewTreeWalkerImp creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := NewTreeWalkerImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func NewTreeWalkerImp(t *_testing.T) *TreeWalkerImp {
	imp := &TreeWalkerImp{
		Controller: _imptest.NewController[*TreeWalkerImpCall](t),
	}
	imp.Mock = &TreeWalkerImpMock{imp: imp}
	imp.ExpectCallIs = &TreeWalkerImpExpectCallIs{imp: imp}
	return imp
}

// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *TreeWalkerImp) GetCurrentCall() *TreeWalkerImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *TreeWalkerImpCall) bool { return true })
	return i.currentCall
}

// Within configures a timeout for expectations and returns a TreeWalkerImpTimed for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*_time.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *TreeWalkerImp) Within(d _time.Duration) *TreeWalkerImpTimed {
	return &TreeWalkerImpTimed{
		ExpectCallIs: &TreeWalkerImpExpectCallIs{imp: i, timeout: d},
	}
}

// TreeWalkerImpCall represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{Method}() to access typed call details.
type TreeWalkerImpCall struct {
	walk              *TreeWalkerImpWalkCall
	walkWithNamedType *TreeWalkerImpWalkWithNamedTypeCall
}

// AsWalk returns the call cast to TreeWalkerImpWalkCall for accessing call details.
// Returns nil if the call was not to Walk.
func (c *TreeWalkerImpCall) AsWalk() *TreeWalkerImpWalkCall {
	return c.walk
}

// AsWalkWithNamedType returns the call cast to TreeWalkerImpWalkWithNamedTypeCall for accessing call details.
// Returns nil if the call was not to WalkWithNamedType.
func (c *TreeWalkerImpCall) AsWalkWithNamedType() *TreeWalkerImpWalkWithNamedTypeCall {
	return c.walkWithNamedType
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *TreeWalkerImpCall) Done() bool {
	if c.walk != nil {
		return c.walk.done
	}
	if c.walkWithNamedType != nil {
		return c.walkWithNamedType.done
	}
	return false
}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *TreeWalkerImpCall) Name() string {
	if c.walk != nil {
		return "Walk"
	}
	if c.walkWithNamedType != nil {
		return "WalkWithNamedType"
	}
	return ""
}

// TreeWalkerImpExpectCallIs provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent TreeWalkerImp to configure timeouts.
type TreeWalkerImpExpectCallIs struct {
	imp     *TreeWalkerImp
	timeout _time.Duration
}

// Walk returns a builder for setting expectations on Walk method calls.
func (e *TreeWalkerImpExpectCallIs) Walk() *TreeWalkerImpWalkBuilder {
	return &TreeWalkerImpWalkBuilder{imp: e.imp, timeout: e.timeout}
}

// WalkWithNamedType returns a builder for setting expectations on WalkWithNamedType method calls.
func (e *TreeWalkerImpExpectCallIs) WalkWithNamedType() *TreeWalkerImpWalkWithNamedTypeBuilder {
	return &TreeWalkerImpWalkWithNamedTypeBuilder{imp: e.imp, timeout: e.timeout}
}

// TreeWalkerImpMock provides the mock implementation of the interface.
// Pass TreeWalkerImpMock to code under test that expects the interface implementation.
// Use the parent TreeWalkerImp controller to set expectations and inject responses.
type TreeWalkerImpMock struct {
	imp *TreeWalkerImp
}

// Walk implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *TreeWalkerImpMock) Walk(root string, fn func(string, fs.DirEntry, error) error) error {
	responseChan := make(chan TreeWalkerImpWalkCallResponse, 1)
	callbackFnChan := make(chan TreeWalkerImpWalkCallFnRequest)

	call := &TreeWalkerImpWalkCall{
		responseChan:   responseChan,
		callbackFnChan: callbackFnChan,
		root:           root,
		fn:             fn,
	}

	callEvent := &TreeWalkerImpCall{
		walk: call,
	}

	m.imp.CallChan <- callEvent

	// Handle callback invocations and final response
	var resp TreeWalkerImpWalkCallResponse
	for {
		select {
		case cbReq := <-callbackFnChan:
			// Direct invocation with typed values - no type assertions needed
			result0 := fn(cbReq.Path, cbReq.D, cbReq.Err)
			cbReq.ResultChan <- TreeWalkerImpWalkCallFnResponse{Result0: result0}
		case resp = <-responseChan:
			// Final response received
			if resp.Type == "panic" {
				panic(resp.PanicValue)
			}
			return resp.Result0
		}
	}
}

// WalkWithNamedType implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *TreeWalkerImpMock) WalkWithNamedType(root string, fn visitor.WalkFunc) error {
	responseChan := make(chan TreeWalkerImpWalkWithNamedTypeCallResponse, 1)

	call := &TreeWalkerImpWalkWithNamedTypeCall{
		responseChan: responseChan,
		root:         root,
		fn:           fn,
	}

	callEvent := &TreeWalkerImpCall{
		walkWithNamedType: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// TreeWalkerImpTimed provides timeout-configured expectation methods.
// Access via TreeWalkerImp.Within(duration) to set a timeout for expectations.
type TreeWalkerImpTimed struct {
	ExpectCallIs *TreeWalkerImpExpectCallIs
}

// TreeWalkerImpWalkBuilder provides a fluent API for setting expectations on Walk calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type TreeWalkerImpWalkBuilder struct {
	imp     *TreeWalkerImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Walk call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *TreeWalkerImpWalkBuilder) ExpectArgsAre(root string, fn func(string, fs.DirEntry, error) error) *TreeWalkerImpWalkCall {
	validator := func(callToCheck *TreeWalkerImpCall) bool {
		if callToCheck.Name() != "Walk" {
			return false
		}
		methodCall := callToCheck.AsWalk()
		if methodCall.root != root {
			return false
		}
		if !_reflect.DeepEqual(methodCall.fn, fn) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsWalk()
}

// ExpectArgsShould waits for a Walk call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *TreeWalkerImpWalkBuilder) ExpectArgsShould(root any, fn any) *TreeWalkerImpWalkCall {
	validator := func(callToCheck *TreeWalkerImpCall) bool {
		if callToCheck.Name() != "Walk" {
			return false
		}
		methodCall := callToCheck.AsWalk()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.root, root)
		if !ok {
			return false
		}
		ok, _ = _imptest.MatchValue(methodCall.fn, fn)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsWalk()
}

// InjectPanic waits for a Walk call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *TreeWalkerImpWalkBuilder) InjectPanic(msg any) *TreeWalkerImpWalkCall {
	validator := func(callToCheck *TreeWalkerImpCall) bool {
		return callToCheck.Name() == "Walk"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsWalk()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Walk call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *TreeWalkerImpWalkBuilder) InjectResult(result error) *TreeWalkerImpWalkCall {
	validator := func(callToCheck *TreeWalkerImpCall) bool {
		return callToCheck.Name() == "Walk"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsWalk()
	methodCall.InjectResult(result)
	return methodCall
}

// TreeWalkerImpWalkCall represents a captured call to the Walk method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type TreeWalkerImpWalkCall struct {
	responseChan chan TreeWalkerImpWalkCallResponse
	done         bool
	root         string
	fn           func(string, fs.DirEntry, error) error
	// Callback coordination channels
	callbackFnChan chan TreeWalkerImpWalkCallFnRequest
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *TreeWalkerImpWalkCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- TreeWalkerImpWalkCallResponse{Type: "panic", PanicValue: msg}
} // TreeWalkerImpWalkCallFnCallbackResult holds the result of invoking the fn callback.

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *TreeWalkerImpWalkCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- TreeWalkerImpWalkCallResponse{Type: "return", Result0: result}
}

// InvokeFn invokes the fn callback with the provided arguments.
// Returns a result object that can verify the callback's return values.
func (c *TreeWalkerImpWalkCall) InvokeFn(path string, d fs.DirEntry, err error) *TreeWalkerImpWalkCallFnCallbackResult {
	resultChan := make(chan TreeWalkerImpWalkCallFnResponse)
	c.callbackFnChan <- TreeWalkerImpWalkCallFnRequest{
		Path:       path,
		D:          d,
		Err:        err,
		ResultChan: resultChan,
	}
	resp := <-resultChan
	return &TreeWalkerImpWalkCallFnCallbackResult{result0: resp.Result0}
}

type TreeWalkerImpWalkCallFnCallbackResult struct {
	result0 error
}

// ExpectReturned verifies that the callback returned the expected values.
func (r *TreeWalkerImpWalkCallFnCallbackResult) ExpectReturned(expected0 error) {
	if !_reflect.DeepEqual(r.result0, expected0) {
		panic(_fmt.Sprintf("callback result[0] = %v, expected %v", r.result0, expected0))
	}
}

// TreeWalkerImpWalkCallFnRequest carries callback invocation data for the fn parameter.
type TreeWalkerImpWalkCallFnRequest struct {
	Path       string
	D          fs.DirEntry
	Err        error
	ResultChan chan TreeWalkerImpWalkCallFnResponse
}

// TreeWalkerImpWalkCallFnResponse carries callback return values for the fn parameter.
type TreeWalkerImpWalkCallFnResponse struct {
	Result0 error
}

// TreeWalkerImpWalkCallResponse holds the response configuration for the Walk method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type TreeWalkerImpWalkCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// TreeWalkerImpWalkWithNamedTypeBuilder provides a fluent API for setting expectations on WalkWithNamedType calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type TreeWalkerImpWalkWithNamedTypeBuilder struct {
	imp     *TreeWalkerImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a WalkWithNamedType call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *TreeWalkerImpWalkWithNamedTypeBuilder) ExpectArgsAre(root string, fn visitor.WalkFunc) *TreeWalkerImpWalkWithNamedTypeCall {
	validator := func(callToCheck *TreeWalkerImpCall) bool {
		if callToCheck.Name() != "WalkWithNamedType" {
			return false
		}
		methodCall := callToCheck.AsWalkWithNamedType()
		if methodCall.root != root {
			return false
		}
		if !_reflect.DeepEqual(methodCall.fn, fn) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsWalkWithNamedType()
}

// ExpectArgsShould waits for a WalkWithNamedType call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *TreeWalkerImpWalkWithNamedTypeBuilder) ExpectArgsShould(root any, fn any) *TreeWalkerImpWalkWithNamedTypeCall {
	validator := func(callToCheck *TreeWalkerImpCall) bool {
		if callToCheck.Name() != "WalkWithNamedType" {
			return false
		}
		methodCall := callToCheck.AsWalkWithNamedType()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.root, root)
		if !ok {
			return false
		}
		ok, _ = _imptest.MatchValue(methodCall.fn, fn)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsWalkWithNamedType()
}

// InjectPanic waits for a WalkWithNamedType call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *TreeWalkerImpWalkWithNamedTypeBuilder) InjectPanic(msg any) *TreeWalkerImpWalkWithNamedTypeCall {
	validator := func(callToCheck *TreeWalkerImpCall) bool {
		return callToCheck.Name() == "WalkWithNamedType"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsWalkWithNamedType()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a WalkWithNamedType call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *TreeWalkerImpWalkWithNamedTypeBuilder) InjectResult(result error) *TreeWalkerImpWalkWithNamedTypeCall {
	validator := func(callToCheck *TreeWalkerImpCall) bool {
		return callToCheck.Name() == "WalkWithNamedType"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsWalkWithNamedType()
	methodCall.InjectResult(result)
	return methodCall
}

// TreeWalkerImpWalkWithNamedTypeCall represents a captured call to the WalkWithNamedType method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type TreeWalkerImpWalkWithNamedTypeCall struct {
	responseChan chan TreeWalkerImpWalkWithNamedTypeCallResponse
	done         bool
	root         string
	fn           visitor.WalkFunc
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *TreeWalkerImpWalkWithNamedTypeCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- TreeWalkerImpWalkWithNamedTypeCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *TreeWalkerImpWalkWithNamedTypeCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- TreeWalkerImpWalkWithNamedTypeCallResponse{Type: "return", Result0: result}
}

// TreeWalkerImpWalkWithNamedTypeCallResponse holds the response configuration for the WalkWithNamedType method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type TreeWalkerImpWalkWithNamedTypeCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// unexported variables.
var (
	// Compile-time verification that TreeWalkerImpMock implements visitor.TreeWalker.
	_ visitor.TreeWalker = (*TreeWalkerImpMock)(nil)
)
