package run_test

// Code generated by impgen. DO NOT EDIT.

import "github.com/toejough/imptest/imptest"
import "sync"
import "testing"
import "time"

type IntOpsImpMock struct {
	imp *IntOpsImp
}

type IntOpsImp struct {
	t            *testing.T
	Mock         *IntOpsImpMock
	callChan     chan *IntOpsImpCall
	ExpectCallIs *IntOpsImpExpectCallIs
	currentCall  *IntOpsImpCall
	callQueue    []*IntOpsImpCall
	queueLock    sync.Mutex
}

type IntOpsImpAddCall struct {
	responseChan chan IntOpsImpAddCallResponse
	done         bool
	a            int
	b            int
}

type IntOpsImpAddCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    int
	PanicValue any
}

func (c *IntOpsImpAddCall) InjectResult(result int) {
	c.done = true
	c.responseChan <- IntOpsImpAddCallResponse{Type: "return", Result0: result}
}
func (c *IntOpsImpAddCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- IntOpsImpAddCallResponse{Type: "panic", PanicValue: msg}
}

type IntOpsImpFormatCall struct {
	responseChan chan IntOpsImpFormatCallResponse
	done         bool
	i            int
}

type IntOpsImpFormatCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    string
	PanicValue any
}

func (c *IntOpsImpFormatCall) InjectResult(result string) {
	c.done = true
	c.responseChan <- IntOpsImpFormatCallResponse{Type: "return", Result0: result}
}
func (c *IntOpsImpFormatCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- IntOpsImpFormatCallResponse{Type: "panic", PanicValue: msg}
}

type IntOpsImpPrintCall struct {
	responseChan chan IntOpsImpPrintCallResponse
	done         bool
	s            string
}

type IntOpsImpPrintCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue any
}

func (c *IntOpsImpPrintCall) Resolve() {
	c.done = true
	c.responseChan <- IntOpsImpPrintCallResponse{Type: "resolve"}
}
func (c *IntOpsImpPrintCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- IntOpsImpPrintCallResponse{Type: "panic", PanicValue: msg}
}

func (m *IntOpsImpMock) Add(a int, b int) int {
	responseChan := make(chan IntOpsImpAddCallResponse, 1)

	call := &IntOpsImpAddCall{
		responseChan: responseChan,
		a:            a,
		b:            b,
	}

	callEvent := &IntOpsImpCall{
		Add: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

func (m *IntOpsImpMock) Format(i int) string {
	responseChan := make(chan IntOpsImpFormatCallResponse, 1)

	call := &IntOpsImpFormatCall{
		responseChan: responseChan,
		i:            i,
	}

	callEvent := &IntOpsImpCall{
		Format: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

func (m *IntOpsImpMock) Print(s string) {
	responseChan := make(chan IntOpsImpPrintCallResponse, 1)

	call := &IntOpsImpPrintCall{
		responseChan: responseChan,
		s:            s,
	}

	callEvent := &IntOpsImpCall{
		Print: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

type IntOpsImpCall struct {
	Add    *IntOpsImpAddCall
	Format *IntOpsImpFormatCall
	Print  *IntOpsImpPrintCall
}

func (c *IntOpsImpCall) Name() string {
	if c.Add != nil {
		return "Add"
	}
	if c.Format != nil {
		return "Format"
	}
	if c.Print != nil {
		return "Print"
	}
	return ""
}

func (c *IntOpsImpCall) Done() bool {
	if c.Add != nil {
		return c.Add.done
	}
	if c.Format != nil {
		return c.Format.done
	}
	if c.Print != nil {
		return c.Print.done
	}
	return false
}

func (c *IntOpsImpCall) AsAdd() *IntOpsImpAddCall { return c.Add }

func (c *IntOpsImpCall) AsFormat() *IntOpsImpFormatCall { return c.Format }

func (c *IntOpsImpCall) AsPrint() *IntOpsImpPrintCall { return c.Print }

type IntOpsImpExpectCallIs struct {
	imp     *IntOpsImp
	timeout time.Duration
}

type IntOpsImpAddBuilder struct {
	imp     *IntOpsImp
	timeout time.Duration
}

func (e *IntOpsImpExpectCallIs) Add() *IntOpsImpAddBuilder {
	return &IntOpsImpAddBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *IntOpsImpAddBuilder) ExpectArgsAre(a int, b int) *IntOpsImpAddCall {
	validator := func(c *IntOpsImpCall) bool {
		if c.Name() != "Add" {
			return false
		}
		methodCall := c.AsAdd()
		if methodCall.a != a {
			return false
		}
		if methodCall.b != b {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsAdd()
}

func (bldr *IntOpsImpAddBuilder) ExpectArgsShould(a any, b any) *IntOpsImpAddCall {
	validator := func(c *IntOpsImpCall) bool {
		if c.Name() != "Add" {
			return false
		}
		methodCall := c.AsAdd()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.a, a)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.b, b)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsAdd()
}

func (bldr *IntOpsImpAddBuilder) InjectResult(result int) *IntOpsImpAddCall {
	validator := func(c *IntOpsImpCall) bool {
		return c.Name() == "Add"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsAdd()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *IntOpsImpAddBuilder) InjectPanic(msg any) *IntOpsImpAddCall {
	validator := func(c *IntOpsImpCall) bool {
		return c.Name() == "Add"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsAdd()
	methodCall.InjectPanic(msg)
	return methodCall
}

type IntOpsImpFormatBuilder struct {
	imp     *IntOpsImp
	timeout time.Duration
}

func (e *IntOpsImpExpectCallIs) Format() *IntOpsImpFormatBuilder {
	return &IntOpsImpFormatBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *IntOpsImpFormatBuilder) ExpectArgsAre(i int) *IntOpsImpFormatCall {
	validator := func(c *IntOpsImpCall) bool {
		if c.Name() != "Format" {
			return false
		}
		methodCall := c.AsFormat()
		if methodCall.i != i {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsFormat()
}

func (bldr *IntOpsImpFormatBuilder) ExpectArgsShould(i any) *IntOpsImpFormatCall {
	validator := func(c *IntOpsImpCall) bool {
		if c.Name() != "Format" {
			return false
		}
		methodCall := c.AsFormat()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.i, i)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsFormat()
}

func (bldr *IntOpsImpFormatBuilder) InjectResult(result string) *IntOpsImpFormatCall {
	validator := func(c *IntOpsImpCall) bool {
		return c.Name() == "Format"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsFormat()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *IntOpsImpFormatBuilder) InjectPanic(msg any) *IntOpsImpFormatCall {
	validator := func(c *IntOpsImpCall) bool {
		return c.Name() == "Format"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsFormat()
	methodCall.InjectPanic(msg)
	return methodCall
}

type IntOpsImpPrintBuilder struct {
	imp     *IntOpsImp
	timeout time.Duration
}

func (e *IntOpsImpExpectCallIs) Print() *IntOpsImpPrintBuilder {
	return &IntOpsImpPrintBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *IntOpsImpPrintBuilder) ExpectArgsAre(s string) *IntOpsImpPrintCall {
	validator := func(c *IntOpsImpCall) bool {
		if c.Name() != "Print" {
			return false
		}
		methodCall := c.AsPrint()
		if methodCall.s != s {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsPrint()
}

func (bldr *IntOpsImpPrintBuilder) ExpectArgsShould(s any) *IntOpsImpPrintCall {
	validator := func(c *IntOpsImpCall) bool {
		if c.Name() != "Print" {
			return false
		}
		methodCall := c.AsPrint()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.s, s)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsPrint()
}

func (bldr *IntOpsImpPrintBuilder) Resolve() *IntOpsImpPrintCall {
	validator := func(c *IntOpsImpCall) bool {
		return c.Name() == "Print"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsPrint()
	methodCall.Resolve()
	return methodCall
}

func (bldr *IntOpsImpPrintBuilder) InjectPanic(msg any) *IntOpsImpPrintCall {
	validator := func(c *IntOpsImpCall) bool {
		return c.Name() == "Print"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsPrint()
	methodCall.InjectPanic(msg)
	return methodCall
}

type IntOpsImpTimed struct {
	ExpectCallIs *IntOpsImpExpectCallIs
}

func (i *IntOpsImp) Within(d time.Duration) *IntOpsImpTimed {
	return &IntOpsImpTimed{
		ExpectCallIs: &IntOpsImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *IntOpsImp) GetCall(
	d time.Duration, validator func(*IntOpsImpCall) bool,
) *IntOpsImpCall {
	i.queueLock.Lock()

	// Check queue first while holding lock
	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			i.queueLock.Unlock()
			return call
		}
	}

	// Release lock before blocking on channel to avoid deadlock
	i.queueLock.Unlock()

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it - need lock to access shared queue
			i.queueLock.Lock()
			i.callQueue = append(i.callQueue, call)
			i.queueLock.Unlock()
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *IntOpsImp) GetCurrentCall() *IntOpsImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *IntOpsImpCall) bool { return true })
	return i.currentCall
}

func NewIntOpsImp(t *testing.T) *IntOpsImp {
	imp := &IntOpsImp{
		t:        t,
		callChan: make(chan *IntOpsImpCall, 1),
	}
	imp.Mock = &IntOpsImpMock{imp: imp}
	imp.ExpectCallIs = &IntOpsImpExpectCallIs{imp: imp}
	return imp
}
