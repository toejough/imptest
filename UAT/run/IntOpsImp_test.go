package run_test

// Code generated by generate.go. DO NOT EDIT.

import "sync"
import "testing"
import "time"

type IntOpsImpMock struct {
	imp *IntOpsImp
}

type IntOpsImp struct {
	t            *testing.T
	Mock         *IntOpsImpMock
	callChan     chan *IntOpsImpCall
	ExpectCallTo *IntOpsImpExpectCallTo
	currentCall  *IntOpsImpCall
	callQueue    []*IntOpsImpCall
	queueLock    sync.Mutex
}

type IntOpsImpAddCall struct {
	responseChan chan IntOpsImpAddCallResponse
	done         bool
	a            int
	b            int
}

type IntOpsImpAddCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    int
	PanicValue interface{}
}

func (c *IntOpsImpAddCall) InjectResult(result int) {
	c.done = true
	c.responseChan <- IntOpsImpAddCallResponse{Type: "return", Result0: result}
}
func (c *IntOpsImpAddCall) InjectPanic(msg interface{}) {
	c.done = true
	c.responseChan <- IntOpsImpAddCallResponse{Type: "panic", PanicValue: msg}
}

type IntOpsImpFormatCall struct {
	responseChan chan IntOpsImpFormatCallResponse
	done         bool
	i            int
}

type IntOpsImpFormatCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    string
	PanicValue interface{}
}

func (c *IntOpsImpFormatCall) InjectResult(result string) {
	c.done = true
	c.responseChan <- IntOpsImpFormatCallResponse{Type: "return", Result0: result}
}
func (c *IntOpsImpFormatCall) InjectPanic(msg interface{}) {
	c.done = true
	c.responseChan <- IntOpsImpFormatCallResponse{Type: "panic", PanicValue: msg}
}

type IntOpsImpPrintCall struct {
	responseChan chan IntOpsImpPrintCallResponse
	done         bool
	s            string
}

type IntOpsImpPrintCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue interface{}
}

func (c *IntOpsImpPrintCall) Resolve() {
	c.done = true
	c.responseChan <- IntOpsImpPrintCallResponse{Type: "resolve"}
}
func (c *IntOpsImpPrintCall) InjectPanic(msg interface{}) {
	c.done = true
	c.responseChan <- IntOpsImpPrintCallResponse{Type: "panic", PanicValue: msg}
}

func (m *IntOpsImpMock) Add(a int, b int) int {
	responseChan := make(chan IntOpsImpAddCallResponse, 1)

	call := &IntOpsImpAddCall{
		responseChan: responseChan,
		a:            a,
		b:            b,
	}

	callEvent := &IntOpsImpCall{
		Add: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

func (m *IntOpsImpMock) Format(i int) string {
	responseChan := make(chan IntOpsImpFormatCallResponse, 1)

	call := &IntOpsImpFormatCall{
		responseChan: responseChan,
		i:            i,
	}

	callEvent := &IntOpsImpCall{
		Format: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

func (m *IntOpsImpMock) Print(s string) {
	responseChan := make(chan IntOpsImpPrintCallResponse, 1)

	call := &IntOpsImpPrintCall{
		responseChan: responseChan,
		s:            s,
	}

	callEvent := &IntOpsImpCall{
		Print: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

type IntOpsImpCall struct {
	Add    *IntOpsImpAddCall
	Format *IntOpsImpFormatCall
	Print  *IntOpsImpPrintCall
}

func (c *IntOpsImpCall) Name() string {
	if c.Add != nil {
		return "Add"
	}
	if c.Format != nil {
		return "Format"
	}
	if c.Print != nil {
		return "Print"
	}
	return ""
}

func (c *IntOpsImpCall) Done() bool {
	if c.Add != nil {
		return c.Add.done
	}
	if c.Format != nil {
		return c.Format.done
	}
	if c.Print != nil {
		return c.Print.done
	}
	return false
}

func (c *IntOpsImpCall) AsAdd() *IntOpsImpAddCall { return c.Add }

func (c *IntOpsImpCall) AsFormat() *IntOpsImpFormatCall { return c.Format }

func (c *IntOpsImpCall) AsPrint() *IntOpsImpPrintCall { return c.Print }

type IntOpsImpExpectCallTo struct {
	imp     *IntOpsImp
	timeout time.Duration
}

func (e *IntOpsImpExpectCallTo) Add(a int, b int) *IntOpsImpAddCall {
	validator := func(c *IntOpsImpCall) bool {
		if c.Name() != "Add" {
			return false
		}
		methodCall := c.AsAdd()
		if methodCall.a != a {
			return false
		}
		if methodCall.b != b {
			return false
		}
		return true
	}

	call := e.imp.GetCall(e.timeout, validator)
	return call.AsAdd()
}

func (e *IntOpsImpExpectCallTo) Format(i int) *IntOpsImpFormatCall {
	validator := func(c *IntOpsImpCall) bool {
		if c.Name() != "Format" {
			return false
		}
		methodCall := c.AsFormat()
		if methodCall.i != i {
			return false
		}
		return true
	}

	call := e.imp.GetCall(e.timeout, validator)
	return call.AsFormat()
}

func (e *IntOpsImpExpectCallTo) Print(s string) *IntOpsImpPrintCall {
	validator := func(c *IntOpsImpCall) bool {
		if c.Name() != "Print" {
			return false
		}
		methodCall := c.AsPrint()
		if methodCall.s != s {
			return false
		}
		return true
	}

	call := e.imp.GetCall(e.timeout, validator)
	return call.AsPrint()
}

type IntOpsImpTimed struct {
	ExpectCallTo *IntOpsImpExpectCallTo
}

func (i *IntOpsImp) Within(d time.Duration) *IntOpsImpTimed {
	return &IntOpsImpTimed{
		ExpectCallTo: &IntOpsImpExpectCallTo{imp: i, timeout: d},
	}
}

func (i *IntOpsImp) GetCall(d time.Duration, validator func(*IntOpsImpCall) bool) *IntOpsImpCall {
	i.queueLock.Lock()
	defer i.queueLock.Unlock()

	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			return call
		}
	}

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it
			i.callQueue = append(i.callQueue, call)
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *IntOpsImp) GetCurrentCall() *IntOpsImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *IntOpsImpCall) bool { return true })
	return i.currentCall
}

func NewIntOpsImp(t *testing.T) *IntOpsImp {
	imp := &IntOpsImp{
		t:        t,
		callChan: make(chan *IntOpsImpCall, 1),
	}
	imp.Mock = &IntOpsImpMock{imp: imp}
	imp.ExpectCallTo = &IntOpsImpExpectCallTo{imp: imp}
	return imp
}
