// Code generated by impgen. DO NOT EDIT.

package run_test

import (
	"reflect"
	"testing"
)

type PingPongPlayerImp struct {
	t        testing.TB
	callable func()

	returnChan chan struct{}
	panicChan  chan any
	returned   *struct{}
	panicked   any
}

func NewPingPongPlayerImp(t testing.TB, callable func()) *PingPongPlayerImp {
	return &PingPongPlayerImp{
		t:          t,
		callable:   callable,
		returnChan: make(chan struct{}, 1),
		panicChan:  make(chan any, 1),
	}
}

func (s *PingPongPlayerImp) Start() *PingPongPlayerImp {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				s.panicChan <- r
			}
		}()

		s.callable()
		s.returnChan <- struct{}{}
	}()
	return s
}

func (s *PingPongPlayerImp) ExpectReturnedValues() {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.returned != nil {
		return
	}

	if s.panicked != nil {
		s.t.Fatalf("expected function to return, but it panicked with: %v", s.panicked)
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
	case p := <-s.panicChan:
		s.panicked = p
		s.t.Fatalf("expected function to return, but it panicked with: %v", p)
	}
}

func (s *PingPongPlayerImp) ExpectPanicWith(expected any) {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.panicked != nil {
		if !reflect.DeepEqual(s.panicked, expected) {
			s.t.Fatalf("expected panic with %v, got %v", expected, s.panicked)
		}
		return
	}

	if s.returned != nil {
		s.t.Fatalf("expected function to panic, but it returned")
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		s.t.Fatalf("expected function to panic, but it returned")
	case p := <-s.panicChan:
		s.panicked = p
		if !reflect.DeepEqual(p, expected) {
			s.t.Fatalf("expected panic with %v, got %v", expected, p)
		}
	}
}

type PingPongPlayerImpResponse struct {
	EventType string // "return" or "panic"
	PanicVal  any
}

func (r *PingPongPlayerImpResponse) Type() string {
	return r.EventType
}

func (r *PingPongPlayerImpResponse) AsReturn() []any {
	return nil
}

func (s *PingPongPlayerImp) GetResponse() *PingPongPlayerImpResponse {
	// Check if we already have a return value or panic
	if s.returned != nil {
		return &PingPongPlayerImpResponse{
			EventType: "ReturnEvent",
		}
	}

	if s.panicked != nil {
		return &PingPongPlayerImpResponse{
			EventType: "PanicEvent",
			PanicVal:  s.panicked,
		}
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		return &PingPongPlayerImpResponse{
			EventType: "ReturnEvent",
		}
	case p := <-s.panicChan:
		s.panicked = p
		return &PingPongPlayerImpResponse{
			EventType: "PanicEvent",
			PanicVal:  p,
		}
	}
}
