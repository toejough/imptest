package run_test

// Code generated by impgen. DO NOT EDIT.

import "sync"
import "testing"
import "time"

type CoinFlipperImpMock struct {
	imp *CoinFlipperImp
}

type CoinFlipperImp struct {
	t            *testing.T
	Mock         *CoinFlipperImpMock
	callChan     chan *CoinFlipperImpCall
	ExpectCallTo *CoinFlipperImpExpectCallTo
	currentCall  *CoinFlipperImpCall
	callQueue    []*CoinFlipperImpCall
	queueLock    sync.Mutex
}

type CoinFlipperImpFlipCall struct {
	responseChan chan CoinFlipperImpFlipCallResponse
	done         bool
}

type CoinFlipperImpFlipCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue interface{}
}

func (c *CoinFlipperImpFlipCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- CoinFlipperImpFlipCallResponse{Type: "return", Result0: result}
}
func (c *CoinFlipperImpFlipCall) InjectPanic(msg interface{}) {
	c.done = true
	c.responseChan <- CoinFlipperImpFlipCallResponse{Type: "panic", PanicValue: msg}
}

func (m *CoinFlipperImpMock) Flip() bool {
	responseChan := make(chan CoinFlipperImpFlipCallResponse, 1)

	call := &CoinFlipperImpFlipCall{
		responseChan: responseChan,
	}

	callEvent := &CoinFlipperImpCall{
		Flip: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

type CoinFlipperImpCall struct {
	Flip *CoinFlipperImpFlipCall
}

func (c *CoinFlipperImpCall) Name() string {
	if c.Flip != nil {
		return "Flip"
	}
	return ""
}

func (c *CoinFlipperImpCall) Done() bool {
	if c.Flip != nil {
		return c.Flip.done
	}
	return false
}

func (c *CoinFlipperImpCall) AsFlip() *CoinFlipperImpFlipCall { return c.Flip }

type CoinFlipperImpExpectCallTo struct {
	imp     *CoinFlipperImp
	timeout time.Duration
}

func (e *CoinFlipperImpExpectCallTo) Flip() *CoinFlipperImpFlipCall {
	validator := func(c *CoinFlipperImpCall) bool {
		if c.Name() != "Flip" {
			return false
		}
		return true
	}

	call := e.imp.GetCall(e.timeout, validator)
	return call.AsFlip()
}

type CoinFlipperImpTimed struct {
	ExpectCallTo *CoinFlipperImpExpectCallTo
}

func (i *CoinFlipperImp) Within(d time.Duration) *CoinFlipperImpTimed {
	return &CoinFlipperImpTimed{
		ExpectCallTo: &CoinFlipperImpExpectCallTo{imp: i, timeout: d},
	}
}

func (i *CoinFlipperImp) GetCall(d time.Duration, validator func(*CoinFlipperImpCall) bool) *CoinFlipperImpCall {
	i.queueLock.Lock()
	defer i.queueLock.Unlock()

	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			return call
		}
	}

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it
			i.callQueue = append(i.callQueue, call)
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *CoinFlipperImp) GetCurrentCall() *CoinFlipperImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *CoinFlipperImpCall) bool { return true })
	return i.currentCall
}

func NewCoinFlipperImp(t *testing.T) *CoinFlipperImp {
	imp := &CoinFlipperImp{
		t:        t,
		callChan: make(chan *CoinFlipperImpCall, 1),
	}
	imp.Mock = &CoinFlipperImpMock{imp: imp}
	imp.ExpectCallTo = &CoinFlipperImpExpectCallTo{imp: imp}
	return imp
}
