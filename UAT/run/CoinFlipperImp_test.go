// Code generated by impgen. DO NOT EDIT.

package run_test

import "sync"
import "testing"
import "time"

type CoinFlipperImpMock struct {
	imp *CoinFlipperImp
}

type CoinFlipperImp struct {
	t            *testing.T
	Mock         *CoinFlipperImpMock
	callChan     chan *CoinFlipperImpCall
	ExpectCallIs *CoinFlipperImpExpectCallIs
	currentCall  *CoinFlipperImpCall
	callQueue    []*CoinFlipperImpCall
	queueLock    sync.Mutex
}

type CoinFlipperImpFlipCall struct {
	responseChan chan CoinFlipperImpFlipCallResponse
	done         bool
}

type CoinFlipperImpFlipCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue any
}

func (c *CoinFlipperImpFlipCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- CoinFlipperImpFlipCallResponse{Type: "return", Result0: result}
}
func (c *CoinFlipperImpFlipCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- CoinFlipperImpFlipCallResponse{Type: "panic", PanicValue: msg}
}

func (m *CoinFlipperImpMock) Flip() bool {
	responseChan := make(chan CoinFlipperImpFlipCallResponse, 1)

	call := &CoinFlipperImpFlipCall{
		responseChan: responseChan,
	}

	callEvent := &CoinFlipperImpCall{
		Flip: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

type CoinFlipperImpCall struct {
	Flip *CoinFlipperImpFlipCall
}

func (c *CoinFlipperImpCall) Name() string {
	if c.Flip != nil {
		return "Flip"
	}
	return ""
}

func (c *CoinFlipperImpCall) Done() bool {
	if c.Flip != nil {
		return c.Flip.done
	}
	return false
}

func (c *CoinFlipperImpCall) AsFlip() *CoinFlipperImpFlipCall { return c.Flip }

type CoinFlipperImpExpectCallIs struct {
	imp     *CoinFlipperImp
	timeout time.Duration
}

type CoinFlipperImpFlipBuilder struct {
	imp     *CoinFlipperImp
	timeout time.Duration
}

func (e *CoinFlipperImpExpectCallIs) Flip() *CoinFlipperImpFlipBuilder {
	return &CoinFlipperImpFlipBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *CoinFlipperImpFlipBuilder) ExpectArgsAre() *CoinFlipperImpFlipCall {
	validator := func(c *CoinFlipperImpCall) bool {
		if c.Name() != "Flip" {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsFlip()
}

func (bldr *CoinFlipperImpFlipBuilder) ExpectArgsShould() *CoinFlipperImpFlipCall {
	validator := func(c *CoinFlipperImpCall) bool {
		if c.Name() != "Flip" {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsFlip()
}

func (bldr *CoinFlipperImpFlipBuilder) InjectResult(result bool) *CoinFlipperImpFlipCall {
	validator := func(c *CoinFlipperImpCall) bool {
		return c.Name() == "Flip"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsFlip()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *CoinFlipperImpFlipBuilder) InjectPanic(msg any) *CoinFlipperImpFlipCall {
	validator := func(c *CoinFlipperImpCall) bool {
		return c.Name() == "Flip"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsFlip()
	methodCall.InjectPanic(msg)
	return methodCall
}

type CoinFlipperImpTimed struct {
	ExpectCallIs *CoinFlipperImpExpectCallIs
}

func (i *CoinFlipperImp) Within(d time.Duration) *CoinFlipperImpTimed {
	return &CoinFlipperImpTimed{
		ExpectCallIs: &CoinFlipperImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *CoinFlipperImp) GetCall(
	d time.Duration, validator func(*CoinFlipperImpCall) bool,
) *CoinFlipperImpCall {
	i.queueLock.Lock()

	// Check queue first while holding lock
	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			i.queueLock.Unlock()
			return call
		}
	}

	// Release lock before blocking on channel to avoid deadlock
	i.queueLock.Unlock()

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it - need lock to access shared queue
			i.queueLock.Lock()
			i.callQueue = append(i.callQueue, call)
			i.queueLock.Unlock()
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *CoinFlipperImp) GetCurrentCall() *CoinFlipperImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *CoinFlipperImpCall) bool { return true })
	return i.currentCall
}

func NewCoinFlipperImp(t *testing.T) *CoinFlipperImp {
	imp := &CoinFlipperImp{
		t:        t,
		callChan: make(chan *CoinFlipperImpCall, 1),
	}
	imp.Mock = &CoinFlipperImpMock{imp: imp}
	imp.ExpectCallIs = &CoinFlipperImpExpectCallIs{imp: imp}
	return imp
}
