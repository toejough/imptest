package run_test

// Code generated by impgen. DO NOT EDIT.

import "github.com/toejough/imptest/imptest"
import "sync"
import "testing"
import "time"

type TrackerImpMock struct {
	imp *TrackerImp
}

type TrackerImp struct {
	t            *testing.T
	Mock         *TrackerImpMock
	callChan     chan *TrackerImpCall
	ExpectCallIs *TrackerImpExpectCallIs
	currentCall  *TrackerImpCall
	callQueue    []*TrackerImpCall
	queueLock    sync.Mutex
}

type TrackerImpRegisterCall struct {
	responseChan chan TrackerImpRegisterCallResponse
	done         bool
	name         string
}

type TrackerImpRegisterCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue any
}

func (c *TrackerImpRegisterCall) Resolve() {
	c.done = true
	c.responseChan <- TrackerImpRegisterCallResponse{Type: "resolve"}
}
func (c *TrackerImpRegisterCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- TrackerImpRegisterCallResponse{Type: "panic", PanicValue: msg}
}

type TrackerImpIsServingCall struct {
	responseChan chan TrackerImpIsServingCallResponse
	done         bool
	name         string
}

type TrackerImpIsServingCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue any
}

func (c *TrackerImpIsServingCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- TrackerImpIsServingCallResponse{Type: "return", Result0: result}
}
func (c *TrackerImpIsServingCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- TrackerImpIsServingCallResponse{Type: "panic", PanicValue: msg}
}

type TrackerImpHitCall struct {
	responseChan chan TrackerImpHitCallResponse
	done         bool
	name         string
}

type TrackerImpHitCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue any
}

func (c *TrackerImpHitCall) Resolve() {
	c.done = true
	c.responseChan <- TrackerImpHitCallResponse{Type: "resolve"}
}
func (c *TrackerImpHitCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- TrackerImpHitCallResponse{Type: "panic", PanicValue: msg}
}

type TrackerImpMissCall struct {
	responseChan chan TrackerImpMissCallResponse
	done         bool
	name         string
}

type TrackerImpMissCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue any
}

func (c *TrackerImpMissCall) Resolve() {
	c.done = true
	c.responseChan <- TrackerImpMissCallResponse{Type: "resolve"}
}
func (c *TrackerImpMissCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- TrackerImpMissCallResponse{Type: "panic", PanicValue: msg}
}

type TrackerImpReceiveCall struct {
	responseChan chan TrackerImpReceiveCallResponse
	done         bool
	name         string
}

type TrackerImpReceiveCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue any
}

func (c *TrackerImpReceiveCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- TrackerImpReceiveCallResponse{Type: "return", Result0: result}
}
func (c *TrackerImpReceiveCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- TrackerImpReceiveCallResponse{Type: "panic", PanicValue: msg}
}

func (m *TrackerImpMock) Register(name string) {
	responseChan := make(chan TrackerImpRegisterCallResponse, 1)

	call := &TrackerImpRegisterCall{
		responseChan: responseChan,
		name:         name,
	}

	callEvent := &TrackerImpCall{
		Register: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

func (m *TrackerImpMock) IsServing(name string) bool {
	responseChan := make(chan TrackerImpIsServingCallResponse, 1)

	call := &TrackerImpIsServingCall{
		responseChan: responseChan,
		name:         name,
	}

	callEvent := &TrackerImpCall{
		IsServing: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

func (m *TrackerImpMock) Hit(name string) {
	responseChan := make(chan TrackerImpHitCallResponse, 1)

	call := &TrackerImpHitCall{
		responseChan: responseChan,
		name:         name,
	}

	callEvent := &TrackerImpCall{
		Hit: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

func (m *TrackerImpMock) Miss(name string) {
	responseChan := make(chan TrackerImpMissCallResponse, 1)

	call := &TrackerImpMissCall{
		responseChan: responseChan,
		name:         name,
	}

	callEvent := &TrackerImpCall{
		Miss: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

func (m *TrackerImpMock) Receive(name string) bool {
	responseChan := make(chan TrackerImpReceiveCallResponse, 1)

	call := &TrackerImpReceiveCall{
		responseChan: responseChan,
		name:         name,
	}

	callEvent := &TrackerImpCall{
		Receive: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

type TrackerImpCall struct {
	Register  *TrackerImpRegisterCall
	IsServing *TrackerImpIsServingCall
	Hit       *TrackerImpHitCall
	Miss      *TrackerImpMissCall
	Receive   *TrackerImpReceiveCall
}

func (c *TrackerImpCall) Name() string {
	if c.Register != nil {
		return "Register"
	}
	if c.IsServing != nil {
		return "IsServing"
	}
	if c.Hit != nil {
		return "Hit"
	}
	if c.Miss != nil {
		return "Miss"
	}
	if c.Receive != nil {
		return "Receive"
	}
	return ""
}

func (c *TrackerImpCall) Done() bool {
	if c.Register != nil {
		return c.Register.done
	}
	if c.IsServing != nil {
		return c.IsServing.done
	}
	if c.Hit != nil {
		return c.Hit.done
	}
	if c.Miss != nil {
		return c.Miss.done
	}
	if c.Receive != nil {
		return c.Receive.done
	}
	return false
}

func (c *TrackerImpCall) AsRegister() *TrackerImpRegisterCall { return c.Register }

func (c *TrackerImpCall) AsIsServing() *TrackerImpIsServingCall { return c.IsServing }

func (c *TrackerImpCall) AsHit() *TrackerImpHitCall { return c.Hit }

func (c *TrackerImpCall) AsMiss() *TrackerImpMissCall { return c.Miss }

func (c *TrackerImpCall) AsReceive() *TrackerImpReceiveCall { return c.Receive }

type TrackerImpExpectCallIs struct {
	imp     *TrackerImp
	timeout time.Duration
}

type TrackerImpRegisterBuilder struct {
	imp     *TrackerImp
	timeout time.Duration
}

func (e *TrackerImpExpectCallIs) Register() *TrackerImpRegisterBuilder {
	return &TrackerImpRegisterBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *TrackerImpRegisterBuilder) ExpectArgsAre(name string) *TrackerImpRegisterCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Register" {
			return false
		}
		methodCall := c.AsRegister()
		if methodCall.name != name {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsRegister()
}

func (bldr *TrackerImpRegisterBuilder) ExpectArgsShould(name any) *TrackerImpRegisterCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Register" {
			return false
		}
		methodCall := c.AsRegister()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.name, name)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsRegister()
}

func (bldr *TrackerImpRegisterBuilder) Resolve() *TrackerImpRegisterCall {
	validator := func(c *TrackerImpCall) bool {
		return c.Name() == "Register"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsRegister()
	methodCall.Resolve()
	return methodCall
}

func (bldr *TrackerImpRegisterBuilder) InjectPanic(msg any) *TrackerImpRegisterCall {
	validator := func(c *TrackerImpCall) bool {
		return c.Name() == "Register"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsRegister()
	methodCall.InjectPanic(msg)
	return methodCall
}

type TrackerImpIsServingBuilder struct {
	imp     *TrackerImp
	timeout time.Duration
}

func (e *TrackerImpExpectCallIs) IsServing() *TrackerImpIsServingBuilder {
	return &TrackerImpIsServingBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *TrackerImpIsServingBuilder) ExpectArgsAre(name string) *TrackerImpIsServingCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "IsServing" {
			return false
		}
		methodCall := c.AsIsServing()
		if methodCall.name != name {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsIsServing()
}

func (bldr *TrackerImpIsServingBuilder) ExpectArgsShould(name any) *TrackerImpIsServingCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "IsServing" {
			return false
		}
		methodCall := c.AsIsServing()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.name, name)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsIsServing()
}

func (bldr *TrackerImpIsServingBuilder) InjectResult(result bool) *TrackerImpIsServingCall {
	validator := func(c *TrackerImpCall) bool {
		return c.Name() == "IsServing"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsIsServing()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *TrackerImpIsServingBuilder) InjectPanic(msg any) *TrackerImpIsServingCall {
	validator := func(c *TrackerImpCall) bool {
		return c.Name() == "IsServing"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsIsServing()
	methodCall.InjectPanic(msg)
	return methodCall
}

type TrackerImpHitBuilder struct {
	imp     *TrackerImp
	timeout time.Duration
}

func (e *TrackerImpExpectCallIs) Hit() *TrackerImpHitBuilder {
	return &TrackerImpHitBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *TrackerImpHitBuilder) ExpectArgsAre(name string) *TrackerImpHitCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Hit" {
			return false
		}
		methodCall := c.AsHit()
		if methodCall.name != name {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsHit()
}

func (bldr *TrackerImpHitBuilder) ExpectArgsShould(name any) *TrackerImpHitCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Hit" {
			return false
		}
		methodCall := c.AsHit()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.name, name)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsHit()
}

func (bldr *TrackerImpHitBuilder) Resolve() *TrackerImpHitCall {
	validator := func(c *TrackerImpCall) bool {
		return c.Name() == "Hit"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsHit()
	methodCall.Resolve()
	return methodCall
}

func (bldr *TrackerImpHitBuilder) InjectPanic(msg any) *TrackerImpHitCall {
	validator := func(c *TrackerImpCall) bool {
		return c.Name() == "Hit"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsHit()
	methodCall.InjectPanic(msg)
	return methodCall
}

type TrackerImpMissBuilder struct {
	imp     *TrackerImp
	timeout time.Duration
}

func (e *TrackerImpExpectCallIs) Miss() *TrackerImpMissBuilder {
	return &TrackerImpMissBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *TrackerImpMissBuilder) ExpectArgsAre(name string) *TrackerImpMissCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Miss" {
			return false
		}
		methodCall := c.AsMiss()
		if methodCall.name != name {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsMiss()
}

func (bldr *TrackerImpMissBuilder) ExpectArgsShould(name any) *TrackerImpMissCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Miss" {
			return false
		}
		methodCall := c.AsMiss()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.name, name)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsMiss()
}

func (bldr *TrackerImpMissBuilder) Resolve() *TrackerImpMissCall {
	validator := func(c *TrackerImpCall) bool {
		return c.Name() == "Miss"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsMiss()
	methodCall.Resolve()
	return methodCall
}

func (bldr *TrackerImpMissBuilder) InjectPanic(msg any) *TrackerImpMissCall {
	validator := func(c *TrackerImpCall) bool {
		return c.Name() == "Miss"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsMiss()
	methodCall.InjectPanic(msg)
	return methodCall
}

type TrackerImpReceiveBuilder struct {
	imp     *TrackerImp
	timeout time.Duration
}

func (e *TrackerImpExpectCallIs) Receive() *TrackerImpReceiveBuilder {
	return &TrackerImpReceiveBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *TrackerImpReceiveBuilder) ExpectArgsAre(name string) *TrackerImpReceiveCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Receive" {
			return false
		}
		methodCall := c.AsReceive()
		if methodCall.name != name {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsReceive()
}

func (bldr *TrackerImpReceiveBuilder) ExpectArgsShould(name any) *TrackerImpReceiveCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Receive" {
			return false
		}
		methodCall := c.AsReceive()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.name, name)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsReceive()
}

func (bldr *TrackerImpReceiveBuilder) InjectResult(result bool) *TrackerImpReceiveCall {
	validator := func(c *TrackerImpCall) bool {
		return c.Name() == "Receive"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsReceive()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *TrackerImpReceiveBuilder) InjectPanic(msg any) *TrackerImpReceiveCall {
	validator := func(c *TrackerImpCall) bool {
		return c.Name() == "Receive"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsReceive()
	methodCall.InjectPanic(msg)
	return methodCall
}

type TrackerImpTimed struct {
	ExpectCallIs *TrackerImpExpectCallIs
}

func (i *TrackerImp) Within(d time.Duration) *TrackerImpTimed {
	return &TrackerImpTimed{
		ExpectCallIs: &TrackerImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *TrackerImp) GetCall(
	d time.Duration, validator func(*TrackerImpCall) bool,
) *TrackerImpCall {
	i.queueLock.Lock()

	// Check queue first while holding lock
	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			i.queueLock.Unlock()
			return call
		}
	}

	// Release lock before blocking on channel to avoid deadlock
	i.queueLock.Unlock()

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it - need lock to access shared queue
			i.queueLock.Lock()
			i.callQueue = append(i.callQueue, call)
			i.queueLock.Unlock()
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *TrackerImp) GetCurrentCall() *TrackerImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *TrackerImpCall) bool { return true })
	return i.currentCall
}

func NewTrackerImp(t *testing.T) *TrackerImp {
	imp := &TrackerImp{
		t:        t,
		callChan: make(chan *TrackerImpCall, 1),
	}
	imp.Mock = &TrackerImpMock{imp: imp}
	imp.ExpectCallIs = &TrackerImpExpectCallIs{imp: imp}
	return imp
}
