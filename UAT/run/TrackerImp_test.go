package run_test

// Code generated by impgen. DO NOT EDIT.

import "sync"
import "testing"
import "time"

type TrackerImpMock struct {
	imp *TrackerImp
}

type TrackerImp struct {
	t            *testing.T
	Mock         *TrackerImpMock
	callChan     chan *TrackerImpCall
	ExpectCallTo *TrackerImpExpectCallTo
	currentCall  *TrackerImpCall
	callQueue    []*TrackerImpCall
	queueLock    sync.Mutex
}

type TrackerImpRegisterCall struct {
	responseChan chan TrackerImpRegisterCallResponse
	done         bool
	name         string
}

type TrackerImpRegisterCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue interface{}
}

func (c *TrackerImpRegisterCall) Resolve() {
	c.done = true
	c.responseChan <- TrackerImpRegisterCallResponse{Type: "resolve"}
}
func (c *TrackerImpRegisterCall) InjectPanic(msg interface{}) {
	c.done = true
	c.responseChan <- TrackerImpRegisterCallResponse{Type: "panic", PanicValue: msg}
}

type TrackerImpIsServingCall struct {
	responseChan chan TrackerImpIsServingCallResponse
	done         bool
	name         string
}

type TrackerImpIsServingCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue interface{}
}

func (c *TrackerImpIsServingCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- TrackerImpIsServingCallResponse{Type: "return", Result0: result}
}
func (c *TrackerImpIsServingCall) InjectPanic(msg interface{}) {
	c.done = true
	c.responseChan <- TrackerImpIsServingCallResponse{Type: "panic", PanicValue: msg}
}

type TrackerImpHitCall struct {
	responseChan chan TrackerImpHitCallResponse
	done         bool
	name         string
}

type TrackerImpHitCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue interface{}
}

func (c *TrackerImpHitCall) Resolve() {
	c.done = true
	c.responseChan <- TrackerImpHitCallResponse{Type: "resolve"}
}
func (c *TrackerImpHitCall) InjectPanic(msg interface{}) {
	c.done = true
	c.responseChan <- TrackerImpHitCallResponse{Type: "panic", PanicValue: msg}
}

type TrackerImpMissCall struct {
	responseChan chan TrackerImpMissCallResponse
	done         bool
	name         string
}

type TrackerImpMissCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue interface{}
}

func (c *TrackerImpMissCall) Resolve() {
	c.done = true
	c.responseChan <- TrackerImpMissCallResponse{Type: "resolve"}
}
func (c *TrackerImpMissCall) InjectPanic(msg interface{}) {
	c.done = true
	c.responseChan <- TrackerImpMissCallResponse{Type: "panic", PanicValue: msg}
}

type TrackerImpReceiveCall struct {
	responseChan chan TrackerImpReceiveCallResponse
	done         bool
	name         string
}

type TrackerImpReceiveCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue interface{}
}

func (c *TrackerImpReceiveCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- TrackerImpReceiveCallResponse{Type: "return", Result0: result}
}
func (c *TrackerImpReceiveCall) InjectPanic(msg interface{}) {
	c.done = true
	c.responseChan <- TrackerImpReceiveCallResponse{Type: "panic", PanicValue: msg}
}

func (m *TrackerImpMock) Register(name string) {
	responseChan := make(chan TrackerImpRegisterCallResponse, 1)

	call := &TrackerImpRegisterCall{
		responseChan: responseChan,
		name:         name,
	}

	callEvent := &TrackerImpCall{
		Register: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

func (m *TrackerImpMock) IsServing(name string) bool {
	responseChan := make(chan TrackerImpIsServingCallResponse, 1)

	call := &TrackerImpIsServingCall{
		responseChan: responseChan,
		name:         name,
	}

	callEvent := &TrackerImpCall{
		IsServing: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

func (m *TrackerImpMock) Hit(name string) {
	responseChan := make(chan TrackerImpHitCallResponse, 1)

	call := &TrackerImpHitCall{
		responseChan: responseChan,
		name:         name,
	}

	callEvent := &TrackerImpCall{
		Hit: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

func (m *TrackerImpMock) Miss(name string) {
	responseChan := make(chan TrackerImpMissCallResponse, 1)

	call := &TrackerImpMissCall{
		responseChan: responseChan,
		name:         name,
	}

	callEvent := &TrackerImpCall{
		Miss: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

func (m *TrackerImpMock) Receive(name string) bool {
	responseChan := make(chan TrackerImpReceiveCallResponse, 1)

	call := &TrackerImpReceiveCall{
		responseChan: responseChan,
		name:         name,
	}

	callEvent := &TrackerImpCall{
		Receive: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

type TrackerImpCall struct {
	Register  *TrackerImpRegisterCall
	IsServing *TrackerImpIsServingCall
	Hit       *TrackerImpHitCall
	Miss      *TrackerImpMissCall
	Receive   *TrackerImpReceiveCall
}

func (c *TrackerImpCall) Name() string {
	if c.Register != nil {
		return "Register"
	}
	if c.IsServing != nil {
		return "IsServing"
	}
	if c.Hit != nil {
		return "Hit"
	}
	if c.Miss != nil {
		return "Miss"
	}
	if c.Receive != nil {
		return "Receive"
	}
	return ""
}

func (c *TrackerImpCall) Done() bool {
	if c.Register != nil {
		return c.Register.done
	}
	if c.IsServing != nil {
		return c.IsServing.done
	}
	if c.Hit != nil {
		return c.Hit.done
	}
	if c.Miss != nil {
		return c.Miss.done
	}
	if c.Receive != nil {
		return c.Receive.done
	}
	return false
}

func (c *TrackerImpCall) AsRegister() *TrackerImpRegisterCall { return c.Register }

func (c *TrackerImpCall) AsIsServing() *TrackerImpIsServingCall { return c.IsServing }

func (c *TrackerImpCall) AsHit() *TrackerImpHitCall { return c.Hit }

func (c *TrackerImpCall) AsMiss() *TrackerImpMissCall { return c.Miss }

func (c *TrackerImpCall) AsReceive() *TrackerImpReceiveCall { return c.Receive }

type TrackerImpExpectCallTo struct {
	imp     *TrackerImp
	timeout time.Duration
}

func (e *TrackerImpExpectCallTo) Register(name string) *TrackerImpRegisterCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Register" {
			return false
		}
		methodCall := c.AsRegister()
		if methodCall.name != name {
			return false
		}
		return true
	}

	call := e.imp.GetCall(e.timeout, validator)
	return call.AsRegister()
}

func (e *TrackerImpExpectCallTo) IsServing(name string) *TrackerImpIsServingCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "IsServing" {
			return false
		}
		methodCall := c.AsIsServing()
		if methodCall.name != name {
			return false
		}
		return true
	}

	call := e.imp.GetCall(e.timeout, validator)
	return call.AsIsServing()
}

func (e *TrackerImpExpectCallTo) Hit(name string) *TrackerImpHitCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Hit" {
			return false
		}
		methodCall := c.AsHit()
		if methodCall.name != name {
			return false
		}
		return true
	}

	call := e.imp.GetCall(e.timeout, validator)
	return call.AsHit()
}

func (e *TrackerImpExpectCallTo) Miss(name string) *TrackerImpMissCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Miss" {
			return false
		}
		methodCall := c.AsMiss()
		if methodCall.name != name {
			return false
		}
		return true
	}

	call := e.imp.GetCall(e.timeout, validator)
	return call.AsMiss()
}

func (e *TrackerImpExpectCallTo) Receive(name string) *TrackerImpReceiveCall {
	validator := func(c *TrackerImpCall) bool {
		if c.Name() != "Receive" {
			return false
		}
		methodCall := c.AsReceive()
		if methodCall.name != name {
			return false
		}
		return true
	}

	call := e.imp.GetCall(e.timeout, validator)
	return call.AsReceive()
}

type TrackerImpTimed struct {
	ExpectCallTo *TrackerImpExpectCallTo
}

func (i *TrackerImp) Within(d time.Duration) *TrackerImpTimed {
	return &TrackerImpTimed{
		ExpectCallTo: &TrackerImpExpectCallTo{imp: i, timeout: d},
	}
}

func (i *TrackerImp) GetCall(d time.Duration, validator func(*TrackerImpCall) bool) *TrackerImpCall {
	i.queueLock.Lock()
	defer i.queueLock.Unlock()

	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			return call
		}
	}

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it
			i.callQueue = append(i.callQueue, call)
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *TrackerImp) GetCurrentCall() *TrackerImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *TrackerImpCall) bool { return true })
	return i.currentCall
}

func NewTrackerImp(t *testing.T) *TrackerImp {
	imp := &TrackerImp{
		t:        t,
		callChan: make(chan *TrackerImpCall, 1),
	}
	imp.Mock = &TrackerImpMock{imp: imp}
	imp.ExpectCallTo = &TrackerImpExpectCallTo{imp: imp}
	return imp
}
