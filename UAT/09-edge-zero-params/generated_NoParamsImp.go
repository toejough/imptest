// Code generated by impgen. DO NOT EDIT.

package zero_params

import "github.com/toejough/imptest/imptest"
import "testing"
import "time"

type NoParamsImpMock struct {
	imp *NoParamsImp
}

type NoParamsImp struct {
	*imptest.Controller[*NoParamsImpCall]
	Mock         *NoParamsImpMock
	ExpectCallIs *NoParamsImpExpectCallIs
	currentCall  *NoParamsImpCall
}

type NoParamsImpGetCall struct {
	responseChan chan NoParamsImpGetCallResponse
	done         bool
}

type NoParamsImpGetCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    int
	PanicValue any
}

func (c *NoParamsImpGetCall) InjectResult(result int) {
	c.done = true
	c.responseChan <- NoParamsImpGetCallResponse{Type: "return", Result0: result}
}
func (c *NoParamsImpGetCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- NoParamsImpGetCallResponse{Type: "panic", PanicValue: msg}
}

type NoParamsImpExecuteCall struct {
	responseChan chan NoParamsImpExecuteCallResponse
	done         bool
}

type NoParamsImpExecuteCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

func (c *NoParamsImpExecuteCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- NoParamsImpExecuteCallResponse{Type: "return", Result0: result}
}
func (c *NoParamsImpExecuteCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- NoParamsImpExecuteCallResponse{Type: "panic", PanicValue: msg}
}

func (m *NoParamsImpMock) Get() int {
	responseChan := make(chan NoParamsImpGetCallResponse, 1)

	call := &NoParamsImpGetCall{
		responseChan: responseChan,
	}

	callEvent := &NoParamsImpCall{
		Get: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

func (m *NoParamsImpMock) Execute() error {
	responseChan := make(chan NoParamsImpExecuteCallResponse, 1)

	call := &NoParamsImpExecuteCall{
		responseChan: responseChan,
	}

	callEvent := &NoParamsImpCall{
		Execute: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

type NoParamsImpCall struct {
	Get     *NoParamsImpGetCall
	Execute *NoParamsImpExecuteCall
}

func (c *NoParamsImpCall) Name() string {
	if c.Get != nil {
		return "Get"
	}
	if c.Execute != nil {
		return "Execute"
	}
	return ""
}

func (c *NoParamsImpCall) Done() bool {
	if c.Get != nil {
		return c.Get.done
	}
	if c.Execute != nil {
		return c.Execute.done
	}
	return false
}

func (c *NoParamsImpCall) AsGet() *NoParamsImpGetCall {
	return c.Get
}

func (c *NoParamsImpCall) AsExecute() *NoParamsImpExecuteCall {
	return c.Execute
}

type NoParamsImpExpectCallIs struct {
	imp     *NoParamsImp
	timeout time.Duration
}

type NoParamsImpGetBuilder struct {
	imp     *NoParamsImp
	timeout time.Duration
}

func (e *NoParamsImpExpectCallIs) Get() *NoParamsImpGetBuilder {
	return &NoParamsImpGetBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *NoParamsImpGetBuilder) InjectResult(result int) *NoParamsImpGetCall {
	validator := func(callToCheck *NoParamsImpCall) bool {
		return callToCheck.Name() == "Get"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsGet()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *NoParamsImpGetBuilder) InjectPanic(msg any) *NoParamsImpGetCall {
	validator := func(callToCheck *NoParamsImpCall) bool {
		return callToCheck.Name() == "Get"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsGet()
	methodCall.InjectPanic(msg)
	return methodCall
}

type NoParamsImpExecuteBuilder struct {
	imp     *NoParamsImp
	timeout time.Duration
}

func (e *NoParamsImpExpectCallIs) Execute() *NoParamsImpExecuteBuilder {
	return &NoParamsImpExecuteBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *NoParamsImpExecuteBuilder) InjectResult(result error) *NoParamsImpExecuteCall {
	validator := func(callToCheck *NoParamsImpCall) bool {
		return callToCheck.Name() == "Execute"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsExecute()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *NoParamsImpExecuteBuilder) InjectPanic(msg any) *NoParamsImpExecuteCall {
	validator := func(callToCheck *NoParamsImpCall) bool {
		return callToCheck.Name() == "Execute"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsExecute()
	methodCall.InjectPanic(msg)
	return methodCall
}

type NoParamsImpTimed struct {
	ExpectCallIs *NoParamsImpExpectCallIs
}

func (i *NoParamsImp) Within(d time.Duration) *NoParamsImpTimed {
	return &NoParamsImpTimed{
		ExpectCallIs: &NoParamsImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *NoParamsImp) GetCurrentCall() *NoParamsImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *NoParamsImpCall) bool { return true })
	return i.currentCall
}

func NewNoParamsImp(t *testing.T) *NoParamsImp {
	imp := &NoParamsImp{
		Controller: imptest.NewController[*NoParamsImpCall](t),
	}
	imp.Mock = &NoParamsImpMock{imp: imp}
	imp.ExpectCallIs = &NoParamsImpExpectCallIs{imp: imp}
	return imp
}
