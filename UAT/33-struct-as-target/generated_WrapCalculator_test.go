// Code generated by impgen. DO NOT EDIT.

package calculator_test

import (
	calculator "github.com/toejough/imptest/UAT/33-struct-as-target"
	"testing"
)

// WrapCalculatorWrapper wraps an implementation of calculator.Calculator to intercept method calls.
type WrapCalculatorWrapper struct {
	impl     *calculator.Calculator
	Add      *WrapCalculatorWrapperAddWrapper
	Divide   *WrapCalculatorWrapperDivideWrapper
	Multiply *WrapCalculatorWrapperMultiplyWrapper
	Process  *WrapCalculatorWrapperProcessWrapper
}

type WrapCalculatorWrapperAddReturns struct {
	Result0 int
}

func (r *WrapCalculatorWrapperAddReturns) WaitForResponse() int {
	return r.Result0
}

type WrapCalculatorWrapperAddWrapper struct {
	t     *testing.T
	fn    func(a int, b int) WrapCalculatorWrapperAddReturns
	calls []WrapCalculatorWrapperAddWrapperCallRecord
}

func (w *WrapCalculatorWrapperAddWrapper) GetCalls() []WrapCalculatorWrapperAddWrapperCallRecord {
	return w.calls
}

func (w *WrapCalculatorWrapperAddWrapper) Start(a int, b int) *WrapCalculatorWrapperAddReturns {
	returns := w.fn(a, b)
	//nolint:lll // Template definition
	w.calls = append(w.calls, WrapCalculatorWrapperAddWrapperCallRecord{Params: struct {
		A int
		B int
	}{a, b}, Returns: returns})
	return &returns
}

type WrapCalculatorWrapperAddWrapperCallRecord struct {
	Params struct {
		A int
		B int
	}
	Returns WrapCalculatorWrapperAddReturns
}

type WrapCalculatorWrapperDivideReturns struct {
	Result0 int
	Result1 bool
}

func (r *WrapCalculatorWrapperDivideReturns) WaitForResponse() (int, bool) {
	return r.Result0, r.Result1
}

type WrapCalculatorWrapperDivideWrapper struct {
	t     *testing.T
	fn    func(numerator int, denominator int) WrapCalculatorWrapperDivideReturns
	calls []WrapCalculatorWrapperDivideWrapperCallRecord
}

func (w *WrapCalculatorWrapperDivideWrapper) GetCalls() []WrapCalculatorWrapperDivideWrapperCallRecord {
	return w.calls
}

func (w *WrapCalculatorWrapperDivideWrapper) Start(numerator int, denominator int) *WrapCalculatorWrapperDivideReturns {
	returns := w.fn(numerator, denominator)
	//nolint:lll // Template definition
	w.calls = append(w.calls, WrapCalculatorWrapperDivideWrapperCallRecord{Params: struct {
		Numerator   int
		Denominator int
	}{numerator, denominator}, Returns: returns})
	return &returns
}

type WrapCalculatorWrapperDivideWrapperCallRecord struct {
	Params struct {
		Numerator   int
		Denominator int
	}
	Returns WrapCalculatorWrapperDivideReturns
}

type WrapCalculatorWrapperMultiplyReturns struct {
	Result0 int
}

func (r *WrapCalculatorWrapperMultiplyReturns) WaitForResponse() int {
	return r.Result0
}

type WrapCalculatorWrapperMultiplyWrapper struct {
	t     *testing.T
	fn    func(value int) WrapCalculatorWrapperMultiplyReturns
	calls []WrapCalculatorWrapperMultiplyWrapperCallRecord
}

func (w *WrapCalculatorWrapperMultiplyWrapper) GetCalls() []WrapCalculatorWrapperMultiplyWrapperCallRecord {
	return w.calls
}

func (w *WrapCalculatorWrapperMultiplyWrapper) Start(value int) *WrapCalculatorWrapperMultiplyReturns {
	returns := w.fn(value)
	//nolint:lll // Template definition
	w.calls = append(w.calls, WrapCalculatorWrapperMultiplyWrapperCallRecord{Params: struct{ Value int }{value}, Returns: returns})
	return &returns
}

type WrapCalculatorWrapperMultiplyWrapperCallRecord struct {
	Params struct {
		Value int
	}
	Returns WrapCalculatorWrapperMultiplyReturns
}

type WrapCalculatorWrapperProcessReturns struct {
	Result0 string
	Result1 error
}

func (r *WrapCalculatorWrapperProcessReturns) WaitForResponse() (string, error) {
	return r.Result0, r.Result1
}

type WrapCalculatorWrapperProcessWrapper struct {
	t     *testing.T
	fn    func(input int) WrapCalculatorWrapperProcessReturns
	calls []WrapCalculatorWrapperProcessWrapperCallRecord
}

func (w *WrapCalculatorWrapperProcessWrapper) GetCalls() []WrapCalculatorWrapperProcessWrapperCallRecord {
	return w.calls
}

func (w *WrapCalculatorWrapperProcessWrapper) Start(input int) *WrapCalculatorWrapperProcessReturns {
	returns := w.fn(input)
	//nolint:lll // Template definition
	w.calls = append(w.calls, WrapCalculatorWrapperProcessWrapperCallRecord{Params: struct{ Input int }{input}, Returns: returns})
	return &returns
}

type WrapCalculatorWrapperProcessWrapperCallRecord struct {
	Params struct {
		Input int
	}
	Returns WrapCalculatorWrapperProcessReturns
}

// WrapCalculator creates a new wrapper for the given calculator.Calculator implementation.
func WrapCalculator(t *testing.T, impl *calculator.Calculator) *WrapCalculatorWrapper {
	w := &WrapCalculatorWrapper{
		impl: impl,
	}
	w.Add = wrapWrapCalculatorWrapperAdd(t, func(a int, b int) WrapCalculatorWrapperAddReturns {
		r0 := w.impl.Add(a, b)
		return WrapCalculatorWrapperAddReturns{Result0: r0}
	})
	w.Divide = wrapWrapCalculatorWrapperDivide(t, func(numerator int, denominator int) WrapCalculatorWrapperDivideReturns {
		r0, r1 := w.impl.Divide(numerator, denominator)
		return WrapCalculatorWrapperDivideReturns{Result0: r0, Result1: r1}
	})
	w.Multiply = wrapWrapCalculatorWrapperMultiply(t, func(value int) WrapCalculatorWrapperMultiplyReturns {
		r0 := w.impl.Multiply(value)
		return WrapCalculatorWrapperMultiplyReturns{Result0: r0}
	})
	w.Process = wrapWrapCalculatorWrapperProcess(t, func(input int) WrapCalculatorWrapperProcessReturns {
		r0, r1 := w.impl.Process(input)
		return WrapCalculatorWrapperProcessReturns{Result0: r0, Result1: r1}
	})
	return w
}

func wrapWrapCalculatorWrapperAdd(t *testing.T, fn func(a int, b int) WrapCalculatorWrapperAddReturns) *WrapCalculatorWrapperAddWrapper {
	return &WrapCalculatorWrapperAddWrapper{t: t, fn: fn}
}

func wrapWrapCalculatorWrapperDivide(t *testing.T, fn func(numerator int, denominator int) WrapCalculatorWrapperDivideReturns) *WrapCalculatorWrapperDivideWrapper {
	return &WrapCalculatorWrapperDivideWrapper{t: t, fn: fn}
}

func wrapWrapCalculatorWrapperMultiply(t *testing.T, fn func(value int) WrapCalculatorWrapperMultiplyReturns) *WrapCalculatorWrapperMultiplyWrapper {
	return &WrapCalculatorWrapperMultiplyWrapper{t: t, fn: fn}
}

func wrapWrapCalculatorWrapperProcess(t *testing.T, fn func(input int) WrapCalculatorWrapperProcessReturns) *WrapCalculatorWrapperProcessWrapper {
	return &WrapCalculatorWrapperProcessWrapper{t: t, fn: fn}
}
