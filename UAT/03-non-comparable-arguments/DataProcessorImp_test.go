// Code generated by impgen. DO NOT EDIT.

package noncomparable_test

import "github.com/toejough/imptest/imptest"
import "reflect"
import "testing"
import "time"

type DataProcessorImpMock struct {
	imp *DataProcessorImp
}

type DataProcessorImp struct {
	*imptest.Controller[*DataProcessorImpCall]
	Mock         *DataProcessorImpMock
	ExpectCallIs *DataProcessorImpExpectCallIs
	currentCall  *DataProcessorImpCall
}

type DataProcessorImpProcessSliceCall struct {
	responseChan chan DataProcessorImpProcessSliceCallResponse
	done         bool
	data         []string
}

type DataProcessorImpProcessSliceCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    int
	PanicValue any
}

func (c *DataProcessorImpProcessSliceCall) InjectResult(result int) {
	c.done = true
	c.responseChan <- DataProcessorImpProcessSliceCallResponse{Type: "return", Result0: result}
}
func (c *DataProcessorImpProcessSliceCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- DataProcessorImpProcessSliceCallResponse{Type: "panic", PanicValue: msg}
}

type DataProcessorImpProcessMapCall struct {
	responseChan chan DataProcessorImpProcessMapCallResponse
	done         bool
	config       map[string]int
}

type DataProcessorImpProcessMapCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue any
}

func (c *DataProcessorImpProcessMapCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- DataProcessorImpProcessMapCallResponse{Type: "return", Result0: result}
}
func (c *DataProcessorImpProcessMapCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- DataProcessorImpProcessMapCallResponse{Type: "panic", PanicValue: msg}
}

func (m *DataProcessorImpMock) ProcessSlice(data []string) int {
	responseChan := make(chan DataProcessorImpProcessSliceCallResponse, 1)

	call := &DataProcessorImpProcessSliceCall{
		responseChan: responseChan,
		data:         data,
	}

	callEvent := &DataProcessorImpCall{
		ProcessSlice: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

func (m *DataProcessorImpMock) ProcessMap(config map[string]int) bool {
	responseChan := make(chan DataProcessorImpProcessMapCallResponse, 1)

	call := &DataProcessorImpProcessMapCall{
		responseChan: responseChan,
		config:       config,
	}

	callEvent := &DataProcessorImpCall{
		ProcessMap: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

type DataProcessorImpCall struct {
	ProcessSlice *DataProcessorImpProcessSliceCall
	ProcessMap   *DataProcessorImpProcessMapCall
}

func (c *DataProcessorImpCall) Name() string {
	if c.ProcessSlice != nil {
		return "ProcessSlice"
	}
	if c.ProcessMap != nil {
		return "ProcessMap"
	}
	return ""
}

func (c *DataProcessorImpCall) Done() bool {
	if c.ProcessSlice != nil {
		return c.ProcessSlice.done
	}
	if c.ProcessMap != nil {
		return c.ProcessMap.done
	}
	return false
}

func (c *DataProcessorImpCall) AsProcessSlice() *DataProcessorImpProcessSliceCall {
	return c.ProcessSlice
}

func (c *DataProcessorImpCall) AsProcessMap() *DataProcessorImpProcessMapCall {
	return c.ProcessMap
}

type DataProcessorImpExpectCallIs struct {
	imp     *DataProcessorImp
	timeout time.Duration
}

type DataProcessorImpProcessSliceBuilder struct {
	imp     *DataProcessorImp
	timeout time.Duration
}

func (e *DataProcessorImpExpectCallIs) ProcessSlice() *DataProcessorImpProcessSliceBuilder {
	return &DataProcessorImpProcessSliceBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *DataProcessorImpProcessSliceBuilder) ExpectArgsAre(data []string) *DataProcessorImpProcessSliceCall {
	validator := func(c *DataProcessorImpCall) bool {
		if c.Name() != "ProcessSlice" {
			return false
		}
		methodCall := c.AsProcessSlice()
		if !reflect.DeepEqual(methodCall.data, data) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsProcessSlice()
}

func (bldr *DataProcessorImpProcessSliceBuilder) ExpectArgsShould(data any) *DataProcessorImpProcessSliceCall {
	validator := func(c *DataProcessorImpCall) bool {
		if c.Name() != "ProcessSlice" {
			return false
		}
		methodCall := c.AsProcessSlice()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.data, data)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsProcessSlice()
}

func (bldr *DataProcessorImpProcessSliceBuilder) InjectResult(result int) *DataProcessorImpProcessSliceCall {
	validator := func(c *DataProcessorImpCall) bool {
		return c.Name() == "ProcessSlice"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsProcessSlice()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *DataProcessorImpProcessSliceBuilder) InjectPanic(msg any) *DataProcessorImpProcessSliceCall {
	validator := func(c *DataProcessorImpCall) bool {
		return c.Name() == "ProcessSlice"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsProcessSlice()
	methodCall.InjectPanic(msg)
	return methodCall
}

type DataProcessorImpProcessMapBuilder struct {
	imp     *DataProcessorImp
	timeout time.Duration
}

func (e *DataProcessorImpExpectCallIs) ProcessMap() *DataProcessorImpProcessMapBuilder {
	return &DataProcessorImpProcessMapBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *DataProcessorImpProcessMapBuilder) ExpectArgsAre(config map[string]int) *DataProcessorImpProcessMapCall {
	validator := func(c *DataProcessorImpCall) bool {
		if c.Name() != "ProcessMap" {
			return false
		}
		methodCall := c.AsProcessMap()
		if !reflect.DeepEqual(methodCall.config, config) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsProcessMap()
}

func (bldr *DataProcessorImpProcessMapBuilder) ExpectArgsShould(config any) *DataProcessorImpProcessMapCall {
	validator := func(c *DataProcessorImpCall) bool {
		if c.Name() != "ProcessMap" {
			return false
		}
		methodCall := c.AsProcessMap()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.config, config)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsProcessMap()
}

func (bldr *DataProcessorImpProcessMapBuilder) InjectResult(result bool) *DataProcessorImpProcessMapCall {
	validator := func(c *DataProcessorImpCall) bool {
		return c.Name() == "ProcessMap"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsProcessMap()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *DataProcessorImpProcessMapBuilder) InjectPanic(msg any) *DataProcessorImpProcessMapCall {
	validator := func(c *DataProcessorImpCall) bool {
		return c.Name() == "ProcessMap"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsProcessMap()
	methodCall.InjectPanic(msg)
	return methodCall
}

type DataProcessorImpTimed struct {
	ExpectCallIs *DataProcessorImpExpectCallIs
}

func (i *DataProcessorImp) Within(d time.Duration) *DataProcessorImpTimed {
	return &DataProcessorImpTimed{
		ExpectCallIs: &DataProcessorImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *DataProcessorImp) GetCurrentCall() *DataProcessorImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *DataProcessorImpCall) bool { return true })
	return i.currentCall
}

func NewDataProcessorImp(t *testing.T) *DataProcessorImp {
	imp := &DataProcessorImp{
		Controller: imptest.NewController[*DataProcessorImpCall](t),
	}
	imp.Mock = &DataProcessorImpMock{imp: imp}
	imp.ExpectCallIs = &DataProcessorImpExpectCallIs{imp: imp}
	return imp
}
