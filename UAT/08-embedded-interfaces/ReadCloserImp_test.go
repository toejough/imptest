// Code generated by impgen. DO NOT EDIT.

package embedded_test

import "github.com/toejough/imptest/imptest"
import "reflect"
import "sync"
import "testing"
import "time"

type ReadCloserImpMock struct {
	imp *ReadCloserImp
}

type ReadCloserImp struct {
	t            *testing.T
	Mock         *ReadCloserImpMock
	callChan     chan *ReadCloserImpCall
	ExpectCallIs *ReadCloserImpExpectCallIs
	currentCall  *ReadCloserImpCall
	callQueue    []*ReadCloserImpCall
	queueLock    sync.Mutex
}

type ReadCloserImpReadCall struct {
	responseChan chan ReadCloserImpReadCallResponse
	done         bool
	p            []byte
}

type ReadCloserImpReadCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	n          int
	err        error
	PanicValue any
}

func (c *ReadCloserImpReadCall) InjectResults(r0 int, r1 error) {
	c.done = true
	resp := ReadCloserImpReadCallResponse{Type: "return", n: r0, err: r1}
	c.responseChan <- resp
}
func (c *ReadCloserImpReadCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- ReadCloserImpReadCallResponse{Type: "panic", PanicValue: msg}
}

type ReadCloserImpCloseCall struct {
	responseChan chan ReadCloserImpCloseCallResponse
	done         bool
}

type ReadCloserImpCloseCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

func (c *ReadCloserImpCloseCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- ReadCloserImpCloseCallResponse{Type: "return", Result0: result}
}
func (c *ReadCloserImpCloseCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- ReadCloserImpCloseCallResponse{Type: "panic", PanicValue: msg}
}

func (m *ReadCloserImpMock) Read(p []byte) (n int, err error) {
	responseChan := make(chan ReadCloserImpReadCallResponse, 1)

	call := &ReadCloserImpReadCall{
		responseChan: responseChan,
		p:            p,
	}

	callEvent := &ReadCloserImpCall{
		Read: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.n, resp.err
}

func (m *ReadCloserImpMock) Close() error {
	responseChan := make(chan ReadCloserImpCloseCallResponse, 1)

	call := &ReadCloserImpCloseCall{
		responseChan: responseChan,
	}

	callEvent := &ReadCloserImpCall{
		Close: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

type ReadCloserImpCall struct {
	Read  *ReadCloserImpReadCall
	Close *ReadCloserImpCloseCall
}

func (c *ReadCloserImpCall) Name() string {
	if c.Read != nil {
		return "Read"
	}
	if c.Close != nil {
		return "Close"
	}
	return ""
}

func (c *ReadCloserImpCall) Done() bool {
	if c.Read != nil {
		return c.Read.done
	}
	if c.Close != nil {
		return c.Close.done
	}
	return false
}

func (c *ReadCloserImpCall) AsRead() *ReadCloserImpReadCall { return c.Read }

func (c *ReadCloserImpCall) AsClose() *ReadCloserImpCloseCall { return c.Close }

type ReadCloserImpExpectCallIs struct {
	imp     *ReadCloserImp
	timeout time.Duration
}

type ReadCloserImpReadBuilder struct {
	imp     *ReadCloserImp
	timeout time.Duration
}

func (e *ReadCloserImpExpectCallIs) Read() *ReadCloserImpReadBuilder {
	return &ReadCloserImpReadBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *ReadCloserImpReadBuilder) ExpectArgsAre(p []byte) *ReadCloserImpReadCall {
	validator := func(c *ReadCloserImpCall) bool {
		if c.Name() != "Read" {
			return false
		}
		methodCall := c.AsRead()
		if !reflect.DeepEqual(methodCall.p, p) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsRead()
}

func (bldr *ReadCloserImpReadBuilder) ExpectArgsShould(p any) *ReadCloserImpReadCall {
	validator := func(c *ReadCloserImpCall) bool {
		if c.Name() != "Read" {
			return false
		}
		methodCall := c.AsRead()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.p, p)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsRead()
}

func (bldr *ReadCloserImpReadBuilder) InjectResults(r0 int, r1 error) *ReadCloserImpReadCall {
	validator := func(c *ReadCloserImpCall) bool {
		return c.Name() == "Read"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsRead()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

func (bldr *ReadCloserImpReadBuilder) InjectPanic(msg any) *ReadCloserImpReadCall {
	validator := func(c *ReadCloserImpCall) bool {
		return c.Name() == "Read"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsRead()
	methodCall.InjectPanic(msg)
	return methodCall
}

type ReadCloserImpCloseBuilder struct {
	imp     *ReadCloserImp
	timeout time.Duration
}

func (e *ReadCloserImpExpectCallIs) Close() *ReadCloserImpCloseBuilder {
	return &ReadCloserImpCloseBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *ReadCloserImpCloseBuilder) ExpectArgsAre() *ReadCloserImpCloseCall {
	validator := func(c *ReadCloserImpCall) bool {
		if c.Name() != "Close" {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsClose()
}

func (bldr *ReadCloserImpCloseBuilder) ExpectArgsShould() *ReadCloserImpCloseCall {
	validator := func(c *ReadCloserImpCall) bool {
		if c.Name() != "Close" {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsClose()
}

func (bldr *ReadCloserImpCloseBuilder) InjectResult(result error) *ReadCloserImpCloseCall {
	validator := func(c *ReadCloserImpCall) bool {
		return c.Name() == "Close"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsClose()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *ReadCloserImpCloseBuilder) InjectPanic(msg any) *ReadCloserImpCloseCall {
	validator := func(c *ReadCloserImpCall) bool {
		return c.Name() == "Close"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsClose()
	methodCall.InjectPanic(msg)
	return methodCall
}

type ReadCloserImpTimed struct {
	ExpectCallIs *ReadCloserImpExpectCallIs
}

func (i *ReadCloserImp) Within(d time.Duration) *ReadCloserImpTimed {
	return &ReadCloserImpTimed{
		ExpectCallIs: &ReadCloserImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *ReadCloserImp) GetCall(
	d time.Duration, validator func(*ReadCloserImpCall) bool,
) *ReadCloserImpCall {
	i.queueLock.Lock()

	// Check queue first while holding lock
	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			i.queueLock.Unlock()
			return call
		}
	}

	// Release lock before blocking on channel to avoid deadlock
	i.queueLock.Unlock()

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it - need lock to access shared queue
			i.queueLock.Lock()
			i.callQueue = append(i.callQueue, call)
			i.queueLock.Unlock()
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *ReadCloserImp) GetCurrentCall() *ReadCloserImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *ReadCloserImpCall) bool { return true })
	return i.currentCall
}

func NewReadCloserImp(t *testing.T) *ReadCloserImp {
	imp := &ReadCloserImp{
		t:        t,
		callChan: make(chan *ReadCloserImpCall, 1),
	}
	imp.Mock = &ReadCloserImpMock{imp: imp}
	imp.ExpectCallIs = &ReadCloserImpExpectCallIs{imp: imp}
	return imp
}
