// Code generated by impgen. DO NOT EDIT.

package callable_test

import "github.com/toejough/imptest/imptest"
import "sync"
import "testing"
import "time"

type ExternalServiceImpMock struct {
	imp *ExternalServiceImp
}

type ExternalServiceImp struct {
	t            *testing.T
	Mock         *ExternalServiceImpMock
	callChan     chan *ExternalServiceImpCall
	ExpectCallIs *ExternalServiceImpExpectCallIs
	currentCall  *ExternalServiceImpCall
	callQueue    []*ExternalServiceImpCall
	queueLock    sync.Mutex
}

type ExternalServiceImpFetchDataCall struct {
	responseChan chan ExternalServiceImpFetchDataCallResponse
	done         bool
	id           int
}

type ExternalServiceImpFetchDataCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    string
	Result1    error
	PanicValue any
}

func (c *ExternalServiceImpFetchDataCall) InjectResults(r0 string, r1 error) {
	c.done = true
	resp := ExternalServiceImpFetchDataCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}
func (c *ExternalServiceImpFetchDataCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- ExternalServiceImpFetchDataCallResponse{Type: "panic", PanicValue: msg}
}

type ExternalServiceImpProcessCall struct {
	responseChan chan ExternalServiceImpProcessCallResponse
	done         bool
	data         string
}

type ExternalServiceImpProcessCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    string
	PanicValue any
}

func (c *ExternalServiceImpProcessCall) InjectResult(result string) {
	c.done = true
	c.responseChan <- ExternalServiceImpProcessCallResponse{Type: "return", Result0: result}
}
func (c *ExternalServiceImpProcessCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- ExternalServiceImpProcessCallResponse{Type: "panic", PanicValue: msg}
}

func (m *ExternalServiceImpMock) FetchData(id int) (string, error) {
	responseChan := make(chan ExternalServiceImpFetchDataCallResponse, 1)

	call := &ExternalServiceImpFetchDataCall{
		responseChan: responseChan,
		id:           id,
	}

	callEvent := &ExternalServiceImpCall{
		FetchData: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

func (m *ExternalServiceImpMock) Process(data string) string {
	responseChan := make(chan ExternalServiceImpProcessCallResponse, 1)

	call := &ExternalServiceImpProcessCall{
		responseChan: responseChan,
		data:         data,
	}

	callEvent := &ExternalServiceImpCall{
		Process: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

type ExternalServiceImpCall struct {
	FetchData *ExternalServiceImpFetchDataCall
	Process   *ExternalServiceImpProcessCall
}

func (c *ExternalServiceImpCall) Name() string {
	if c.FetchData != nil {
		return "FetchData"
	}
	if c.Process != nil {
		return "Process"
	}
	return ""
}

func (c *ExternalServiceImpCall) Done() bool {
	if c.FetchData != nil {
		return c.FetchData.done
	}
	if c.Process != nil {
		return c.Process.done
	}
	return false
}

func (c *ExternalServiceImpCall) AsFetchData() *ExternalServiceImpFetchDataCall {
	return c.FetchData
}

func (c *ExternalServiceImpCall) AsProcess() *ExternalServiceImpProcessCall {
	return c.Process
}

type ExternalServiceImpExpectCallIs struct {
	imp     *ExternalServiceImp
	timeout time.Duration
}

type ExternalServiceImpFetchDataBuilder struct {
	imp     *ExternalServiceImp
	timeout time.Duration
}

func (e *ExternalServiceImpExpectCallIs) FetchData() *ExternalServiceImpFetchDataBuilder {
	return &ExternalServiceImpFetchDataBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *ExternalServiceImpFetchDataBuilder) ExpectArgsAre(id int) *ExternalServiceImpFetchDataCall {
	validator := func(c *ExternalServiceImpCall) bool {
		if c.Name() != "FetchData" {
			return false
		}
		methodCall := c.AsFetchData()
		if methodCall.id != id {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsFetchData()
}

func (bldr *ExternalServiceImpFetchDataBuilder) ExpectArgsShould(id any) *ExternalServiceImpFetchDataCall {
	validator := func(c *ExternalServiceImpCall) bool {
		if c.Name() != "FetchData" {
			return false
		}
		methodCall := c.AsFetchData()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.id, id)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsFetchData()
}

func (bldr *ExternalServiceImpFetchDataBuilder) InjectResults(r0 string, r1 error) *ExternalServiceImpFetchDataCall {
	validator := func(c *ExternalServiceImpCall) bool {
		return c.Name() == "FetchData"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsFetchData()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

func (bldr *ExternalServiceImpFetchDataBuilder) InjectPanic(msg any) *ExternalServiceImpFetchDataCall {
	validator := func(c *ExternalServiceImpCall) bool {
		return c.Name() == "FetchData"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsFetchData()
	methodCall.InjectPanic(msg)
	return methodCall
}

type ExternalServiceImpProcessBuilder struct {
	imp     *ExternalServiceImp
	timeout time.Duration
}

func (e *ExternalServiceImpExpectCallIs) Process() *ExternalServiceImpProcessBuilder {
	return &ExternalServiceImpProcessBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *ExternalServiceImpProcessBuilder) ExpectArgsAre(data string) *ExternalServiceImpProcessCall {
	validator := func(c *ExternalServiceImpCall) bool {
		if c.Name() != "Process" {
			return false
		}
		methodCall := c.AsProcess()
		if methodCall.data != data {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsProcess()
}

func (bldr *ExternalServiceImpProcessBuilder) ExpectArgsShould(data any) *ExternalServiceImpProcessCall {
	validator := func(c *ExternalServiceImpCall) bool {
		if c.Name() != "Process" {
			return false
		}
		methodCall := c.AsProcess()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.data, data)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsProcess()
}

func (bldr *ExternalServiceImpProcessBuilder) InjectResult(result string) *ExternalServiceImpProcessCall {
	validator := func(c *ExternalServiceImpCall) bool {
		return c.Name() == "Process"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsProcess()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *ExternalServiceImpProcessBuilder) InjectPanic(msg any) *ExternalServiceImpProcessCall {
	validator := func(c *ExternalServiceImpCall) bool {
		return c.Name() == "Process"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsProcess()
	methodCall.InjectPanic(msg)
	return methodCall
}

type ExternalServiceImpTimed struct {
	ExpectCallIs *ExternalServiceImpExpectCallIs
}

func (i *ExternalServiceImp) Within(d time.Duration) *ExternalServiceImpTimed {
	return &ExternalServiceImpTimed{
		ExpectCallIs: &ExternalServiceImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *ExternalServiceImp) GetCall(
	d time.Duration, validator func(*ExternalServiceImpCall) bool,
) *ExternalServiceImpCall {
	i.queueLock.Lock()

	// Check queue first while holding lock
	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			i.queueLock.Unlock()
			return call
		}
	}

	// Release lock before blocking on channel to avoid deadlock
	i.queueLock.Unlock()

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it - need lock to access shared queue
			i.queueLock.Lock()
			i.callQueue = append(i.callQueue, call)
			i.queueLock.Unlock()
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *ExternalServiceImp) GetCurrentCall() *ExternalServiceImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *ExternalServiceImpCall) bool { return true })
	return i.currentCall
}

func NewExternalServiceImp(t *testing.T) *ExternalServiceImp {
	imp := &ExternalServiceImp{
		t:        t,
		callChan: make(chan *ExternalServiceImpCall, 1),
	}
	imp.Mock = &ExternalServiceImpMock{imp: imp}
	imp.ExpectCallIs = &ExternalServiceImpExpectCallIs{imp: imp}
	return imp
}
