// Code generated by impgen. DO NOT EDIT.

package callable_test

import (
	callable "github.com/toejough/imptest/UAT/02-callable-wrappers"
	"github.com/toejough/imptest/imptest"
	"testing"
)

type BusinessLogicImpReturn struct {
	Result0 string
	Result1 error
}

type BusinessLogicImp struct {
	t        testing.TB
	callable func(svc callable.ExternalService, id int) (string, error)

	returnChan chan BusinessLogicImpReturn
	panicChan  chan any
	returned   *BusinessLogicImpReturn
	panicked   any
}

func NewBusinessLogicImp(t testing.TB, callable func(svc callable.ExternalService, id int) (string, error)) *BusinessLogicImp {
	return &BusinessLogicImp{
		t:          t,
		callable:   callable,
		returnChan: make(chan BusinessLogicImpReturn, 1),
		panicChan:  make(chan any, 1),
	}
}

func (s *BusinessLogicImp) Start(svc callable.ExternalService, id int) *BusinessLogicImp {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				s.panicChan <- r
			}
		}()

		ret0, ret1 := s.callable(svc, id)
		s.returnChan <- BusinessLogicImpReturn{
			Result0: ret0,
			Result1: ret1,
		}
	}()
	return s
}

func (s *BusinessLogicImp) ExpectReturnedValuesAre(v1 string, v2 error) {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.returned != nil {
		if s.returned.Result0 != v1 {
			s.t.Fatalf("expected return value 0 to be %v, got %v", v1, s.returned.Result0)
		}
		if s.returned.Result1 != v2 {
			s.t.Fatalf("expected return value 1 to be %v, got %v", v2, s.returned.Result1)
		}
		return
	}

	if s.panicked != nil {
		s.t.Fatalf("expected function to return, but it panicked with: %v", s.panicked)
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		if ret.Result0 != v1 {
			s.t.Fatalf("expected return value 0 to be %v, got %v", v1, ret.Result0)
		}
		if ret.Result1 != v2 {
			s.t.Fatalf("expected return value 1 to be %v, got %v", v2, ret.Result1)
		}
	case p := <-s.panicChan:
		s.panicked = p
		s.t.Fatalf("expected function to return, but it panicked with: %v", p)
	}
}

func (s *BusinessLogicImp) ExpectReturnedValuesShould(v1 any, v2 any) {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.returned != nil {
		var ok bool
		var msg string
		ok, msg = imptest.MatchValue(s.returned.Result0, v1)
		if !ok {
			s.t.Fatalf("return value 0: %s", msg)
		}
		ok, msg = imptest.MatchValue(s.returned.Result1, v2)
		if !ok {
			s.t.Fatalf("return value 1: %s", msg)
		}
		return
	}

	if s.panicked != nil {
		s.t.Fatalf("expected function to return, but it panicked with: %v", s.panicked)
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		var ok bool
		var msg string
		ok, msg = imptest.MatchValue(ret.Result0, v1)
		if !ok {
			s.t.Fatalf("return value 0: %s", msg)
		}
		ok, msg = imptest.MatchValue(ret.Result1, v2)
		if !ok {
			s.t.Fatalf("return value 1: %s", msg)
		}
	case p := <-s.panicChan:
		s.panicked = p
		s.t.Fatalf("expected function to return, but it panicked with: %v", p)
	}
}

func (s *BusinessLogicImp) ExpectPanicWith(expected any) {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.panicked != nil {
		ok, msg := imptest.MatchValue(s.panicked, expected)
		if !ok {
			s.t.Fatalf("panic value: %s", msg)
		}
		return
	}

	if s.returned != nil {
		s.t.Fatalf("expected function to panic, but it returned")
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		s.t.Fatalf("expected function to panic, but it returned")
	case p := <-s.panicChan:
		s.panicked = p
		ok, msg := imptest.MatchValue(p, expected)
		if !ok {
			s.t.Fatalf("panic value: %s", msg)
		}
	}
}

type BusinessLogicImpResponse struct {
	EventType string // "return" or "panic"
	ReturnVal *BusinessLogicImpReturn
	PanicVal  any
}

func (r *BusinessLogicImpResponse) Type() string {
	return r.EventType
}

func (r *BusinessLogicImpResponse) AsReturn() []any {
	if r.ReturnVal == nil {
		return nil
	}
	return []any{r.ReturnVal.Result0, r.ReturnVal.Result1}
}

func (s *BusinessLogicImp) GetResponse() *BusinessLogicImpResponse {
	// Check if we already have a return value or panic
	if s.returned != nil {
		return &BusinessLogicImpResponse{
			EventType: "ReturnEvent",
			ReturnVal: s.returned,
		}
	}

	if s.panicked != nil {
		return &BusinessLogicImpResponse{
			EventType: "PanicEvent",
			PanicVal:  s.panicked,
		}
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		return &BusinessLogicImpResponse{
			EventType: "ReturnEvent",
			ReturnVal: &ret,
		}
	case p := <-s.panicChan:
		s.panicked = p
		return &BusinessLogicImpResponse{
			EventType: "PanicEvent",
			PanicVal:  p,
		}
	}
}
