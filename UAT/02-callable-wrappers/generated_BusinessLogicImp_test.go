// Code generated by impgen. DO NOT EDIT.

package callable_test

import (
	callable "github.com/toejough/imptest/UAT/02-callable-wrappers"
	"github.com/toejough/imptest/imptest"
	"testing"
)

// BusinessLogicImpReturn holds the return values from the callable function.
// Access individual return values via Result0, Result1, etc. fields.
type BusinessLogicImpReturn struct {
	Result0 string
	Result1 error
}

// BusinessLogicImp wraps a callable function for testing.
// Create with NewBusinessLogicImp(t, yourFunction), call Start() to execute,
// then use ExpectReturnedValuesAre/Should() or ExpectPanicWith() to verify behavior.
type BusinessLogicImp struct {
	*imptest.CallableController[BusinessLogicImpReturn]
	callable func(svc callable.ExternalService, id int) (string, error)
}

// NewBusinessLogicImp creates a new wrapper for testing the callable function.
// Pass the function to test and a testing.TB to enable assertion failures.
//
// Example:
//
//	wrapper := NewBusinessLogicImp(t, myFunction)
//	wrapper.Start(args...).ExpectReturnedValuesAre(expectedVals...)
func NewBusinessLogicImp(t testing.TB, callable func(svc callable.ExternalService, id int) (string, error)) *BusinessLogicImp {
	return &BusinessLogicImp{
		CallableController: imptest.NewCallableController[BusinessLogicImpReturn](t),
		callable:           callable,
	}
}

// Start begins execution of the callable in a goroutine with the provided arguments.
// Returns the wrapper for method chaining with expectation methods.
// Captures both normal returns and panics for verification.
//
// Example:
//
//	wrapper.Start(arg1, arg2).ExpectReturnedValuesAre(expectedResult)
func (s *BusinessLogicImp) Start(svc callable.ExternalService, id int) *BusinessLogicImp {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				s.PanicChan <- r
			}
		}()

		ret0, ret1 := s.callable(svc, id)
		s.ReturnChan <- BusinessLogicImpReturn{
			Result0: ret0,
			Result1: ret1,
		}
	}()
	return s
}

// ExpectReturnedValuesAre asserts the callable returned with exactly the specified values.
// Fails the test if the values don't match exactly or if the callable panicked.
// Uses == for comparison, so reference types must be the same instance.
func (s *BusinessLogicImp) ExpectReturnedValuesAre(v1 string, v2 error) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Returned != nil {
		if s.Returned.Result0 != v1 {
			s.T.Fatalf("expected return value 0 to be %v, got %v", v1, s.Returned.Result0)
		}
		if s.Returned.Result1 != v2 {
			s.T.Fatalf("expected return value 1 to be %v, got %v", v2, s.Returned.Result1)
		}
		return
	}

	s.T.Fatalf("expected function to return, but it panicked with: %v", s.Panicked)
}

// ExpectReturnedValuesShould asserts return values match the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Fails the test if any matcher fails or if the callable panicked.
func (s *BusinessLogicImp) ExpectReturnedValuesShould(v1 any, v2 any) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Returned != nil {
		var ok bool
		var msg string
		ok, msg = imptest.MatchValue(s.Returned.Result0, v1)
		if !ok {
			s.T.Fatalf("return value 0: %s", msg)
		}
		ok, msg = imptest.MatchValue(s.Returned.Result1, v2)
		if !ok {
			s.T.Fatalf("return value 1: %s", msg)
		}
		return
	}

	s.T.Fatalf("expected function to return, but it panicked with: %v", s.Panicked)
}

// ExpectPanicWith asserts the callable panicked with a value matching the expectation.
// Use imptest.Any() to match any panic value, or imptest.Satisfies(fn) for custom matching.
// Fails the test if the callable returned normally or panicked with a different value.
func (s *BusinessLogicImp) ExpectPanicWith(expected any) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Panicked != nil {
		ok, msg := imptest.MatchValue(s.Panicked, expected)
		if !ok {
			s.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	s.T.Fatalf("expected function to panic, but it returned")
}

// BusinessLogicImpResponse represents the response from the callable (either return or panic).
// Check EventType to determine if the callable returned normally or panicked.
// Use AsReturn() to get return values as a slice, or access PanicVal directly.
type BusinessLogicImpResponse struct {
	EventType string // "return" or "panic"
	ReturnVal *BusinessLogicImpReturn
	PanicVal  any
}

// Type returns the event type: "return" for normal returns, "panic" for panics.
func (r *BusinessLogicImpResponse) Type() string {
	return r.EventType
}

// AsReturn converts the return values to a slice of any for generic processing.
// Returns nil if the response was a panic or if there are no return values.
func (r *BusinessLogicImpResponse) AsReturn() []any {
	if r.ReturnVal == nil {
		return nil
	}
	return []any{r.ReturnVal.Result0, r.ReturnVal.Result1}
}

// GetResponse waits for and returns the callable's response.
// Use this when you need to inspect the response without asserting specific values.
// The response indicates whether the callable returned or panicked.
func (s *BusinessLogicImp) GetResponse() *BusinessLogicImpResponse {
	s.WaitForResponse()

	if s.Returned != nil {
		return &BusinessLogicImpResponse{
			EventType: "ReturnEvent",
			ReturnVal: s.Returned,
		}
	}

	return &BusinessLogicImpResponse{
		EventType: "PanicEvent",
		PanicVal:  s.Panicked,
	}
}
