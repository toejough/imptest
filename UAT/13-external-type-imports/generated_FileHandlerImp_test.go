// Code generated by impgen. DO NOT EDIT.

package externalimports_test

import _imptest "github.com/toejough/imptest/imptest"
import _reflect "reflect"
import _testing "testing"
import _time "time"
import externalimports "github.com/toejough/imptest/UAT/13-external-type-imports"
import io "io"
import os "os"

// FileHandlerImp is the test controller for mocking the interface.
// Create with NewFileHandlerImp(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := NewFileHandlerImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type FileHandlerImp struct {
	*_imptest.Controller[*FileHandlerImpCall]
	Mock         *FileHandlerImpMock
	ExpectCallIs *FileHandlerImpExpectCallIs
	currentCall  *FileHandlerImpCall
}

// NewFileHandlerImp creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := NewFileHandlerImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func NewFileHandlerImp(t *_testing.T) *FileHandlerImp {
	imp := &FileHandlerImp{
		Controller: _imptest.NewController[*FileHandlerImpCall](t),
	}
	imp.Mock = &FileHandlerImpMock{imp: imp}
	imp.ExpectCallIs = &FileHandlerImpExpectCallIs{imp: imp}
	return imp
}

// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *FileHandlerImp) GetCurrentCall() *FileHandlerImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *FileHandlerImpCall) bool { return true })
	return i.currentCall
}

// Within configures a timeout for expectations and returns a FileHandlerImpTimed for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*_time.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *FileHandlerImp) Within(d _time.Duration) *FileHandlerImpTimed {
	return &FileHandlerImpTimed{
		ExpectCallIs: &FileHandlerImpExpectCallIs{imp: i, timeout: d},
	}
}

// FileHandlerImpCall represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{Method}() to access typed call details.
type FileHandlerImpCall struct {
	readAll  *FileHandlerImpReadAllCall
	openFile *FileHandlerImpOpenFileCall
	stats    *FileHandlerImpStatsCall
}

// AsOpenFile returns the call cast to FileHandlerImpOpenFileCall for accessing call details.
// Returns nil if the call was not to OpenFile.
func (c *FileHandlerImpCall) AsOpenFile() *FileHandlerImpOpenFileCall {
	return c.openFile
}

// AsReadAll returns the call cast to FileHandlerImpReadAllCall for accessing call details.
// Returns nil if the call was not to ReadAll.
func (c *FileHandlerImpCall) AsReadAll() *FileHandlerImpReadAllCall {
	return c.readAll
}

// AsStats returns the call cast to FileHandlerImpStatsCall for accessing call details.
// Returns nil if the call was not to Stats.
func (c *FileHandlerImpCall) AsStats() *FileHandlerImpStatsCall {
	return c.stats
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *FileHandlerImpCall) Done() bool {
	if c.readAll != nil {
		return c.readAll.done
	}
	if c.openFile != nil {
		return c.openFile.done
	}
	if c.stats != nil {
		return c.stats.done
	}
	return false
}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *FileHandlerImpCall) Name() string {
	if c.readAll != nil {
		return "ReadAll"
	}
	if c.openFile != nil {
		return "OpenFile"
	}
	if c.stats != nil {
		return "Stats"
	}
	return ""
}

// FileHandlerImpExpectCallIs provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent FileHandlerImp to configure timeouts.
type FileHandlerImpExpectCallIs struct {
	imp     *FileHandlerImp
	timeout _time.Duration
}

// OpenFile returns a builder for setting expectations on OpenFile method calls.
func (e *FileHandlerImpExpectCallIs) OpenFile() *FileHandlerImpOpenFileBuilder {
	return &FileHandlerImpOpenFileBuilder{imp: e.imp, timeout: e.timeout}
}

// ReadAll returns a builder for setting expectations on ReadAll method calls.
func (e *FileHandlerImpExpectCallIs) ReadAll() *FileHandlerImpReadAllBuilder {
	return &FileHandlerImpReadAllBuilder{imp: e.imp, timeout: e.timeout}
}

// Stats returns a builder for setting expectations on Stats method calls.
func (e *FileHandlerImpExpectCallIs) Stats() *FileHandlerImpStatsBuilder {
	return &FileHandlerImpStatsBuilder{imp: e.imp, timeout: e.timeout}
}

// FileHandlerImpMock provides the mock implementation of the interface.
// Pass FileHandlerImpMock to code under test that expects the interface implementation.
// Use the parent FileHandlerImp controller to set expectations and inject responses.
type FileHandlerImpMock struct {
	imp *FileHandlerImp
}

// OpenFile implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileHandlerImpMock) OpenFile(path string, mode os.FileMode) (*os.File, error) {
	responseChan := make(chan FileHandlerImpOpenFileCallResponse, 1)

	call := &FileHandlerImpOpenFileCall{
		responseChan: responseChan,
		path:         path,
		mode:         mode,
		t:            m.imp.T,
	}

	callEvent := &FileHandlerImpCall{
		openFile: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// ReadAll implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileHandlerImpMock) ReadAll(r io.Reader) ([]byte, error) {
	responseChan := make(chan FileHandlerImpReadAllCallResponse, 1)

	call := &FileHandlerImpReadAllCall{
		responseChan: responseChan,
		r:            r,
		t:            m.imp.T,
	}

	callEvent := &FileHandlerImpCall{
		readAll: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// Stats implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *FileHandlerImpMock) Stats(path string) (os.FileInfo, error) {
	responseChan := make(chan FileHandlerImpStatsCallResponse, 1)

	call := &FileHandlerImpStatsCall{
		responseChan: responseChan,
		path:         path,
		t:            m.imp.T,
	}

	callEvent := &FileHandlerImpCall{
		stats: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// FileHandlerImpOpenFileBuilder provides a fluent API for setting expectations on OpenFile calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileHandlerImpOpenFileBuilder struct {
	imp     *FileHandlerImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a OpenFile call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileHandlerImpOpenFileBuilder) ExpectArgsAre(path string, mode os.FileMode) *FileHandlerImpOpenFileCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		if callToCheck.Name() != "OpenFile" {
			return false
		}
		methodCall := callToCheck.AsOpenFile()
		if methodCall.path != path {
			return false
		}
		if !_reflect.DeepEqual(methodCall.mode, mode) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsOpenFile()
}

// ExpectArgsShould waits for a OpenFile call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileHandlerImpOpenFileBuilder) ExpectArgsShould(path any, mode any) *FileHandlerImpOpenFileCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		if callToCheck.Name() != "OpenFile" {
			return false
		}
		methodCall := callToCheck.AsOpenFile()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		ok, _ = _imptest.MatchValue(methodCall.mode, mode)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsOpenFile()
}

// InjectPanic waits for a OpenFile call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileHandlerImpOpenFileBuilder) InjectPanic(msg any) *FileHandlerImpOpenFileCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		return callToCheck.Name() == "OpenFile"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsOpenFile()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a OpenFile call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileHandlerImpOpenFileBuilder) InjectResults(r0 *os.File, r1 error) *FileHandlerImpOpenFileCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		return callToCheck.Name() == "OpenFile"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsOpenFile()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// FileHandlerImpOpenFileCall represents a captured call to the OpenFile method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileHandlerImpOpenFileCall struct {
	responseChan chan FileHandlerImpOpenFileCallResponse
	done         bool
	path         string
	mode         os.FileMode
	t            _imptest.Tester
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileHandlerImpOpenFileCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileHandlerImpOpenFileCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *FileHandlerImpOpenFileCall) InjectResults(r0 *os.File, r1 error) {
	c.done = true
	resp := FileHandlerImpOpenFileCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// FileHandlerImpOpenFileCallResponse holds the response configuration for the OpenFile method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileHandlerImpOpenFileCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    *os.File
	Result1    error
	PanicValue any
}

// FileHandlerImpReadAllBuilder provides a fluent API for setting expectations on ReadAll calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileHandlerImpReadAllBuilder struct {
	imp     *FileHandlerImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a ReadAll call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileHandlerImpReadAllBuilder) ExpectArgsAre(r io.Reader) *FileHandlerImpReadAllCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		if callToCheck.Name() != "ReadAll" {
			return false
		}
		methodCall := callToCheck.AsReadAll()
		if !_reflect.DeepEqual(methodCall.r, r) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsReadAll()
}

// ExpectArgsShould waits for a ReadAll call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileHandlerImpReadAllBuilder) ExpectArgsShould(r any) *FileHandlerImpReadAllCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		if callToCheck.Name() != "ReadAll" {
			return false
		}
		methodCall := callToCheck.AsReadAll()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.r, r)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsReadAll()
}

// InjectPanic waits for a ReadAll call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileHandlerImpReadAllBuilder) InjectPanic(msg any) *FileHandlerImpReadAllCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		return callToCheck.Name() == "ReadAll"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsReadAll()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a ReadAll call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileHandlerImpReadAllBuilder) InjectResults(r0 []byte, r1 error) *FileHandlerImpReadAllCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		return callToCheck.Name() == "ReadAll"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsReadAll()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// FileHandlerImpReadAllCall represents a captured call to the ReadAll method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileHandlerImpReadAllCall struct {
	responseChan chan FileHandlerImpReadAllCallResponse
	done         bool
	r            io.Reader
	t            _imptest.Tester
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileHandlerImpReadAllCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileHandlerImpReadAllCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *FileHandlerImpReadAllCall) InjectResults(r0 []byte, r1 error) {
	c.done = true
	resp := FileHandlerImpReadAllCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// FileHandlerImpReadAllCallResponse holds the response configuration for the ReadAll method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileHandlerImpReadAllCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    []byte
	Result1    error
	PanicValue any
}

// FileHandlerImpStatsBuilder provides a fluent API for setting expectations on Stats calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type FileHandlerImpStatsBuilder struct {
	imp     *FileHandlerImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Stats call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *FileHandlerImpStatsBuilder) ExpectArgsAre(path string) *FileHandlerImpStatsCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		if callToCheck.Name() != "Stats" {
			return false
		}
		methodCall := callToCheck.AsStats()
		if methodCall.path != path {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsStats()
}

// ExpectArgsShould waits for a Stats call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *FileHandlerImpStatsBuilder) ExpectArgsShould(path any) *FileHandlerImpStatsCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		if callToCheck.Name() != "Stats" {
			return false
		}
		methodCall := callToCheck.AsStats()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.path, path)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsStats()
}

// InjectPanic waits for a Stats call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *FileHandlerImpStatsBuilder) InjectPanic(msg any) *FileHandlerImpStatsCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		return callToCheck.Name() == "Stats"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsStats()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a Stats call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *FileHandlerImpStatsBuilder) InjectResults(r0 os.FileInfo, r1 error) *FileHandlerImpStatsCall {
	validator := func(callToCheck *FileHandlerImpCall) bool {
		return callToCheck.Name() == "Stats"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsStats()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// FileHandlerImpStatsCall represents a captured call to the Stats method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type FileHandlerImpStatsCall struct {
	responseChan chan FileHandlerImpStatsCallResponse
	done         bool
	path         string
	t            _imptest.Tester
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *FileHandlerImpStatsCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- FileHandlerImpStatsCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *FileHandlerImpStatsCall) InjectResults(r0 os.FileInfo, r1 error) {
	c.done = true
	resp := FileHandlerImpStatsCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// FileHandlerImpStatsCallResponse holds the response configuration for the Stats method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type FileHandlerImpStatsCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    os.FileInfo
	Result1    error
	PanicValue any
}

// FileHandlerImpTimed provides timeout-configured expectation methods.
// Access via FileHandlerImp.Within(duration) to set a timeout for expectations.
type FileHandlerImpTimed struct {
	ExpectCallIs *FileHandlerImpExpectCallIs
}

// unexported variables.
var (
	// Compile-time verification that FileHandlerImpMock implements externalimports.FileHandler.
	_ externalimports.FileHandler = (*FileHandlerImpMock)(nil)
)
