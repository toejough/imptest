// Code generated by impgen. DO NOT EDIT.

package generics_test

import (
	generics "github.com/toejough/imptest/UAT/07-generics"
	_imptest "github.com/toejough/imptest/imptest"
)

// RepositoryMock is the mock for Repository.
type RepositoryMock[T any] struct {
	imp  *_imptest.Imp
	Save *RepositoryMockSaveMethod[T]
	Get  *RepositoryMockGetMethod[T]
}

// Interface returns the Repository implementation that can be passed to code under test.
func (m *RepositoryMock[T]) Interface() generics.Repository[T] {
	return &mockRepositoryImpl[T]{mock: m}
}

// RepositoryMockGetArgs holds typed arguments for Get.
type RepositoryMockGetArgs[T any] struct {
	Id string
}

// RepositoryMockGetCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type RepositoryMockGetCall[T any] struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RepositoryMockGetCall[T]) GetArgs() RepositoryMockGetArgs[T] {
	raw := c.RawArgs()
	return RepositoryMockGetArgs[T]{
		Id: raw[0].(string),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *RepositoryMockGetCall[T]) InjectReturnValues(result0 T, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// RepositoryMockGetMethod wraps DependencyMethod with typed returns.
type RepositoryMockGetMethod[T any] struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *RepositoryMockGetMethod[T]) Eventually() *RepositoryMockGetMethod[T] {
	return &RepositoryMockGetMethod[T]{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *RepositoryMockGetMethod[T]) ExpectCalledWithExactly(id string) *RepositoryMockGetCall[T] {
	call := m.DependencyMethod.ExpectCalledWithExactly(id)
	return &RepositoryMockGetCall[T]{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *RepositoryMockGetMethod[T]) ExpectCalledWithMatches(matchers ...any) *RepositoryMockGetCall[T] {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &RepositoryMockGetCall[T]{DependencyCall: call}
}

// RepositoryMockSaveArgs holds typed arguments for Save.
type RepositoryMockSaveArgs[T any] struct {
	Item T
}

// RepositoryMockSaveCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type RepositoryMockSaveCall[T any] struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RepositoryMockSaveCall[T]) GetArgs() RepositoryMockSaveArgs[T] {
	raw := c.RawArgs()
	return RepositoryMockSaveArgs[T]{
		Item: raw[0].(T),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *RepositoryMockSaveCall[T]) InjectReturnValues(result0 error) {
	c.DependencyCall.InjectReturnValues(result0)
}

// RepositoryMockSaveMethod wraps DependencyMethod with typed returns.
type RepositoryMockSaveMethod[T any] struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *RepositoryMockSaveMethod[T]) Eventually() *RepositoryMockSaveMethod[T] {
	return &RepositoryMockSaveMethod[T]{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *RepositoryMockSaveMethod[T]) ExpectCalledWithExactly(item T) *RepositoryMockSaveCall[T] {
	call := m.DependencyMethod.ExpectCalledWithExactly(item)
	return &RepositoryMockSaveCall[T]{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *RepositoryMockSaveMethod[T]) ExpectCalledWithMatches(matchers ...any) *RepositoryMockSaveCall[T] {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &RepositoryMockSaveCall[T]{DependencyCall: call}
}

// MockRepository creates a new RepositoryMock for testing.
func MockRepository[T any](t _imptest.TestReporter) *RepositoryMock[T] {
	imp := _imptest.NewImp(t)
	return &RepositoryMock[T]{
		imp:  imp,
		Save: &RepositoryMockSaveMethod[T]{DependencyMethod: _imptest.NewDependencyMethod(imp, "Save")},
		Get:  &RepositoryMockGetMethod[T]{DependencyMethod: _imptest.NewDependencyMethod(imp, "Get")},
	}
}

// mockRepositoryImpl implements generics.Repository[T].
type mockRepositoryImpl[T any] struct {
	mock *RepositoryMock[T]
}

// Get implements generics.Repository[T].Get.
func (impl *mockRepositoryImpl[T]) Get(id string) (T, error) {
	call := &_imptest.GenericCall{
		MethodName:   "Get",
		Args:         []any{id},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 T
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(T); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// Save implements generics.Repository[T].Save.
func (impl *mockRepositoryImpl[T]) Save(item T) error {
	call := &_imptest.GenericCall{
		MethodName:   "Save",
		Args:         []any{item},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}
