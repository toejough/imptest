// Code generated by impgen. DO NOT EDIT.

package generics_test

import "github.com/toejough/imptest/imptest"
import "reflect"
import "sync"
import "testing"
import "time"

type RepositoryImpMock[T any] struct {
	imp *RepositoryImp[T]
}

type RepositoryImp[T any] struct {
	t            *testing.T
	Mock         *RepositoryImpMock[T]
	callChan     chan *RepositoryImpCall[T]
	ExpectCallIs *RepositoryImpExpectCallIs[T]
	currentCall  *RepositoryImpCall[T]
	callQueue    []*RepositoryImpCall[T]
	queueLock    sync.Mutex
}

type RepositoryImpSaveCall[T any] struct {
	responseChan chan RepositoryImpSaveCallResponse[T]
	done         bool
	item         T
}

type RepositoryImpSaveCallResponse[T any] struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

func (c *RepositoryImpSaveCall[T]) InjectResult(result error) {
	c.done = true
	c.responseChan <- RepositoryImpSaveCallResponse[T]{Type: "return", Result0: result}
}
func (c *RepositoryImpSaveCall[T]) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- RepositoryImpSaveCallResponse[T]{Type: "panic", PanicValue: msg}
}

type RepositoryImpGetCall[T any] struct {
	responseChan chan RepositoryImpGetCallResponse[T]
	done         bool
	id           string
}

type RepositoryImpGetCallResponse[T any] struct {
	Type       string // "return", "panic", or "resolve"
	Result0    T
	Result1    error
	PanicValue any
}

func (c *RepositoryImpGetCall[T]) InjectResults(r0 T, r1 error) {
	c.done = true
	resp := RepositoryImpGetCallResponse[T]{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}
func (c *RepositoryImpGetCall[T]) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- RepositoryImpGetCallResponse[T]{Type: "panic", PanicValue: msg}
}

func (m *RepositoryImpMock[T]) Save(item T) error {
	responseChan := make(chan RepositoryImpSaveCallResponse[T], 1)

	call := &RepositoryImpSaveCall[T]{
		responseChan: responseChan,
		item:         item,
	}

	callEvent := &RepositoryImpCall[T]{
		Save: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

func (m *RepositoryImpMock[T]) Get(id string) (T, error) {
	responseChan := make(chan RepositoryImpGetCallResponse[T], 1)

	call := &RepositoryImpGetCall[T]{
		responseChan: responseChan,
		id:           id,
	}

	callEvent := &RepositoryImpCall[T]{
		Get: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

type RepositoryImpCall[T any] struct {
	Save *RepositoryImpSaveCall[T]
	Get  *RepositoryImpGetCall[T]
}

func (c *RepositoryImpCall[T]) Name() string {
	if c.Save != nil {
		return "Save"
	}
	if c.Get != nil {
		return "Get"
	}
	return ""
}

func (c *RepositoryImpCall[T]) Done() bool {
	if c.Save != nil {
		return c.Save.done
	}
	if c.Get != nil {
		return c.Get.done
	}
	return false
}

func (c *RepositoryImpCall[T]) AsSave() *RepositoryImpSaveCall[T] { return c.Save }

func (c *RepositoryImpCall[T]) AsGet() *RepositoryImpGetCall[T] { return c.Get }

type RepositoryImpExpectCallIs[T any] struct {
	imp     *RepositoryImp[T]
	timeout time.Duration
}

type RepositoryImpSaveBuilder[T any] struct {
	imp     *RepositoryImp[T]
	timeout time.Duration
}

func (e *RepositoryImpExpectCallIs[T]) Save() *RepositoryImpSaveBuilder[T] {
	return &RepositoryImpSaveBuilder[T]{imp: e.imp, timeout: e.timeout}
}

func (bldr *RepositoryImpSaveBuilder[T]) ExpectArgsAre(item T) *RepositoryImpSaveCall[T] {
	validator := func(c *RepositoryImpCall[T]) bool {
		if c.Name() != "Save" {
			return false
		}
		methodCall := c.AsSave()
		if !reflect.DeepEqual(methodCall.item, item) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsSave()
}

func (bldr *RepositoryImpSaveBuilder[T]) ExpectArgsShould(item any) *RepositoryImpSaveCall[T] {
	validator := func(c *RepositoryImpCall[T]) bool {
		if c.Name() != "Save" {
			return false
		}
		methodCall := c.AsSave()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.item, item)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsSave()
}

func (bldr *RepositoryImpSaveBuilder[T]) InjectResult(result error) *RepositoryImpSaveCall[T] {
	validator := func(c *RepositoryImpCall[T]) bool {
		return c.Name() == "Save"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsSave()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *RepositoryImpSaveBuilder[T]) InjectPanic(msg any) *RepositoryImpSaveCall[T] {
	validator := func(c *RepositoryImpCall[T]) bool {
		return c.Name() == "Save"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsSave()
	methodCall.InjectPanic(msg)
	return methodCall
}

type RepositoryImpGetBuilder[T any] struct {
	imp     *RepositoryImp[T]
	timeout time.Duration
}

func (e *RepositoryImpExpectCallIs[T]) Get() *RepositoryImpGetBuilder[T] {
	return &RepositoryImpGetBuilder[T]{imp: e.imp, timeout: e.timeout}
}

func (bldr *RepositoryImpGetBuilder[T]) ExpectArgsAre(id string) *RepositoryImpGetCall[T] {
	validator := func(c *RepositoryImpCall[T]) bool {
		if c.Name() != "Get" {
			return false
		}
		methodCall := c.AsGet()
		if methodCall.id != id {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsGet()
}

func (bldr *RepositoryImpGetBuilder[T]) ExpectArgsShould(id any) *RepositoryImpGetCall[T] {
	validator := func(c *RepositoryImpCall[T]) bool {
		if c.Name() != "Get" {
			return false
		}
		methodCall := c.AsGet()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.id, id)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsGet()
}

func (bldr *RepositoryImpGetBuilder[T]) InjectResults(r0 T, r1 error) *RepositoryImpGetCall[T] {
	validator := func(c *RepositoryImpCall[T]) bool {
		return c.Name() == "Get"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsGet()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

func (bldr *RepositoryImpGetBuilder[T]) InjectPanic(msg any) *RepositoryImpGetCall[T] {
	validator := func(c *RepositoryImpCall[T]) bool {
		return c.Name() == "Get"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsGet()
	methodCall.InjectPanic(msg)
	return methodCall
}

type RepositoryImpTimed[T any] struct {
	ExpectCallIs *RepositoryImpExpectCallIs[T]
}

func (i *RepositoryImp[T]) Within(d time.Duration) *RepositoryImpTimed[T] {
	return &RepositoryImpTimed[T]{
		ExpectCallIs: &RepositoryImpExpectCallIs[T]{imp: i, timeout: d},
	}
}

func (i *RepositoryImp[T]) GetCall(
	d time.Duration, validator func(*RepositoryImpCall[T]) bool,
) *RepositoryImpCall[T] {
	i.queueLock.Lock()

	// Check queue first while holding lock
	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			i.queueLock.Unlock()
			return call
		}
	}

	// Release lock before blocking on channel to avoid deadlock
	i.queueLock.Unlock()

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it - need lock to access shared queue
			i.queueLock.Lock()
			i.callQueue = append(i.callQueue, call)
			i.queueLock.Unlock()
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *RepositoryImp[T]) GetCurrentCall() *RepositoryImpCall[T] {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *RepositoryImpCall[T]) bool { return true })
	return i.currentCall
}

func NewRepositoryImp[T any](t *testing.T) *RepositoryImp[T] {
	imp := &RepositoryImp[T]{
		t:        t,
		callChan: make(chan *RepositoryImpCall[T], 1),
	}
	imp.Mock = &RepositoryImpMock[T]{imp: imp}
	imp.ExpectCallIs = &RepositoryImpExpectCallIs[T]{imp: imp}
	return imp
}
