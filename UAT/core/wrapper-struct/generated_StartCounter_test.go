// Code generated by impgen. DO NOT EDIT.
// impgen:hash:44d7ef7a265b37d7

package calculator_test

import (
	_imptest "github.com/toejough/imptest"
	calculator "github.com/toejough/imptest/UAT/core/wrapper-struct"
	_reflect "reflect"
	"testing"
)

// StartCounterWrapperAddAmountCallHandle represents a single call to the wrapped method.
type StartCounterWrapperAddAmountCallHandle struct {
	*_imptest.CallableController[StartCounterWrapperAddAmountReturns]
}

// ExpectCompletes verifies the method completes without panicking.
func (h *StartCounterWrapperAddAmountCallHandle) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

// ExpectPanic verifies the method panics with the expected value.
func (h *StartCounterWrapperAddAmountCallHandle) ExpectPanic(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectPanicMatch verifies the method panics with a value matching the given matcher.
func (h *StartCounterWrapperAddAmountCallHandle) ExpectPanicMatch(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectReturn verifies the method returned the expected values.
func (h *StartCounterWrapperAddAmountCallHandle) ExpectReturn(v0 int) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		if !_reflect.DeepEqual(h.Returned.Result0, v0) {
			h.T.Fatalf("expected return value 0 to be %v, got %v", v0, h.Returned.Result0)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnMatch verifies the return values match the given matchers.
func (h *StartCounterWrapperAddAmountCallHandle) ExpectReturnMatch(v0 any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		ok, msg = _imptest.MatchValue(h.Returned.Result0, v0)
		if !ok {
			h.T.Fatalf("return value 0: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

type StartCounterWrapperAddAmountReturns struct {
	Result0 int
}

type StartCounterWrapperAddAmountWrapper struct {
	t  *testing.T
	fn func(amount int) StartCounterWrapperAddAmountReturns
}

// Start executes the wrapped method in a goroutine.
func (w *StartCounterWrapperAddAmountWrapper) Start(amount int) *StartCounterWrapperAddAmountCallHandle {
	handle := &StartCounterWrapperAddAmountCallHandle{
		CallableController: _imptest.NewCallableController[StartCounterWrapperAddAmountReturns](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn(amount)
		handle.ReturnChan <- returns
	}()
	return handle
}

// StartCounterWrapperGetValueCallHandle represents a single call to the wrapped method.
type StartCounterWrapperGetValueCallHandle struct {
	*_imptest.CallableController[StartCounterWrapperGetValueReturns]
}

// ExpectCompletes verifies the method completes without panicking.
func (h *StartCounterWrapperGetValueCallHandle) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

// ExpectPanic verifies the method panics with the expected value.
func (h *StartCounterWrapperGetValueCallHandle) ExpectPanic(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectPanicMatch verifies the method panics with a value matching the given matcher.
func (h *StartCounterWrapperGetValueCallHandle) ExpectPanicMatch(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectReturn verifies the method returned the expected values.
func (h *StartCounterWrapperGetValueCallHandle) ExpectReturn(v0 int) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		if !_reflect.DeepEqual(h.Returned.Result0, v0) {
			h.T.Fatalf("expected return value 0 to be %v, got %v", v0, h.Returned.Result0)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnMatch verifies the return values match the given matchers.
func (h *StartCounterWrapperGetValueCallHandle) ExpectReturnMatch(v0 any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		ok, msg = _imptest.MatchValue(h.Returned.Result0, v0)
		if !ok {
			h.T.Fatalf("return value 0: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

type StartCounterWrapperGetValueReturns struct {
	Result0 int
}

type StartCounterWrapperGetValueWrapper struct {
	t  *testing.T
	fn func() StartCounterWrapperGetValueReturns
}

// Start executes the wrapped method in a goroutine.
func (w *StartCounterWrapperGetValueWrapper) Start() *StartCounterWrapperGetValueCallHandle {
	handle := &StartCounterWrapperGetValueCallHandle{
		CallableController: _imptest.NewCallableController[StartCounterWrapperGetValueReturns](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn()
		handle.ReturnChan <- returns
	}()
	return handle
}

// StartCounterWrapperHandle wraps an implementation of calculator.Counter to intercept method calls.
type StartCounterWrapperHandle struct {
	AddAmount *StartCounterWrapperAddAmountWrapper
	GetValue  *StartCounterWrapperGetValueWrapper
	Increment *StartCounterWrapperIncrementWrapper
	impl      *calculator.Counter
}

// StartCounterWrapperIncrementCallHandle represents a single call to the wrapped method.
type StartCounterWrapperIncrementCallHandle struct {
	*_imptest.CallableController[StartCounterWrapperIncrementReturns]
}

// ExpectCompletes verifies the method completes without panicking.
func (h *StartCounterWrapperIncrementCallHandle) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

// ExpectPanic verifies the method panics with the expected value.
func (h *StartCounterWrapperIncrementCallHandle) ExpectPanic(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectPanicMatch verifies the method panics with a value matching the given matcher.
func (h *StartCounterWrapperIncrementCallHandle) ExpectPanicMatch(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectReturn verifies the method returned the expected values.
func (h *StartCounterWrapperIncrementCallHandle) ExpectReturn(v0 int) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		if !_reflect.DeepEqual(h.Returned.Result0, v0) {
			h.T.Fatalf("expected return value 0 to be %v, got %v", v0, h.Returned.Result0)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnMatch verifies the return values match the given matchers.
func (h *StartCounterWrapperIncrementCallHandle) ExpectReturnMatch(v0 any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		ok, msg = _imptest.MatchValue(h.Returned.Result0, v0)
		if !ok {
			h.T.Fatalf("return value 0: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

type StartCounterWrapperIncrementReturns struct {
	Result0 int
}

type StartCounterWrapperIncrementWrapper struct {
	t  *testing.T
	fn func() StartCounterWrapperIncrementReturns
}

// Start executes the wrapped method in a goroutine.
func (w *StartCounterWrapperIncrementWrapper) Start() *StartCounterWrapperIncrementCallHandle {
	handle := &StartCounterWrapperIncrementCallHandle{
		CallableController: _imptest.NewCallableController[StartCounterWrapperIncrementReturns](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn()
		handle.ReturnChan <- returns
	}()
	return handle
}

// StartCounter creates a new wrapper for the given calculator.Counter implementation.
func StartCounter(t *testing.T, impl *calculator.Counter) *StartCounterWrapperHandle {
	h := &StartCounterWrapperHandle{
		impl: impl,
	}
	h.AddAmount = wrapStartCounterWrapperAddAmount(t, func(amount int) StartCounterWrapperAddAmountReturns {
		r0 := h.impl.AddAmount(amount)
		return StartCounterWrapperAddAmountReturns{Result0: r0}
	})
	h.GetValue = wrapStartCounterWrapperGetValue(t, func() StartCounterWrapperGetValueReturns {
		r0 := h.impl.GetValue()
		return StartCounterWrapperGetValueReturns{Result0: r0}
	})
	h.Increment = wrapStartCounterWrapperIncrement(t, func() StartCounterWrapperIncrementReturns {
		r0 := h.impl.Increment()
		return StartCounterWrapperIncrementReturns{Result0: r0}
	})
	return h
}

func wrapStartCounterWrapperAddAmount(t *testing.T, fn func(amount int) StartCounterWrapperAddAmountReturns) *StartCounterWrapperAddAmountWrapper {
	return &StartCounterWrapperAddAmountWrapper{t: t, fn: fn}
}

func wrapStartCounterWrapperGetValue(t *testing.T, fn func() StartCounterWrapperGetValueReturns) *StartCounterWrapperGetValueWrapper {
	return &StartCounterWrapperGetValueWrapper{t: t, fn: fn}
}

func wrapStartCounterWrapperIncrement(t *testing.T, fn func() StartCounterWrapperIncrementReturns) *StartCounterWrapperIncrementWrapper {
	return &StartCounterWrapperIncrementWrapper{t: t, fn: fn}
}
