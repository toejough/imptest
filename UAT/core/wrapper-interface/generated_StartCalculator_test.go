// Code generated by impgen. DO NOT EDIT.
// impgen:hash:804f1dea0369e2a8

package handlers_test

import (
	_imptest "github.com/toejough/imptest"
	handlers "github.com/toejough/imptest/UAT/core/wrapper-interface"
	_reflect "reflect"
	"testing"
)

// StartCalculatorWrapperAddCallHandle represents a single call to the wrapped method.
type StartCalculatorWrapperAddCallHandle struct {
	*_imptest.CallableController[StartCalculatorWrapperAddReturns]
}

// ExpectCompletes verifies the method completes without panicking.
func (h *StartCalculatorWrapperAddCallHandle) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

// ExpectPanic verifies the method panics with the expected value.
func (h *StartCalculatorWrapperAddCallHandle) ExpectPanic(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectPanicMatch verifies the method panics with a value matching the given matcher.
func (h *StartCalculatorWrapperAddCallHandle) ExpectPanicMatch(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectReturn verifies the method returned the expected values.
func (h *StartCalculatorWrapperAddCallHandle) ExpectReturn(v0 int) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		if !_reflect.DeepEqual(h.Returned.Result0, v0) {
			h.T.Fatalf("expected return value 0 to be %v, got %v", v0, h.Returned.Result0)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnMatch verifies the return values match the given matchers.
func (h *StartCalculatorWrapperAddCallHandle) ExpectReturnMatch(v0 any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		ok, msg = _imptest.MatchValue(h.Returned.Result0, v0)
		if !ok {
			h.T.Fatalf("return value 0: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

type StartCalculatorWrapperAddReturns struct {
	Result0 int
}

type StartCalculatorWrapperAddWrapper struct {
	t  *testing.T
	fn func(a int, b int) StartCalculatorWrapperAddReturns
}

// Start executes the wrapped method in a goroutine.
func (w *StartCalculatorWrapperAddWrapper) Start(a int, b int) *StartCalculatorWrapperAddCallHandle {
	handle := &StartCalculatorWrapperAddCallHandle{
		CallableController: _imptest.NewCallableController[StartCalculatorWrapperAddReturns](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn(a, b)
		handle.ReturnChan <- returns
	}()
	return handle
}

// StartCalculatorWrapperDivideCallHandle represents a single call to the wrapped method.
type StartCalculatorWrapperDivideCallHandle struct {
	*_imptest.CallableController[StartCalculatorWrapperDivideReturns]
}

// ExpectCompletes verifies the method completes without panicking.
func (h *StartCalculatorWrapperDivideCallHandle) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

// ExpectPanic verifies the method panics with the expected value.
func (h *StartCalculatorWrapperDivideCallHandle) ExpectPanic(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectPanicMatch verifies the method panics with a value matching the given matcher.
func (h *StartCalculatorWrapperDivideCallHandle) ExpectPanicMatch(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectReturn verifies the method returned the expected values.
func (h *StartCalculatorWrapperDivideCallHandle) ExpectReturn(v0 int, v1 bool) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		if !_reflect.DeepEqual(h.Returned.Result0, v0) {
			h.T.Fatalf("expected return value 0 to be %v, got %v", v0, h.Returned.Result0)
		}
		if !_reflect.DeepEqual(h.Returned.Result1, v1) {
			h.T.Fatalf("expected return value 1 to be %v, got %v", v1, h.Returned.Result1)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnMatch verifies the return values match the given matchers.
func (h *StartCalculatorWrapperDivideCallHandle) ExpectReturnMatch(v0 any, v1 any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		ok, msg = _imptest.MatchValue(h.Returned.Result0, v0)
		if !ok {
			h.T.Fatalf("return value 0: %s", msg)
		}
		ok, msg = _imptest.MatchValue(h.Returned.Result1, v1)
		if !ok {
			h.T.Fatalf("return value 1: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

type StartCalculatorWrapperDivideReturns struct {
	Result0 int
	Result1 bool
}

type StartCalculatorWrapperDivideWrapper struct {
	t  *testing.T
	fn func(numerator int, denominator int) StartCalculatorWrapperDivideReturns
}

// Start executes the wrapped method in a goroutine.
func (w *StartCalculatorWrapperDivideWrapper) Start(numerator int, denominator int) *StartCalculatorWrapperDivideCallHandle {
	handle := &StartCalculatorWrapperDivideCallHandle{
		CallableController: _imptest.NewCallableController[StartCalculatorWrapperDivideReturns](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn(numerator, denominator)
		handle.ReturnChan <- returns
	}()
	return handle
}

// StartCalculatorWrapperHandle wraps an implementation of handlers.Calculator to intercept method calls.
type StartCalculatorWrapperHandle struct {
	Add          *StartCalculatorWrapperAddWrapper
	Divide       *StartCalculatorWrapperDivideWrapper
	Multiply     *StartCalculatorWrapperMultiplyWrapper
	ProcessValue *StartCalculatorWrapperProcessValueWrapper
	impl         handlers.Calculator
}

// StartCalculatorWrapperMultiplyCallHandle represents a single call to the wrapped method.
type StartCalculatorWrapperMultiplyCallHandle struct {
	*_imptest.CallableController[StartCalculatorWrapperMultiplyReturns]
}

// ExpectCompletes verifies the method completes without panicking.
func (h *StartCalculatorWrapperMultiplyCallHandle) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

// ExpectPanic verifies the method panics with the expected value.
func (h *StartCalculatorWrapperMultiplyCallHandle) ExpectPanic(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectPanicMatch verifies the method panics with a value matching the given matcher.
func (h *StartCalculatorWrapperMultiplyCallHandle) ExpectPanicMatch(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectReturn verifies the method returned the expected values.
func (h *StartCalculatorWrapperMultiplyCallHandle) ExpectReturn(v0 int) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		if !_reflect.DeepEqual(h.Returned.Result0, v0) {
			h.T.Fatalf("expected return value 0 to be %v, got %v", v0, h.Returned.Result0)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnMatch verifies the return values match the given matchers.
func (h *StartCalculatorWrapperMultiplyCallHandle) ExpectReturnMatch(v0 any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		ok, msg = _imptest.MatchValue(h.Returned.Result0, v0)
		if !ok {
			h.T.Fatalf("return value 0: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

type StartCalculatorWrapperMultiplyReturns struct {
	Result0 int
}

type StartCalculatorWrapperMultiplyWrapper struct {
	t  *testing.T
	fn func(value int) StartCalculatorWrapperMultiplyReturns
}

// Start executes the wrapped method in a goroutine.
func (w *StartCalculatorWrapperMultiplyWrapper) Start(value int) *StartCalculatorWrapperMultiplyCallHandle {
	handle := &StartCalculatorWrapperMultiplyCallHandle{
		CallableController: _imptest.NewCallableController[StartCalculatorWrapperMultiplyReturns](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn(value)
		handle.ReturnChan <- returns
	}()
	return handle
}

// StartCalculatorWrapperProcessValueCallHandle represents a single call to the wrapped method.
type StartCalculatorWrapperProcessValueCallHandle struct {
	*_imptest.CallableController[StartCalculatorWrapperProcessValueReturns]
}

// ExpectCompletes verifies the method completes without panicking.
func (h *StartCalculatorWrapperProcessValueCallHandle) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

// ExpectPanic verifies the method panics with the expected value.
func (h *StartCalculatorWrapperProcessValueCallHandle) ExpectPanic(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectPanicMatch verifies the method panics with a value matching the given matcher.
func (h *StartCalculatorWrapperProcessValueCallHandle) ExpectPanicMatch(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectReturn verifies the method returned the expected values.
func (h *StartCalculatorWrapperProcessValueCallHandle) ExpectReturn(v0 int) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		if !_reflect.DeepEqual(h.Returned.Result0, v0) {
			h.T.Fatalf("expected return value 0 to be %v, got %v", v0, h.Returned.Result0)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnMatch verifies the return values match the given matchers.
func (h *StartCalculatorWrapperProcessValueCallHandle) ExpectReturnMatch(v0 any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		ok, msg = _imptest.MatchValue(h.Returned.Result0, v0)
		if !ok {
			h.T.Fatalf("return value 0: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

type StartCalculatorWrapperProcessValueReturns struct {
	Result0 int
}

type StartCalculatorWrapperProcessValueWrapper struct {
	t  *testing.T
	fn func(value int) StartCalculatorWrapperProcessValueReturns
}

// Start executes the wrapped method in a goroutine.
func (w *StartCalculatorWrapperProcessValueWrapper) Start(value int) *StartCalculatorWrapperProcessValueCallHandle {
	handle := &StartCalculatorWrapperProcessValueCallHandle{
		CallableController: _imptest.NewCallableController[StartCalculatorWrapperProcessValueReturns](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn(value)
		handle.ReturnChan <- returns
	}()
	return handle
}

// StartCalculator creates a new wrapper for the given handlers.Calculator implementation.
func StartCalculator(t *testing.T, impl handlers.Calculator) *StartCalculatorWrapperHandle {
	h := &StartCalculatorWrapperHandle{
		impl: impl,
	}
	h.Add = wrapStartCalculatorWrapperAdd(t, func(a int, b int) StartCalculatorWrapperAddReturns {
		r0 := h.impl.Add(a, b)
		return StartCalculatorWrapperAddReturns{Result0: r0}
	})
	h.Divide = wrapStartCalculatorWrapperDivide(t, func(numerator int, denominator int) StartCalculatorWrapperDivideReturns {
		r0, r1 := h.impl.Divide(numerator, denominator)
		return StartCalculatorWrapperDivideReturns{Result0: r0, Result1: r1}
	})
	h.Multiply = wrapStartCalculatorWrapperMultiply(t, func(value int) StartCalculatorWrapperMultiplyReturns {
		r0 := h.impl.Multiply(value)
		return StartCalculatorWrapperMultiplyReturns{Result0: r0}
	})
	h.ProcessValue = wrapStartCalculatorWrapperProcessValue(t, func(value int) StartCalculatorWrapperProcessValueReturns {
		r0 := h.impl.ProcessValue(value)
		return StartCalculatorWrapperProcessValueReturns{Result0: r0}
	})
	return h
}

func wrapStartCalculatorWrapperAdd(t *testing.T, fn func(a int, b int) StartCalculatorWrapperAddReturns) *StartCalculatorWrapperAddWrapper {
	return &StartCalculatorWrapperAddWrapper{t: t, fn: fn}
}

func wrapStartCalculatorWrapperDivide(t *testing.T, fn func(numerator int, denominator int) StartCalculatorWrapperDivideReturns) *StartCalculatorWrapperDivideWrapper {
	return &StartCalculatorWrapperDivideWrapper{t: t, fn: fn}
}

func wrapStartCalculatorWrapperMultiply(t *testing.T, fn func(value int) StartCalculatorWrapperMultiplyReturns) *StartCalculatorWrapperMultiplyWrapper {
	return &StartCalculatorWrapperMultiplyWrapper{t: t, fn: fn}
}

func wrapStartCalculatorWrapperProcessValue(t *testing.T, fn func(value int) StartCalculatorWrapperProcessValueReturns) *StartCalculatorWrapperProcessValueWrapper {
	return &StartCalculatorWrapperProcessValueWrapper{t: t, fn: fn}
}
