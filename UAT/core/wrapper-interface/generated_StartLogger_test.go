// Code generated by impgen. DO NOT EDIT.
// impgen:hash:919a3b79555940ac

package handlers_test

import (
	context "context"
	_imptest "github.com/toejough/imptest"
	handlers "github.com/toejough/imptest/UAT/core/wrapper-interface"
	_reflect "reflect"
	"testing"
)

type StartLoggerWrapperHandle struct {
	Log            *StartLoggerWrapperLogWrapper
	LogWithContext *StartLoggerWrapperLogWithContextWrapper
	impl           handlers.Logger
}

type StartLoggerWrapperLogCallHandle struct {
	*_imptest.CallableController[StartLoggerWrapperLogReturns]
}

// Completes verifies the method completes without panicking.
func (h *StartLoggerWrapperLogCallHandle) Completes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

// PanicEquals verifies the method panics with the expected value.
func (h *StartLoggerWrapperLogCallHandle) PanicEquals(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// PanicShould verifies the method panics with a value matching the given matcher.
func (h *StartLoggerWrapperLogCallHandle) PanicShould(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ReturnsEqual verifies the method returned the expected values.
func (h *StartLoggerWrapperLogCallHandle) ReturnsEqual(v0 error) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		if !_reflect.DeepEqual(h.Returned.Result0, v0) {
			h.T.Fatalf("expected return value 0 to be %v, got %v", v0, h.Returned.Result0)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ReturnsShould verifies the return values match the given matchers.
func (h *StartLoggerWrapperLogCallHandle) ReturnsShould(v0 any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		ok, msg = _imptest.MatchValue(h.Returned.Result0, v0)
		if !ok {
			h.T.Fatalf("return value 0: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

type StartLoggerWrapperLogReturns struct {
	Result0 error
}

type StartLoggerWrapperLogWithContextCallHandle struct {
	*_imptest.CallableController[StartLoggerWrapperLogWithContextReturns]
}

// Completes verifies the method completes without panicking.
func (h *StartLoggerWrapperLogWithContextCallHandle) Completes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

// PanicEquals verifies the method panics with the expected value.
func (h *StartLoggerWrapperLogWithContextCallHandle) PanicEquals(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// PanicShould verifies the method panics with a value matching the given matcher.
func (h *StartLoggerWrapperLogWithContextCallHandle) PanicShould(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := _imptest.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ReturnsEqual verifies the method returned the expected values.
func (h *StartLoggerWrapperLogWithContextCallHandle) ReturnsEqual(v0 error) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		if !_reflect.DeepEqual(h.Returned.Result0, v0) {
			h.T.Fatalf("expected return value 0 to be %v, got %v", v0, h.Returned.Result0)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ReturnsShould verifies the return values match the given matchers.
func (h *StartLoggerWrapperLogWithContextCallHandle) ReturnsShould(v0 any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		ok, msg = _imptest.MatchValue(h.Returned.Result0, v0)
		if !ok {
			h.T.Fatalf("return value 0: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

type StartLoggerWrapperLogWithContextReturns struct {
	Result0 error
}

type StartLoggerWrapperLogWithContextWrapper struct {
	t  *testing.T
	fn func(ctx context.Context, msg string) StartLoggerWrapperLogWithContextReturns
}

// Start executes the wrapped method in a goroutine.
func (w *StartLoggerWrapperLogWithContextWrapper) Start(ctx context.Context, msg string) *StartLoggerWrapperLogWithContextCallHandle {
	handle := &StartLoggerWrapperLogWithContextCallHandle{
		CallableController: _imptest.NewCallableController[StartLoggerWrapperLogWithContextReturns](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn(ctx, msg)
		handle.ReturnChan <- returns
	}()
	return handle
}

type StartLoggerWrapperLogWrapper struct {
	t  *testing.T
	fn func(msg string) StartLoggerWrapperLogReturns
}

// Start executes the wrapped method in a goroutine.
func (w *StartLoggerWrapperLogWrapper) Start(msg string) *StartLoggerWrapperLogCallHandle {
	handle := &StartLoggerWrapperLogCallHandle{
		CallableController: _imptest.NewCallableController[StartLoggerWrapperLogReturns](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn(msg)
		handle.ReturnChan <- returns
	}()
	return handle
}

// StartLogger creates a new wrapper for the given handlers.Logger implementation.
func StartLogger(t *testing.T, impl handlers.Logger) *StartLoggerWrapperHandle {
	h := &StartLoggerWrapperHandle{
		impl: impl,
	}
	h.Log = wrapStartLoggerWrapperLog(t, func(msg string) StartLoggerWrapperLogReturns {
		r0 := h.impl.Log(msg)
		return StartLoggerWrapperLogReturns{Result0: r0}
	})
	h.LogWithContext = wrapStartLoggerWrapperLogWithContext(t, func(ctx context.Context, msg string) StartLoggerWrapperLogWithContextReturns {
		r0 := h.impl.LogWithContext(ctx, msg)
		return StartLoggerWrapperLogWithContextReturns{Result0: r0}
	})
	return h
}

func wrapStartLoggerWrapperLog(t *testing.T, fn func(msg string) StartLoggerWrapperLogReturns) *StartLoggerWrapperLogWrapper {
	return &StartLoggerWrapperLogWrapper{t: t, fn: fn}
}

func wrapStartLoggerWrapperLogWithContext(t *testing.T, fn func(ctx context.Context, msg string) StartLoggerWrapperLogWithContextReturns) *StartLoggerWrapperLogWithContextWrapper {
	return &StartLoggerWrapperLogWithContextWrapper{t: t, fn: fn}
}
