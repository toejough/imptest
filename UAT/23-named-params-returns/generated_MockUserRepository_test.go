// Code generated by impgen. DO NOT EDIT.

package named_test

import (
	context "context"
	named "github.com/toejough/imptest/UAT/23-named-params-returns"
	_imptest "github.com/toejough/imptest/imptest"
)

// UserRepositoryMock is the mock for UserRepository.
type UserRepositoryMock struct {
	imp        *_imptest.Imp
	GetUser    *UserRepositoryMockGetUserMethod
	SaveUser   *UserRepositoryMockSaveUserMethod
	DeleteUser *UserRepositoryMockDeleteUserMethod
	CountUsers *UserRepositoryMockCountUsersMethod
}

// Interface returns the UserRepository implementation that can be passed to code under test.
func (m *UserRepositoryMock) Interface() named.UserRepository {
	return &mockUserRepositoryImpl{mock: m}
}

// UserRepositoryMockCountUsersArgs holds typed arguments for CountUsers.
type UserRepositoryMockCountUsersArgs struct {
	Ctx context.Context
}

// UserRepositoryMockCountUsersCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type UserRepositoryMockCountUsersCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *UserRepositoryMockCountUsersCall) GetArgs() UserRepositoryMockCountUsersArgs {
	raw := c.RawArgs()
	return UserRepositoryMockCountUsersArgs{
		Ctx: raw[0].(context.Context),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *UserRepositoryMockCountUsersCall) InjectReturnValues(result0 int, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// UserRepositoryMockCountUsersMethod wraps DependencyMethod with typed returns.
type UserRepositoryMockCountUsersMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *UserRepositoryMockCountUsersMethod) Eventually() *UserRepositoryMockCountUsersMethod {
	return &UserRepositoryMockCountUsersMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *UserRepositoryMockCountUsersMethod) ExpectCalledWithExactly(ctx context.Context) *UserRepositoryMockCountUsersCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(ctx)
	return &UserRepositoryMockCountUsersCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *UserRepositoryMockCountUsersMethod) ExpectCalledWithMatches(matchers ...any) *UserRepositoryMockCountUsersCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &UserRepositoryMockCountUsersCall{DependencyCall: call}
}

// UserRepositoryMockDeleteUserArgs holds typed arguments for DeleteUser.
type UserRepositoryMockDeleteUserArgs struct {
	Ctx    context.Context
	UserID int
}

// UserRepositoryMockDeleteUserCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type UserRepositoryMockDeleteUserCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *UserRepositoryMockDeleteUserCall) GetArgs() UserRepositoryMockDeleteUserArgs {
	raw := c.RawArgs()
	return UserRepositoryMockDeleteUserArgs{
		Ctx:    raw[0].(context.Context),
		UserID: raw[1].(int),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *UserRepositoryMockDeleteUserCall) InjectReturnValues(result0 error) {
	c.DependencyCall.InjectReturnValues(result0)
}

// UserRepositoryMockDeleteUserMethod wraps DependencyMethod with typed returns.
type UserRepositoryMockDeleteUserMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *UserRepositoryMockDeleteUserMethod) Eventually() *UserRepositoryMockDeleteUserMethod {
	return &UserRepositoryMockDeleteUserMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *UserRepositoryMockDeleteUserMethod) ExpectCalledWithExactly(ctx context.Context, userID int) *UserRepositoryMockDeleteUserCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(ctx, userID)
	return &UserRepositoryMockDeleteUserCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *UserRepositoryMockDeleteUserMethod) ExpectCalledWithMatches(matchers ...any) *UserRepositoryMockDeleteUserCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &UserRepositoryMockDeleteUserCall{DependencyCall: call}
}

// UserRepositoryMockGetUserArgs holds typed arguments for GetUser.
type UserRepositoryMockGetUserArgs struct {
	Ctx    context.Context
	UserID int
}

// UserRepositoryMockGetUserCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type UserRepositoryMockGetUserCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *UserRepositoryMockGetUserCall) GetArgs() UserRepositoryMockGetUserArgs {
	raw := c.RawArgs()
	return UserRepositoryMockGetUserArgs{
		Ctx:    raw[0].(context.Context),
		UserID: raw[1].(int),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *UserRepositoryMockGetUserCall) InjectReturnValues(result0 named.User, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// UserRepositoryMockGetUserMethod wraps DependencyMethod with typed returns.
type UserRepositoryMockGetUserMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *UserRepositoryMockGetUserMethod) Eventually() *UserRepositoryMockGetUserMethod {
	return &UserRepositoryMockGetUserMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *UserRepositoryMockGetUserMethod) ExpectCalledWithExactly(ctx context.Context, userID int) *UserRepositoryMockGetUserCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(ctx, userID)
	return &UserRepositoryMockGetUserCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *UserRepositoryMockGetUserMethod) ExpectCalledWithMatches(matchers ...any) *UserRepositoryMockGetUserCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &UserRepositoryMockGetUserCall{DependencyCall: call}
}

// UserRepositoryMockSaveUserArgs holds typed arguments for SaveUser.
type UserRepositoryMockSaveUserArgs struct {
	Ctx  context.Context
	User named.User
}

// UserRepositoryMockSaveUserCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type UserRepositoryMockSaveUserCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *UserRepositoryMockSaveUserCall) GetArgs() UserRepositoryMockSaveUserArgs {
	raw := c.RawArgs()
	return UserRepositoryMockSaveUserArgs{
		Ctx:  raw[0].(context.Context),
		User: raw[1].(named.User),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *UserRepositoryMockSaveUserCall) InjectReturnValues(result0 named.User, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// UserRepositoryMockSaveUserMethod wraps DependencyMethod with typed returns.
type UserRepositoryMockSaveUserMethod struct {
	*_imptest.DependencyMethod
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *UserRepositoryMockSaveUserMethod) Eventually() *UserRepositoryMockSaveUserMethod {
	return &UserRepositoryMockSaveUserMethod{DependencyMethod: m.DependencyMethod.Eventually()}
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *UserRepositoryMockSaveUserMethod) ExpectCalledWithExactly(ctx context.Context, user named.User) *UserRepositoryMockSaveUserCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(ctx, user)
	return &UserRepositoryMockSaveUserCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *UserRepositoryMockSaveUserMethod) ExpectCalledWithMatches(matchers ...any) *UserRepositoryMockSaveUserCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &UserRepositoryMockSaveUserCall{DependencyCall: call}
}

// MockUserRepository creates a new UserRepositoryMock for testing.
func MockUserRepository(t _imptest.TestReporter) *UserRepositoryMock {
	imp := _imptest.NewImp(t)
	return &UserRepositoryMock{
		imp:        imp,
		GetUser:    &UserRepositoryMockGetUserMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "GetUser")},
		SaveUser:   &UserRepositoryMockSaveUserMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "SaveUser")},
		DeleteUser: &UserRepositoryMockDeleteUserMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "DeleteUser")},
		CountUsers: &UserRepositoryMockCountUsersMethod{DependencyMethod: _imptest.NewDependencyMethod(imp, "CountUsers")},
	}
}

// mockUserRepositoryImpl implements named.UserRepository.
type mockUserRepositoryImpl struct {
	mock *UserRepositoryMock
}

// CountUsers implements named.UserRepository.CountUsers.
func (impl *mockUserRepositoryImpl) CountUsers(ctx context.Context) (int, error) {
	call := &_imptest.GenericCall{
		MethodName:   "CountUsers",
		Args:         []any{ctx},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 int
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(int); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// DeleteUser implements named.UserRepository.DeleteUser.
func (impl *mockUserRepositoryImpl) DeleteUser(ctx context.Context, userID int) error {
	call := &_imptest.GenericCall{
		MethodName:   "DeleteUser",
		Args:         []any{ctx, userID},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}

// GetUser implements named.UserRepository.GetUser.
func (impl *mockUserRepositoryImpl) GetUser(ctx context.Context, userID int) (named.User, error) {
	call := &_imptest.GenericCall{
		MethodName:   "GetUser",
		Args:         []any{ctx, userID},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 named.User
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(named.User); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// SaveUser implements named.UserRepository.SaveUser.
func (impl *mockUserRepositoryImpl) SaveUser(ctx context.Context, user named.User) (named.User, error) {
	call := &_imptest.GenericCall{
		MethodName:   "SaveUser",
		Args:         []any{ctx, user},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 named.User
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(named.User); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}
