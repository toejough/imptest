// Code generated by impgen. DO NOT EDIT.

package samepackage_test

import _imptest "github.com/toejough/imptest/imptest"
import _reflect "reflect"
import _testing "testing"
import _time "time"
import samepackage "github.com/toejough/imptest/UAT/14-same-package-interfaces"

// DataProcessorImp is the test controller for mocking the interface.
// Create with NewDataProcessorImp(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := NewDataProcessorImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type DataProcessorImp struct {
	*_imptest.Controller[*DataProcessorImpCall]
	Mock         *DataProcessorImpMock
	ExpectCallIs *DataProcessorImpExpectCallIs
	currentCall  *DataProcessorImpCall
}

// NewDataProcessorImp creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := NewDataProcessorImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func NewDataProcessorImp(t *_testing.T) *DataProcessorImp {
	imp := &DataProcessorImp{
		Controller: _imptest.NewController[*DataProcessorImpCall](t),
	}
	imp.Mock = &DataProcessorImpMock{imp: imp}
	imp.ExpectCallIs = &DataProcessorImpExpectCallIs{imp: imp}
	return imp
}

// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *DataProcessorImp) GetCurrentCall() *DataProcessorImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *DataProcessorImpCall) bool { return true })
	return i.currentCall
}

// Within configures a timeout for expectations and returns a DataProcessorImpTimed for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*_time.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *DataProcessorImp) Within(d _time.Duration) *DataProcessorImpTimed {
	return &DataProcessorImpTimed{
		ExpectCallIs: &DataProcessorImpExpectCallIs{imp: i, timeout: d},
	}
}

// DataProcessorImpCall represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{Method}() to access typed call details.
type DataProcessorImpCall struct {
	process   *DataProcessorImpProcessCall
	transform *DataProcessorImpTransformCall
	validate  *DataProcessorImpValidateCall
}

// AsProcess returns the call cast to DataProcessorImpProcessCall for accessing call details.
// Returns nil if the call was not to Process.
func (c *DataProcessorImpCall) AsProcess() *DataProcessorImpProcessCall {
	return c.process
}

// AsTransform returns the call cast to DataProcessorImpTransformCall for accessing call details.
// Returns nil if the call was not to Transform.
func (c *DataProcessorImpCall) AsTransform() *DataProcessorImpTransformCall {
	return c.transform
}

// AsValidate returns the call cast to DataProcessorImpValidateCall for accessing call details.
// Returns nil if the call was not to Validate.
func (c *DataProcessorImpCall) AsValidate() *DataProcessorImpValidateCall {
	return c.validate
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *DataProcessorImpCall) Done() bool {
	if c.process != nil {
		return c.process.done
	}
	if c.transform != nil {
		return c.transform.done
	}
	if c.validate != nil {
		return c.validate.done
	}
	return false
}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *DataProcessorImpCall) Name() string {
	if c.process != nil {
		return "Process"
	}
	if c.transform != nil {
		return "Transform"
	}
	if c.validate != nil {
		return "Validate"
	}
	return ""
}

// DataProcessorImpExpectCallIs provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent DataProcessorImp to configure timeouts.
type DataProcessorImpExpectCallIs struct {
	imp     *DataProcessorImp
	timeout _time.Duration
}

// Process returns a builder for setting expectations on Process method calls.
func (e *DataProcessorImpExpectCallIs) Process() *DataProcessorImpProcessBuilder {
	return &DataProcessorImpProcessBuilder{imp: e.imp, timeout: e.timeout}
}

// Transform returns a builder for setting expectations on Transform method calls.
func (e *DataProcessorImpExpectCallIs) Transform() *DataProcessorImpTransformBuilder {
	return &DataProcessorImpTransformBuilder{imp: e.imp, timeout: e.timeout}
}

// Validate returns a builder for setting expectations on Validate method calls.
func (e *DataProcessorImpExpectCallIs) Validate() *DataProcessorImpValidateBuilder {
	return &DataProcessorImpValidateBuilder{imp: e.imp, timeout: e.timeout}
}

// DataProcessorImpMock provides the mock implementation of the interface.
// Pass DataProcessorImpMock to code under test that expects the interface implementation.
// Use the parent DataProcessorImp controller to set expectations and inject responses.
type DataProcessorImpMock struct {
	imp *DataProcessorImp
}

// Process implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *DataProcessorImpMock) Process(source samepackage.DataSource, sink samepackage.DataSink) error {
	responseChan := make(chan DataProcessorImpProcessCallResponse, 1)

	call := &DataProcessorImpProcessCall{
		responseChan: responseChan,
		source:       source,
		sink:         sink,
	}

	callEvent := &DataProcessorImpCall{
		process: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// Transform implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *DataProcessorImpMock) Transform(input samepackage.DataSource) (samepackage.DataSource, error) {
	responseChan := make(chan DataProcessorImpTransformCallResponse, 1)

	call := &DataProcessorImpTransformCall{
		responseChan: responseChan,
		input:        input,
	}

	callEvent := &DataProcessorImpCall{
		transform: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// Validate implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *DataProcessorImpMock) Validate(sink samepackage.DataSink) bool {
	responseChan := make(chan DataProcessorImpValidateCallResponse, 1)

	call := &DataProcessorImpValidateCall{
		responseChan: responseChan,
		sink:         sink,
	}

	callEvent := &DataProcessorImpCall{
		validate: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// DataProcessorImpProcessBuilder provides a fluent API for setting expectations on Process calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type DataProcessorImpProcessBuilder struct {
	imp     *DataProcessorImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Process call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *DataProcessorImpProcessBuilder) ExpectArgsAre(source samepackage.DataSource, sink samepackage.DataSink) *DataProcessorImpProcessCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		if callToCheck.Name() != "Process" {
			return false
		}
		methodCall := callToCheck.AsProcess()
		if !_reflect.DeepEqual(methodCall.source, source) {
			return false
		}
		if !_reflect.DeepEqual(methodCall.sink, sink) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsProcess()
}

// ExpectArgsShould waits for a Process call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *DataProcessorImpProcessBuilder) ExpectArgsShould(source any, sink any) *DataProcessorImpProcessCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		if callToCheck.Name() != "Process" {
			return false
		}
		methodCall := callToCheck.AsProcess()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.source, source)
		if !ok {
			return false
		}
		ok, _ = _imptest.MatchValue(methodCall.sink, sink)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsProcess()
}

// InjectPanic waits for a Process call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *DataProcessorImpProcessBuilder) InjectPanic(msg any) *DataProcessorImpProcessCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		return callToCheck.Name() == "Process"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsProcess()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Process call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *DataProcessorImpProcessBuilder) InjectResult(result error) *DataProcessorImpProcessCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		return callToCheck.Name() == "Process"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsProcess()
	methodCall.InjectResult(result)
	return methodCall
}

// DataProcessorImpProcessCall represents a captured call to the Process method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type DataProcessorImpProcessCall struct {
	responseChan chan DataProcessorImpProcessCallResponse
	done         bool
	source       samepackage.DataSource
	sink         samepackage.DataSink
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *DataProcessorImpProcessCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- DataProcessorImpProcessCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *DataProcessorImpProcessCall) InjectResult(result error) {
	c.done = true
	c.responseChan <- DataProcessorImpProcessCallResponse{Type: "return", Result0: result}
}

// DataProcessorImpProcessCallResponse holds the response configuration for the Process method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type DataProcessorImpProcessCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    error
	PanicValue any
}

// DataProcessorImpTimed provides timeout-configured expectation methods.
// Access via DataProcessorImp.Within(duration) to set a timeout for expectations.
type DataProcessorImpTimed struct {
	ExpectCallIs *DataProcessorImpExpectCallIs
}

// DataProcessorImpTransformBuilder provides a fluent API for setting expectations on Transform calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type DataProcessorImpTransformBuilder struct {
	imp     *DataProcessorImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Transform call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *DataProcessorImpTransformBuilder) ExpectArgsAre(input samepackage.DataSource) *DataProcessorImpTransformCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		if callToCheck.Name() != "Transform" {
			return false
		}
		methodCall := callToCheck.AsTransform()
		if !_reflect.DeepEqual(methodCall.input, input) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsTransform()
}

// ExpectArgsShould waits for a Transform call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *DataProcessorImpTransformBuilder) ExpectArgsShould(input any) *DataProcessorImpTransformCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		if callToCheck.Name() != "Transform" {
			return false
		}
		methodCall := callToCheck.AsTransform()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.input, input)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsTransform()
}

// InjectPanic waits for a Transform call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *DataProcessorImpTransformBuilder) InjectPanic(msg any) *DataProcessorImpTransformCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		return callToCheck.Name() == "Transform"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsTransform()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a Transform call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *DataProcessorImpTransformBuilder) InjectResults(r0 samepackage.DataSource, r1 error) *DataProcessorImpTransformCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		return callToCheck.Name() == "Transform"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsTransform()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// DataProcessorImpTransformCall represents a captured call to the Transform method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type DataProcessorImpTransformCall struct {
	responseChan chan DataProcessorImpTransformCallResponse
	done         bool
	input        samepackage.DataSource
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *DataProcessorImpTransformCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- DataProcessorImpTransformCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *DataProcessorImpTransformCall) InjectResults(r0 samepackage.DataSource, r1 error) {
	c.done = true
	resp := DataProcessorImpTransformCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// DataProcessorImpTransformCallResponse holds the response configuration for the Transform method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type DataProcessorImpTransformCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    samepackage.DataSource
	Result1    error
	PanicValue any
}

// DataProcessorImpValidateBuilder provides a fluent API for setting expectations on Validate calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type DataProcessorImpValidateBuilder struct {
	imp     *DataProcessorImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Validate call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *DataProcessorImpValidateBuilder) ExpectArgsAre(sink samepackage.DataSink) *DataProcessorImpValidateCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		if callToCheck.Name() != "Validate" {
			return false
		}
		methodCall := callToCheck.AsValidate()
		if !_reflect.DeepEqual(methodCall.sink, sink) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsValidate()
}

// ExpectArgsShould waits for a Validate call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *DataProcessorImpValidateBuilder) ExpectArgsShould(sink any) *DataProcessorImpValidateCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		if callToCheck.Name() != "Validate" {
			return false
		}
		methodCall := callToCheck.AsValidate()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.sink, sink)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsValidate()
}

// InjectPanic waits for a Validate call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *DataProcessorImpValidateBuilder) InjectPanic(msg any) *DataProcessorImpValidateCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		return callToCheck.Name() == "Validate"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsValidate()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Validate call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *DataProcessorImpValidateBuilder) InjectResult(result bool) *DataProcessorImpValidateCall {
	validator := func(callToCheck *DataProcessorImpCall) bool {
		return callToCheck.Name() == "Validate"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsValidate()
	methodCall.InjectResult(result)
	return methodCall
}

// DataProcessorImpValidateCall represents a captured call to the Validate method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type DataProcessorImpValidateCall struct {
	responseChan chan DataProcessorImpValidateCallResponse
	done         bool
	sink         samepackage.DataSink
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *DataProcessorImpValidateCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- DataProcessorImpValidateCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *DataProcessorImpValidateCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- DataProcessorImpValidateCallResponse{Type: "return", Result0: result}
}

// DataProcessorImpValidateCallResponse holds the response configuration for the Validate method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type DataProcessorImpValidateCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue any
}

// unexported variables.
var (
	// Compile-time verification that DataProcessorImpMock implements samepackage.DataProcessor.
	_ samepackage.DataProcessor = (*DataProcessorImpMock)(nil)
)
