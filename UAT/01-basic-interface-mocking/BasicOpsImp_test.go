// Code generated by impgen. DO NOT EDIT.

package basic_test

import "github.com/toejough/imptest/imptest"
import "reflect"
import "sync"
import "testing"
import "time"

type BasicOpsImpMock struct {
	imp *BasicOpsImp
}

type BasicOpsImp struct {
	t            *testing.T
	Mock         *BasicOpsImpMock
	callChan     chan *BasicOpsImpCall
	ExpectCallIs *BasicOpsImpExpectCallIs
	currentCall  *BasicOpsImpCall
	callQueue    []*BasicOpsImpCall
	queueLock    sync.Mutex
}

type BasicOpsImpAddCall struct {
	responseChan chan BasicOpsImpAddCallResponse
	done         bool
	a            int
	b            int
}

type BasicOpsImpAddCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    int
	PanicValue any
}

func (c *BasicOpsImpAddCall) InjectResult(result int) {
	c.done = true
	c.responseChan <- BasicOpsImpAddCallResponse{Type: "return", Result0: result}
}
func (c *BasicOpsImpAddCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- BasicOpsImpAddCallResponse{Type: "panic", PanicValue: msg}
}

type BasicOpsImpStoreCall struct {
	responseChan chan BasicOpsImpStoreCallResponse
	done         bool
	key          string
	value        any
}

type BasicOpsImpStoreCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    int
	Result1    error
	PanicValue any
}

func (c *BasicOpsImpStoreCall) InjectResults(r0 int, r1 error) {
	c.done = true
	resp := BasicOpsImpStoreCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}
func (c *BasicOpsImpStoreCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- BasicOpsImpStoreCallResponse{Type: "panic", PanicValue: msg}
}

type BasicOpsImpLogCall struct {
	responseChan chan BasicOpsImpLogCallResponse
	done         bool
	message      string
}

type BasicOpsImpLogCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue any
}

func (c *BasicOpsImpLogCall) Resolve() {
	c.done = true
	c.responseChan <- BasicOpsImpLogCallResponse{Type: "resolve"}
}
func (c *BasicOpsImpLogCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- BasicOpsImpLogCallResponse{Type: "panic", PanicValue: msg}
}

type BasicOpsImpNotifyCall struct {
	responseChan chan BasicOpsImpNotifyCallResponse
	done         bool
	message      string
	ids          []int
}

type BasicOpsImpNotifyCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue any
}

func (c *BasicOpsImpNotifyCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- BasicOpsImpNotifyCallResponse{Type: "return", Result0: result}
}
func (c *BasicOpsImpNotifyCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- BasicOpsImpNotifyCallResponse{Type: "panic", PanicValue: msg}
}

func (m *BasicOpsImpMock) Add(a int, b int) int {
	responseChan := make(chan BasicOpsImpAddCallResponse, 1)

	call := &BasicOpsImpAddCall{
		responseChan: responseChan,
		a:            a,
		b:            b,
	}

	callEvent := &BasicOpsImpCall{
		Add: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

func (m *BasicOpsImpMock) Store(key string, value any) (int, error) {
	responseChan := make(chan BasicOpsImpStoreCallResponse, 1)

	call := &BasicOpsImpStoreCall{
		responseChan: responseChan,
		key:          key,
		value:        value,
	}

	callEvent := &BasicOpsImpCall{
		Store: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

func (m *BasicOpsImpMock) Log(message string) {
	responseChan := make(chan BasicOpsImpLogCallResponse, 1)

	call := &BasicOpsImpLogCall{
		responseChan: responseChan,
		message:      message,
	}

	callEvent := &BasicOpsImpCall{
		Log: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

func (m *BasicOpsImpMock) Notify(message string, ids ...int) bool {
	responseChan := make(chan BasicOpsImpNotifyCallResponse, 1)

	call := &BasicOpsImpNotifyCall{
		responseChan: responseChan,
		message:      message,
		ids:          ids,
	}

	callEvent := &BasicOpsImpCall{
		Notify: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

type BasicOpsImpCall struct {
	Add    *BasicOpsImpAddCall
	Store  *BasicOpsImpStoreCall
	Log    *BasicOpsImpLogCall
	Notify *BasicOpsImpNotifyCall
}

func (c *BasicOpsImpCall) Name() string {
	if c.Add != nil {
		return "Add"
	}
	if c.Store != nil {
		return "Store"
	}
	if c.Log != nil {
		return "Log"
	}
	if c.Notify != nil {
		return "Notify"
	}
	return ""
}

func (c *BasicOpsImpCall) Done() bool {
	if c.Add != nil {
		return c.Add.done
	}
	if c.Store != nil {
		return c.Store.done
	}
	if c.Log != nil {
		return c.Log.done
	}
	if c.Notify != nil {
		return c.Notify.done
	}
	return false
}

func (c *BasicOpsImpCall) AsAdd() *BasicOpsImpAddCall { return c.Add }

func (c *BasicOpsImpCall) AsStore() *BasicOpsImpStoreCall { return c.Store }

func (c *BasicOpsImpCall) AsLog() *BasicOpsImpLogCall { return c.Log }

func (c *BasicOpsImpCall) AsNotify() *BasicOpsImpNotifyCall { return c.Notify }

type BasicOpsImpExpectCallIs struct {
	imp     *BasicOpsImp
	timeout time.Duration
}

type BasicOpsImpAddBuilder struct {
	imp     *BasicOpsImp
	timeout time.Duration
}

func (e *BasicOpsImpExpectCallIs) Add() *BasicOpsImpAddBuilder {
	return &BasicOpsImpAddBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *BasicOpsImpAddBuilder) ExpectArgsAre(a int, b int) *BasicOpsImpAddCall {
	validator := func(c *BasicOpsImpCall) bool {
		if c.Name() != "Add" {
			return false
		}
		methodCall := c.AsAdd()
		if methodCall.a != a {
			return false
		}
		if methodCall.b != b {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsAdd()
}

func (bldr *BasicOpsImpAddBuilder) ExpectArgsShould(a any, b any) *BasicOpsImpAddCall {
	validator := func(c *BasicOpsImpCall) bool {
		if c.Name() != "Add" {
			return false
		}
		methodCall := c.AsAdd()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.a, a)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.b, b)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsAdd()
}

func (bldr *BasicOpsImpAddBuilder) InjectResult(result int) *BasicOpsImpAddCall {
	validator := func(c *BasicOpsImpCall) bool {
		return c.Name() == "Add"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsAdd()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *BasicOpsImpAddBuilder) InjectPanic(msg any) *BasicOpsImpAddCall {
	validator := func(c *BasicOpsImpCall) bool {
		return c.Name() == "Add"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsAdd()
	methodCall.InjectPanic(msg)
	return methodCall
}

type BasicOpsImpStoreBuilder struct {
	imp     *BasicOpsImp
	timeout time.Duration
}

func (e *BasicOpsImpExpectCallIs) Store() *BasicOpsImpStoreBuilder {
	return &BasicOpsImpStoreBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *BasicOpsImpStoreBuilder) ExpectArgsAre(key string, value any) *BasicOpsImpStoreCall {
	validator := func(c *BasicOpsImpCall) bool {
		if c.Name() != "Store" {
			return false
		}
		methodCall := c.AsStore()
		if methodCall.key != key {
			return false
		}
		if methodCall.value != value {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsStore()
}

func (bldr *BasicOpsImpStoreBuilder) ExpectArgsShould(key any, value any) *BasicOpsImpStoreCall {
	validator := func(c *BasicOpsImpCall) bool {
		if c.Name() != "Store" {
			return false
		}
		methodCall := c.AsStore()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.key, key)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.value, value)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsStore()
}

func (bldr *BasicOpsImpStoreBuilder) InjectResults(r0 int, r1 error) *BasicOpsImpStoreCall {
	validator := func(c *BasicOpsImpCall) bool {
		return c.Name() == "Store"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsStore()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

func (bldr *BasicOpsImpStoreBuilder) InjectPanic(msg any) *BasicOpsImpStoreCall {
	validator := func(c *BasicOpsImpCall) bool {
		return c.Name() == "Store"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsStore()
	methodCall.InjectPanic(msg)
	return methodCall
}

type BasicOpsImpLogBuilder struct {
	imp     *BasicOpsImp
	timeout time.Duration
}

func (e *BasicOpsImpExpectCallIs) Log() *BasicOpsImpLogBuilder {
	return &BasicOpsImpLogBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *BasicOpsImpLogBuilder) ExpectArgsAre(message string) *BasicOpsImpLogCall {
	validator := func(c *BasicOpsImpCall) bool {
		if c.Name() != "Log" {
			return false
		}
		methodCall := c.AsLog()
		if methodCall.message != message {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsLog()
}

func (bldr *BasicOpsImpLogBuilder) ExpectArgsShould(message any) *BasicOpsImpLogCall {
	validator := func(c *BasicOpsImpCall) bool {
		if c.Name() != "Log" {
			return false
		}
		methodCall := c.AsLog()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.message, message)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsLog()
}

func (bldr *BasicOpsImpLogBuilder) Resolve() *BasicOpsImpLogCall {
	validator := func(c *BasicOpsImpCall) bool {
		return c.Name() == "Log"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsLog()
	methodCall.Resolve()
	return methodCall
}

func (bldr *BasicOpsImpLogBuilder) InjectPanic(msg any) *BasicOpsImpLogCall {
	validator := func(c *BasicOpsImpCall) bool {
		return c.Name() == "Log"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsLog()
	methodCall.InjectPanic(msg)
	return methodCall
}

type BasicOpsImpNotifyBuilder struct {
	imp     *BasicOpsImp
	timeout time.Duration
}

func (e *BasicOpsImpExpectCallIs) Notify() *BasicOpsImpNotifyBuilder {
	return &BasicOpsImpNotifyBuilder{imp: e.imp, timeout: e.timeout}
}

func (bldr *BasicOpsImpNotifyBuilder) ExpectArgsAre(message string, ids ...int) *BasicOpsImpNotifyCall {
	validator := func(c *BasicOpsImpCall) bool {
		if c.Name() != "Notify" {
			return false
		}
		methodCall := c.AsNotify()
		if methodCall.message != message {
			return false
		}
		if !reflect.DeepEqual(methodCall.ids, ids) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsNotify()
}

func (bldr *BasicOpsImpNotifyBuilder) ExpectArgsShould(message any, ids any) *BasicOpsImpNotifyCall {
	validator := func(c *BasicOpsImpCall) bool {
		if c.Name() != "Notify" {
			return false
		}
		methodCall := c.AsNotify()
		var ok bool
		ok, _ = imptest.MatchValue(methodCall.message, message)
		if !ok {
			return false
		}
		ok, _ = imptest.MatchValue(methodCall.ids, ids)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsNotify()
}

func (bldr *BasicOpsImpNotifyBuilder) InjectResult(result bool) *BasicOpsImpNotifyCall {
	validator := func(c *BasicOpsImpCall) bool {
		return c.Name() == "Notify"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsNotify()
	methodCall.InjectResult(result)
	return methodCall
}

func (bldr *BasicOpsImpNotifyBuilder) InjectPanic(msg any) *BasicOpsImpNotifyCall {
	validator := func(c *BasicOpsImpCall) bool {
		return c.Name() == "Notify"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsNotify()
	methodCall.InjectPanic(msg)
	return methodCall
}

type BasicOpsImpTimed struct {
	ExpectCallIs *BasicOpsImpExpectCallIs
}

func (i *BasicOpsImp) Within(d time.Duration) *BasicOpsImpTimed {
	return &BasicOpsImpTimed{
		ExpectCallIs: &BasicOpsImpExpectCallIs{imp: i, timeout: d},
	}
}

func (i *BasicOpsImp) GetCall(
	d time.Duration, validator func(*BasicOpsImpCall) bool,
) *BasicOpsImpCall {
	i.queueLock.Lock()

	// Check queue first while holding lock
	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			i.queueLock.Unlock()
			return call
		}
	}

	// Release lock before blocking on channel to avoid deadlock
	i.queueLock.Unlock()

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it - need lock to access shared queue
			i.queueLock.Lock()
			i.callQueue = append(i.callQueue, call)
			i.queueLock.Unlock()
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

func (i *BasicOpsImp) GetCurrentCall() *BasicOpsImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *BasicOpsImpCall) bool { return true })
	return i.currentCall
}

func NewBasicOpsImp(t *testing.T) *BasicOpsImp {
	imp := &BasicOpsImp{
		t:        t,
		callChan: make(chan *BasicOpsImpCall, 1),
	}
	imp.Mock = &BasicOpsImpMock{imp: imp}
	imp.ExpectCallIs = &BasicOpsImpExpectCallIs{imp: imp}
	return imp
}
