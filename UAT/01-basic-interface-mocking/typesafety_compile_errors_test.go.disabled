// This file demonstrates compile errors with typed InjectReturnValues.
// Rename to .go to verify these produce compile errors.
package basic_test

import "testing"

func TestWrongTypes(t *testing.T) {
	mock := MockOps(t)

	// COMPILE ERROR: cannot use "wrong" (type string) as type int
	go func() { _, _ = mock.Interface().Store("key", "value") }()
	call := mock.Store.ExpectCalledWithExactly("key", "value")
	call.InjectReturnValues("wrong", nil) // ✗ expects (int, error) but got (string, nil)
}

func TestWrongArity_TooFew(t *testing.T) {
	mock := MockOps(t)

	// COMPILE ERROR: not enough arguments (expected 2, got 1)
	go func() { _, _ = mock.Interface().Store("key", "value") }()
	call := mock.Store.ExpectCalledWithExactly("key", "value")
	call.InjectReturnValues(42) // ✗ expects (int, error) but got (int)
}

func TestWrongArity_TooMany(t *testing.T) {
	mock := MockOps(t)

	// COMPILE ERROR: too many arguments (expected 2, got 3)
	go func() { _, _ = mock.Interface().Store("key", "value") }()
	call := mock.Store.ExpectCalledWithExactly("key", "value")
	call.InjectReturnValues(42, nil, "extra") // ✗ expects (int, error) but got 3 args
}

func TestWrongType_SingleReturn(t *testing.T) {
	mock := MockOps(t)

	// COMPILE ERROR: cannot use "wrong" (type string) as type int
	go func() { _ = mock.Interface().Add(5, 3) }()
	call := mock.Add.ExpectCalledWithExactly(5, 3)
	call.InjectReturnValues("wrong") // ✗ expects (int) but got (string)
}
