// Code generated by impgen. DO NOT EDIT.

package basic_test

import _imptest "github.com/toejough/imptest/imptest"
import _reflect "reflect"
import _testing "testing"
import _time "time"
import basic "github.com/toejough/imptest/UAT/01-basic-interface-mocking"

// CustomOpsImp is the test controller for mocking the interface.
// Create with NewCustomOpsImp(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := NewCustomOpsImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type CustomOpsImp struct {
	*_imptest.Controller[*CustomOpsImpCall]
	Mock         *CustomOpsImpMock
	ExpectCallIs *CustomOpsImpExpectCallIs
	currentCall  *CustomOpsImpCall
}

// NewCustomOpsImp creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := NewCustomOpsImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func NewCustomOpsImp(t *_testing.T) *CustomOpsImp {
	imp := &CustomOpsImp{
		Controller: _imptest.NewController[*CustomOpsImpCall](t),
	}
	imp.Mock = &CustomOpsImpMock{imp: imp}
	imp.ExpectCallIs = &CustomOpsImpExpectCallIs{imp: imp}
	return imp
}

// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *CustomOpsImp) GetCurrentCall() *CustomOpsImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *CustomOpsImpCall) bool { return true })
	return i.currentCall
}

// Within configures a timeout for expectations and returns a CustomOpsImpTimed for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*_time.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *CustomOpsImp) Within(d _time.Duration) *CustomOpsImpTimed {
	return &CustomOpsImpTimed{
		ExpectCallIs: &CustomOpsImpExpectCallIs{imp: i, timeout: d},
	}
}

// CustomOpsImpAddBuilder provides a fluent API for setting expectations on Add calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type CustomOpsImpAddBuilder struct {
	imp     *CustomOpsImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Add call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *CustomOpsImpAddBuilder) ExpectArgsAre(a int, b int) *CustomOpsImpAddCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		if callToCheck.Name() != "Add" {
			return false
		}
		methodCall := callToCheck.AsAdd()
		if methodCall.a != a {
			return false
		}
		if methodCall.b != b {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsAdd()
}

// ExpectArgsShould waits for a Add call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *CustomOpsImpAddBuilder) ExpectArgsShould(a any, b any) *CustomOpsImpAddCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		if callToCheck.Name() != "Add" {
			return false
		}
		methodCall := callToCheck.AsAdd()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.a, a)
		if !ok {
			return false
		}
		ok, _ = _imptest.MatchValue(methodCall.b, b)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsAdd()
}

// InjectPanic waits for a Add call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *CustomOpsImpAddBuilder) InjectPanic(msg any) *CustomOpsImpAddCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		return callToCheck.Name() == "Add"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsAdd()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Add call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *CustomOpsImpAddBuilder) InjectResult(result int) *CustomOpsImpAddCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		return callToCheck.Name() == "Add"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsAdd()
	methodCall.InjectResult(result)
	return methodCall
}

// CustomOpsImpAddCall represents a captured call to the Add method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type CustomOpsImpAddCall struct {
	responseChan chan CustomOpsImpAddCallResponse
	done         bool
	a            int
	b            int
	t            _imptest.Tester
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *CustomOpsImpAddCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- CustomOpsImpAddCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *CustomOpsImpAddCall) InjectResult(result int) {
	c.done = true
	c.responseChan <- CustomOpsImpAddCallResponse{Type: "return", Result0: result}
}

// CustomOpsImpAddCallResponse holds the response configuration for the Add method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type CustomOpsImpAddCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    int
	PanicValue any
}

// CustomOpsImpCall represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{Method}() to access typed call details.
type CustomOpsImpCall struct {
	add    *CustomOpsImpAddCall
	store  *CustomOpsImpStoreCall
	log    *CustomOpsImpLogCall
	notify *CustomOpsImpNotifyCall
	finish *CustomOpsImpFinishCall
}

// AsAdd returns the call cast to CustomOpsImpAddCall for accessing call details.
// Returns nil if the call was not to Add.
func (c *CustomOpsImpCall) AsAdd() *CustomOpsImpAddCall {
	return c.add
}

// AsFinish returns the call cast to CustomOpsImpFinishCall for accessing call details.
// Returns nil if the call was not to Finish.
func (c *CustomOpsImpCall) AsFinish() *CustomOpsImpFinishCall {
	return c.finish
}

// AsLog returns the call cast to CustomOpsImpLogCall for accessing call details.
// Returns nil if the call was not to Log.
func (c *CustomOpsImpCall) AsLog() *CustomOpsImpLogCall {
	return c.log
}

// AsNotify returns the call cast to CustomOpsImpNotifyCall for accessing call details.
// Returns nil if the call was not to Notify.
func (c *CustomOpsImpCall) AsNotify() *CustomOpsImpNotifyCall {
	return c.notify
}

// AsStore returns the call cast to CustomOpsImpStoreCall for accessing call details.
// Returns nil if the call was not to Store.
func (c *CustomOpsImpCall) AsStore() *CustomOpsImpStoreCall {
	return c.store
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *CustomOpsImpCall) Done() bool {
	if c.add != nil {
		return c.add.done
	}
	if c.store != nil {
		return c.store.done
	}
	if c.log != nil {
		return c.log.done
	}
	if c.notify != nil {
		return c.notify.done
	}
	if c.finish != nil {
		return c.finish.done
	}
	return false
}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *CustomOpsImpCall) Name() string {
	if c.add != nil {
		return "Add"
	}
	if c.store != nil {
		return "Store"
	}
	if c.log != nil {
		return "Log"
	}
	if c.notify != nil {
		return "Notify"
	}
	if c.finish != nil {
		return "Finish"
	}
	return ""
}

// CustomOpsImpExpectCallIs provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent CustomOpsImp to configure timeouts.
type CustomOpsImpExpectCallIs struct {
	imp     *CustomOpsImp
	timeout _time.Duration
}

// Add returns a builder for setting expectations on Add method calls.
func (e *CustomOpsImpExpectCallIs) Add() *CustomOpsImpAddBuilder {
	return &CustomOpsImpAddBuilder{imp: e.imp, timeout: e.timeout}
}

// Finish returns a builder for setting expectations on Finish method calls.
func (e *CustomOpsImpExpectCallIs) Finish() *CustomOpsImpFinishBuilder {
	return &CustomOpsImpFinishBuilder{imp: e.imp, timeout: e.timeout}
}

// Log returns a builder for setting expectations on Log method calls.
func (e *CustomOpsImpExpectCallIs) Log() *CustomOpsImpLogBuilder {
	return &CustomOpsImpLogBuilder{imp: e.imp, timeout: e.timeout}
}

// Notify returns a builder for setting expectations on Notify method calls.
func (e *CustomOpsImpExpectCallIs) Notify() *CustomOpsImpNotifyBuilder {
	return &CustomOpsImpNotifyBuilder{imp: e.imp, timeout: e.timeout}
}

// Store returns a builder for setting expectations on Store method calls.
func (e *CustomOpsImpExpectCallIs) Store() *CustomOpsImpStoreBuilder {
	return &CustomOpsImpStoreBuilder{imp: e.imp, timeout: e.timeout}
}

// CustomOpsImpFinishBuilder provides a fluent API for setting expectations on Finish calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type CustomOpsImpFinishBuilder struct {
	imp     *CustomOpsImp
	timeout _time.Duration
}

// InjectPanic waits for a Finish call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *CustomOpsImpFinishBuilder) InjectPanic(msg any) *CustomOpsImpFinishCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		return callToCheck.Name() == "Finish"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsFinish()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Finish call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *CustomOpsImpFinishBuilder) InjectResult(result bool) *CustomOpsImpFinishCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		return callToCheck.Name() == "Finish"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsFinish()
	methodCall.InjectResult(result)
	return methodCall
}

// CustomOpsImpFinishCall represents a captured call to the Finish method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type CustomOpsImpFinishCall struct {
	responseChan chan CustomOpsImpFinishCallResponse
	done         bool
	t            _imptest.Tester
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *CustomOpsImpFinishCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- CustomOpsImpFinishCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *CustomOpsImpFinishCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- CustomOpsImpFinishCallResponse{Type: "return", Result0: result}
}

// CustomOpsImpFinishCallResponse holds the response configuration for the Finish method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type CustomOpsImpFinishCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue any
}

// CustomOpsImpLogBuilder provides a fluent API for setting expectations on Log calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type CustomOpsImpLogBuilder struct {
	imp     *CustomOpsImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Log call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *CustomOpsImpLogBuilder) ExpectArgsAre(message string) *CustomOpsImpLogCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		if callToCheck.Name() != "Log" {
			return false
		}
		methodCall := callToCheck.AsLog()
		if methodCall.message != message {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsLog()
}

// ExpectArgsShould waits for a Log call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *CustomOpsImpLogBuilder) ExpectArgsShould(message any) *CustomOpsImpLogCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		if callToCheck.Name() != "Log" {
			return false
		}
		methodCall := callToCheck.AsLog()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.message, message)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsLog()
}

// InjectPanic waits for a Log call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *CustomOpsImpLogBuilder) InjectPanic(msg any) *CustomOpsImpLogCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		return callToCheck.Name() == "Log"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsLog()
	methodCall.InjectPanic(msg)
	return methodCall
}

// Resolve waits for a Log call and immediately completes it without error.
// This is a shortcut that combines waiting for the call with resolving it.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *CustomOpsImpLogBuilder) Resolve() *CustomOpsImpLogCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		return callToCheck.Name() == "Log"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsLog()
	methodCall.Resolve()
	return methodCall
}

// CustomOpsImpLogCall represents a captured call to the Log method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type CustomOpsImpLogCall struct {
	responseChan chan CustomOpsImpLogCallResponse
	done         bool
	message      string
	t            _imptest.Tester
}

// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *CustomOpsImpLogCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- CustomOpsImpLogCallResponse{Type: "panic", PanicValue: msg}
}

// Resolve completes a void method call without error.
// Use this to unblock the mock method and allow execution to continue.
// Only applicable to methods with no return values.
func (c *CustomOpsImpLogCall) Resolve() {
	c.done = true
	c.responseChan <- CustomOpsImpLogCallResponse{Type: "resolve"}
} // InjectPanic causes the mocked method to panic with the given value.

// CustomOpsImpLogCallResponse holds the response configuration for the Log method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type CustomOpsImpLogCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue any
}

// CustomOpsImpMock provides the mock implementation of the interface.
// Pass CustomOpsImpMock to code under test that expects the interface implementation.
// Use the parent CustomOpsImp controller to set expectations and inject responses.
type CustomOpsImpMock struct {
	imp *CustomOpsImp
}

// Add implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *CustomOpsImpMock) Add(a int, b int) int {
	responseChan := make(chan CustomOpsImpAddCallResponse, 1)

	call := &CustomOpsImpAddCall{
		responseChan: responseChan,
		a:            a,
		b:            b,
		t:            m.imp.T,
	}

	callEvent := &CustomOpsImpCall{
		add: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// Finish implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *CustomOpsImpMock) Finish() bool {
	responseChan := make(chan CustomOpsImpFinishCallResponse, 1)

	call := &CustomOpsImpFinishCall{
		responseChan: responseChan,
		t:            m.imp.T,
	}

	callEvent := &CustomOpsImpCall{
		finish: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// Log implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *CustomOpsImpMock) Log(message string) {
	responseChan := make(chan CustomOpsImpLogCallResponse, 1)

	call := &CustomOpsImpLogCall{
		responseChan: responseChan,
		message:      message,
		t:            m.imp.T,
	}

	callEvent := &CustomOpsImpCall{
		log: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

// Notify implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *CustomOpsImpMock) Notify(message string, ids ...int) bool {
	responseChan := make(chan CustomOpsImpNotifyCallResponse, 1)

	call := &CustomOpsImpNotifyCall{
		responseChan: responseChan,
		message:      message,
		ids:          ids,
		t:            m.imp.T,
	}

	callEvent := &CustomOpsImpCall{
		notify: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0
}

// Store implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *CustomOpsImpMock) Store(key string, value any) (int, error) {
	responseChan := make(chan CustomOpsImpStoreCallResponse, 1)

	call := &CustomOpsImpStoreCall{
		responseChan: responseChan,
		key:          key,
		value:        value,
		t:            m.imp.T,
	}

	callEvent := &CustomOpsImpCall{
		store: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return resp.Result0, resp.Result1
}

// CustomOpsImpNotifyBuilder provides a fluent API for setting expectations on Notify calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type CustomOpsImpNotifyBuilder struct {
	imp     *CustomOpsImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Notify call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *CustomOpsImpNotifyBuilder) ExpectArgsAre(message string, ids ...int) *CustomOpsImpNotifyCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		if callToCheck.Name() != "Notify" {
			return false
		}
		methodCall := callToCheck.AsNotify()
		if methodCall.message != message {
			return false
		}
		if !_reflect.DeepEqual(methodCall.ids, ids) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsNotify()
}

// ExpectArgsShould waits for a Notify call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *CustomOpsImpNotifyBuilder) ExpectArgsShould(message any, ids any) *CustomOpsImpNotifyCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		if callToCheck.Name() != "Notify" {
			return false
		}
		methodCall := callToCheck.AsNotify()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.message, message)
		if !ok {
			return false
		}
		ok, _ = _imptest.MatchValue(methodCall.ids, ids)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsNotify()
}

// InjectPanic waits for a Notify call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *CustomOpsImpNotifyBuilder) InjectPanic(msg any) *CustomOpsImpNotifyCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		return callToCheck.Name() == "Notify"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsNotify()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResult waits for a Notify call and immediately injects the return value.
// This is a shortcut that combines waiting for the call with injecting the result.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *CustomOpsImpNotifyBuilder) InjectResult(result bool) *CustomOpsImpNotifyCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		return callToCheck.Name() == "Notify"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsNotify()
	methodCall.InjectResult(result)
	return methodCall
}

// CustomOpsImpNotifyCall represents a captured call to the Notify method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type CustomOpsImpNotifyCall struct {
	responseChan chan CustomOpsImpNotifyCallResponse
	done         bool
	message      string
	ids          []int
	t            _imptest.Tester
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *CustomOpsImpNotifyCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- CustomOpsImpNotifyCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResult sets the return value for this method call and unblocks the caller.
// The mocked method will return the provided result value.
func (c *CustomOpsImpNotifyCall) InjectResult(result bool) {
	c.done = true
	c.responseChan <- CustomOpsImpNotifyCallResponse{Type: "return", Result0: result}
}

// CustomOpsImpNotifyCallResponse holds the response configuration for the Notify method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type CustomOpsImpNotifyCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    bool
	PanicValue any
}

// CustomOpsImpStoreBuilder provides a fluent API for setting expectations on Store calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type CustomOpsImpStoreBuilder struct {
	imp     *CustomOpsImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Store call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *CustomOpsImpStoreBuilder) ExpectArgsAre(key string, value any) *CustomOpsImpStoreCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		if callToCheck.Name() != "Store" {
			return false
		}
		methodCall := callToCheck.AsStore()
		if methodCall.key != key {
			return false
		}
		if !_reflect.DeepEqual(methodCall.value, value) {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsStore()
}

// ExpectArgsShould waits for a Store call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *CustomOpsImpStoreBuilder) ExpectArgsShould(key any, value any) *CustomOpsImpStoreCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		if callToCheck.Name() != "Store" {
			return false
		}
		methodCall := callToCheck.AsStore()
		var ok bool
		ok, _ = _imptest.MatchValue(methodCall.key, key)
		if !ok {
			return false
		}
		ok, _ = _imptest.MatchValue(methodCall.value, value)
		if !ok {
			return false
		}
		return true
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsStore()
}

// InjectPanic waits for a Store call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *CustomOpsImpStoreBuilder) InjectPanic(msg any) *CustomOpsImpStoreCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		return callToCheck.Name() == "Store"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsStore()
	methodCall.InjectPanic(msg)
	return methodCall
}

// InjectResults waits for a Store call and immediately injects the return values.
// This is a shortcut that combines waiting for the call with injecting multiple results.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *CustomOpsImpStoreBuilder) InjectResults(r0 int, r1 error) *CustomOpsImpStoreCall {
	validator := func(callToCheck *CustomOpsImpCall) bool {
		return callToCheck.Name() == "Store"
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsStore()
	methodCall.InjectResults(r0, r1)
	return methodCall
}

// CustomOpsImpStoreCall represents a captured call to the Store method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type CustomOpsImpStoreCall struct {
	responseChan chan CustomOpsImpStoreCallResponse
	done         bool
	key          string
	value        any
	t            _imptest.Tester
}

// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *CustomOpsImpStoreCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- CustomOpsImpStoreCallResponse{Type: "panic", PanicValue: msg}
}

// InjectResults sets the return values for this method call and unblocks the caller.
// The mocked method will return the provided result values in order.
func (c *CustomOpsImpStoreCall) InjectResults(r0 int, r1 error) {
	c.done = true
	resp := CustomOpsImpStoreCallResponse{Type: "return", Result0: r0, Result1: r1}
	c.responseChan <- resp
}

// CustomOpsImpStoreCallResponse holds the response configuration for the Store method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type CustomOpsImpStoreCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	Result0    int
	Result1    error
	PanicValue any
}

// CustomOpsImpTimed provides timeout-configured expectation methods.
// Access via CustomOpsImp.Within(duration) to set a timeout for expectations.
type CustomOpsImpTimed struct {
	ExpectCallIs *CustomOpsImpExpectCallIs
}

// unexported variables.
var (
	// Compile-time verification that CustomOpsImpMock implements basic.Ops.
	_ basic.Ops = (*CustomOpsImpMock)(nil)
)
