// Code generated by impgen. DO NOT EDIT.
// impgen:hash:ce137bf3b9d88ed8

package generics_test

import (
	_imptest "github.com/toejough/imptest"
	generics "github.com/toejough/imptest/UAT/variations/signature/generics"
)

// RepositoryImp holds method wrappers for setting expectations on Repository.
type RepositoryImp[T any] struct {
	Save *RepositoryMockSaveMethod[T]
	Get  *RepositoryMockGetMethod[T]
	// Eventually provides async versions of all methods for concurrent code.
	Eventually *RepositoryImpEventually[T]
}

// RepositoryImpEventually holds async method wrappers for Repository.
type RepositoryImpEventually[T any] struct {
	Save *RepositoryMockSaveMethod[T]
	Get  *RepositoryMockGetMethod[T]
}

// RepositoryMockGetArgs holds typed arguments for Get.
type RepositoryMockGetArgs[T any] struct {
	Id string
}

// RepositoryMockGetCall wraps DependencyCall with typed GetArgs and Return.
type RepositoryMockGetCall[T any] struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RepositoryMockGetCall[T]) GetArgs() RepositoryMockGetArgs[T] {
	raw := c.RawArgs()
	return RepositoryMockGetArgs[T]{
		Id: raw[0].(string),
	}
}

// Return specifies the typed values the mock should return.
func (c *RepositoryMockGetCall[T]) Return(result0 T, result1 error) {
	c.DependencyCall.Return(result0, result1)
}

// RepositoryMockGetMethod wraps DependencyMethod with typed returns.
type RepositoryMockGetMethod[T any] struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *RepositoryMockGetMethod[T]) ArgsEqual(id string) *RepositoryMockGetCall[T] {
	call := m.DependencyMethod.ArgsEqual(id)
	return &RepositoryMockGetCall[T]{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *RepositoryMockGetMethod[T]) ArgsShould(matchers ...any) *RepositoryMockGetCall[T] {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &RepositoryMockGetCall[T]{DependencyCall: call}
}

// RepositoryMockSaveArgs holds typed arguments for Save.
type RepositoryMockSaveArgs[T any] struct {
	Item T
}

// RepositoryMockSaveCall wraps DependencyCall with typed GetArgs and Return.
type RepositoryMockSaveCall[T any] struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RepositoryMockSaveCall[T]) GetArgs() RepositoryMockSaveArgs[T] {
	raw := c.RawArgs()
	return RepositoryMockSaveArgs[T]{
		Item: raw[0].(T),
	}
}

// Return specifies the typed values the mock should return.
func (c *RepositoryMockSaveCall[T]) Return(result0 error) {
	c.DependencyCall.Return(result0)
}

// RepositoryMockSaveMethod wraps DependencyMethod with typed returns.
type RepositoryMockSaveMethod[T any] struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *RepositoryMockSaveMethod[T]) ArgsEqual(item T) *RepositoryMockSaveCall[T] {
	call := m.DependencyMethod.ArgsEqual(item)
	return &RepositoryMockSaveCall[T]{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *RepositoryMockSaveMethod[T]) ArgsShould(matchers ...any) *RepositoryMockSaveCall[T] {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &RepositoryMockSaveCall[T]{DependencyCall: call}
}

// MockRepository creates a mock Repository and returns (mock, expectation handle).
func MockRepository[T any](t _imptest.TestReporter) (generics.Repository[T], *RepositoryImp[T]) {
	ctrl := _imptest.GetOrCreateImp(t)
	imp := &RepositoryImp[T]{
		Save: newRepositoryMockSaveMethod[T](_imptest.NewDependencyMethod(ctrl, "Save")),
		Get:  newRepositoryMockGetMethod[T](_imptest.NewDependencyMethod(ctrl, "Get")),
	}
	imp.Eventually = &RepositoryImpEventually[T]{
		Save: newRepositoryMockSaveMethod[T](_imptest.NewDependencyMethod(ctrl, "Save").AsEventually()),
		Get:  newRepositoryMockGetMethod[T](_imptest.NewDependencyMethod(ctrl, "Get").AsEventually()),
	}
	mock := &mockRepositoryImpl[T]{ctrl: ctrl}
	return mock, imp
}

// mockRepositoryImpl implements generics.Repository[T].
type mockRepositoryImpl[T any] struct {
	ctrl *_imptest.Imp
}

// Get implements generics.Repository[T].Get.
func (impl *mockRepositoryImpl[T]) Get(id string) (T, error) {
	call := &_imptest.GenericCall{
		MethodName:   "Get",
		Args:         []any{id},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 T
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(T); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// Save implements generics.Repository[T].Save.
func (impl *mockRepositoryImpl[T]) Save(item T) error {
	call := &_imptest.GenericCall{
		MethodName:   "Save",
		Args:         []any{item},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}

// newRepositoryMockGetMethod creates a typed method wrapper.
func newRepositoryMockGetMethod[T any](dm *_imptest.DependencyMethod) *RepositoryMockGetMethod[T] {
	return &RepositoryMockGetMethod[T]{DependencyMethod: dm}
}

// newRepositoryMockSaveMethod creates a typed method wrapper.
func newRepositoryMockSaveMethod[T any](dm *_imptest.DependencyMethod) *RepositoryMockSaveMethod[T] {
	return &RepositoryMockSaveMethod[T]{DependencyMethod: dm}
}
