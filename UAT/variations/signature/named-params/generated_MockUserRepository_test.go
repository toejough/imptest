// Code generated by impgen. DO NOT EDIT.
// impgen:hash:7a463d2cfe9dda96

package named_test

import (
	context "context"
	_imptest "github.com/toejough/imptest"
	named "github.com/toejough/imptest/UAT/variations/signature/named-params"
)

// UserRepositoryImp holds method wrappers for setting expectations on UserRepository.
type UserRepositoryImp struct {
	GetUser    *UserRepositoryMockGetUserMethod
	SaveUser   *UserRepositoryMockSaveUserMethod
	DeleteUser *UserRepositoryMockDeleteUserMethod
	CountUsers *UserRepositoryMockCountUsersMethod
	// Eventually provides async versions of all methods for concurrent code.
	Eventually *UserRepositoryImpEventually
}

// UserRepositoryImpEventually holds async method wrappers for UserRepository.
type UserRepositoryImpEventually struct {
	GetUser    *UserRepositoryMockGetUserMethod
	SaveUser   *UserRepositoryMockSaveUserMethod
	DeleteUser *UserRepositoryMockDeleteUserMethod
	CountUsers *UserRepositoryMockCountUsersMethod
}

// UserRepositoryMockCountUsersArgs holds typed arguments for CountUsers.
type UserRepositoryMockCountUsersArgs struct {
	Ctx context.Context
}

// UserRepositoryMockCountUsersCall wraps DependencyCall with typed GetArgs and Return.
type UserRepositoryMockCountUsersCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *UserRepositoryMockCountUsersCall) GetArgs() UserRepositoryMockCountUsersArgs {
	raw := c.RawArgs()
	return UserRepositoryMockCountUsersArgs{
		Ctx: raw[0].(context.Context),
	}
}

// Return specifies the typed values the mock should return.
func (c *UserRepositoryMockCountUsersCall) Return(result0 int, result1 error) {
	c.DependencyCall.Return(result0, result1)
}

// UserRepositoryMockCountUsersMethod wraps DependencyMethod with typed returns.
type UserRepositoryMockCountUsersMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *UserRepositoryMockCountUsersMethod) ArgsEqual(ctx context.Context) *UserRepositoryMockCountUsersCall {
	call := m.DependencyMethod.ArgsEqual(ctx)
	return &UserRepositoryMockCountUsersCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *UserRepositoryMockCountUsersMethod) ArgsShould(matchers ...any) *UserRepositoryMockCountUsersCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &UserRepositoryMockCountUsersCall{DependencyCall: call}
}

// UserRepositoryMockDeleteUserArgs holds typed arguments for DeleteUser.
type UserRepositoryMockDeleteUserArgs struct {
	Ctx    context.Context
	UserID int
}

// UserRepositoryMockDeleteUserCall wraps DependencyCall with typed GetArgs and Return.
type UserRepositoryMockDeleteUserCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *UserRepositoryMockDeleteUserCall) GetArgs() UserRepositoryMockDeleteUserArgs {
	raw := c.RawArgs()
	return UserRepositoryMockDeleteUserArgs{
		Ctx:    raw[0].(context.Context),
		UserID: raw[1].(int),
	}
}

// Return specifies the typed values the mock should return.
func (c *UserRepositoryMockDeleteUserCall) Return(result0 error) {
	c.DependencyCall.Return(result0)
}

// UserRepositoryMockDeleteUserMethod wraps DependencyMethod with typed returns.
type UserRepositoryMockDeleteUserMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *UserRepositoryMockDeleteUserMethod) ArgsEqual(ctx context.Context, userID int) *UserRepositoryMockDeleteUserCall {
	call := m.DependencyMethod.ArgsEqual(ctx, userID)
	return &UserRepositoryMockDeleteUserCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *UserRepositoryMockDeleteUserMethod) ArgsShould(matchers ...any) *UserRepositoryMockDeleteUserCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &UserRepositoryMockDeleteUserCall{DependencyCall: call}
}

// UserRepositoryMockGetUserArgs holds typed arguments for GetUser.
type UserRepositoryMockGetUserArgs struct {
	Ctx    context.Context
	UserID int
}

// UserRepositoryMockGetUserCall wraps DependencyCall with typed GetArgs and Return.
type UserRepositoryMockGetUserCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *UserRepositoryMockGetUserCall) GetArgs() UserRepositoryMockGetUserArgs {
	raw := c.RawArgs()
	return UserRepositoryMockGetUserArgs{
		Ctx:    raw[0].(context.Context),
		UserID: raw[1].(int),
	}
}

// Return specifies the typed values the mock should return.
func (c *UserRepositoryMockGetUserCall) Return(result0 named.User, result1 error) {
	c.DependencyCall.Return(result0, result1)
}

// UserRepositoryMockGetUserMethod wraps DependencyMethod with typed returns.
type UserRepositoryMockGetUserMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *UserRepositoryMockGetUserMethod) ArgsEqual(ctx context.Context, userID int) *UserRepositoryMockGetUserCall {
	call := m.DependencyMethod.ArgsEqual(ctx, userID)
	return &UserRepositoryMockGetUserCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *UserRepositoryMockGetUserMethod) ArgsShould(matchers ...any) *UserRepositoryMockGetUserCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &UserRepositoryMockGetUserCall{DependencyCall: call}
}

// UserRepositoryMockSaveUserArgs holds typed arguments for SaveUser.
type UserRepositoryMockSaveUserArgs struct {
	Ctx  context.Context
	User named.User
}

// UserRepositoryMockSaveUserCall wraps DependencyCall with typed GetArgs and Return.
type UserRepositoryMockSaveUserCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *UserRepositoryMockSaveUserCall) GetArgs() UserRepositoryMockSaveUserArgs {
	raw := c.RawArgs()
	return UserRepositoryMockSaveUserArgs{
		Ctx:  raw[0].(context.Context),
		User: raw[1].(named.User),
	}
}

// Return specifies the typed values the mock should return.
func (c *UserRepositoryMockSaveUserCall) Return(result0 named.User, result1 error) {
	c.DependencyCall.Return(result0, result1)
}

// UserRepositoryMockSaveUserMethod wraps DependencyMethod with typed returns.
type UserRepositoryMockSaveUserMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *UserRepositoryMockSaveUserMethod) ArgsEqual(ctx context.Context, user named.User) *UserRepositoryMockSaveUserCall {
	call := m.DependencyMethod.ArgsEqual(ctx, user)
	return &UserRepositoryMockSaveUserCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *UserRepositoryMockSaveUserMethod) ArgsShould(matchers ...any) *UserRepositoryMockSaveUserCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &UserRepositoryMockSaveUserCall{DependencyCall: call}
}

// MockUserRepository creates a mock UserRepository and returns (mock, expectation handle).
func MockUserRepository(t _imptest.TestReporter) (named.UserRepository, *UserRepositoryImp) {
	ctrl := _imptest.GetOrCreateImp(t)
	imp := &UserRepositoryImp{
		GetUser:    newUserRepositoryMockGetUserMethod(_imptest.NewDependencyMethod(ctrl, "GetUser")),
		SaveUser:   newUserRepositoryMockSaveUserMethod(_imptest.NewDependencyMethod(ctrl, "SaveUser")),
		DeleteUser: newUserRepositoryMockDeleteUserMethod(_imptest.NewDependencyMethod(ctrl, "DeleteUser")),
		CountUsers: newUserRepositoryMockCountUsersMethod(_imptest.NewDependencyMethod(ctrl, "CountUsers")),
	}
	imp.Eventually = &UserRepositoryImpEventually{
		GetUser:    newUserRepositoryMockGetUserMethod(_imptest.NewDependencyMethod(ctrl, "GetUser").AsEventually()),
		SaveUser:   newUserRepositoryMockSaveUserMethod(_imptest.NewDependencyMethod(ctrl, "SaveUser").AsEventually()),
		DeleteUser: newUserRepositoryMockDeleteUserMethod(_imptest.NewDependencyMethod(ctrl, "DeleteUser").AsEventually()),
		CountUsers: newUserRepositoryMockCountUsersMethod(_imptest.NewDependencyMethod(ctrl, "CountUsers").AsEventually()),
	}
	mock := &mockUserRepositoryImpl{ctrl: ctrl}
	return mock, imp
}

// mockUserRepositoryImpl implements named.UserRepository.
type mockUserRepositoryImpl struct {
	ctrl *_imptest.Imp
}

// CountUsers implements named.UserRepository.CountUsers.
func (impl *mockUserRepositoryImpl) CountUsers(ctx context.Context) (int, error) {
	call := &_imptest.GenericCall{
		MethodName:   "CountUsers",
		Args:         []any{ctx},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 int
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(int); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// DeleteUser implements named.UserRepository.DeleteUser.
func (impl *mockUserRepositoryImpl) DeleteUser(ctx context.Context, userID int) error {
	call := &_imptest.GenericCall{
		MethodName:   "DeleteUser",
		Args:         []any{ctx, userID},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}

// GetUser implements named.UserRepository.GetUser.
func (impl *mockUserRepositoryImpl) GetUser(ctx context.Context, userID int) (named.User, error) {
	call := &_imptest.GenericCall{
		MethodName:   "GetUser",
		Args:         []any{ctx, userID},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 named.User
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(named.User); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// SaveUser implements named.UserRepository.SaveUser.
func (impl *mockUserRepositoryImpl) SaveUser(ctx context.Context, user named.User) (named.User, error) {
	call := &_imptest.GenericCall{
		MethodName:   "SaveUser",
		Args:         []any{ctx, user},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 named.User
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(named.User); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// newUserRepositoryMockCountUsersMethod creates a typed method wrapper.
func newUserRepositoryMockCountUsersMethod(dm *_imptest.DependencyMethod) *UserRepositoryMockCountUsersMethod {
	return &UserRepositoryMockCountUsersMethod{DependencyMethod: dm}
}

// newUserRepositoryMockDeleteUserMethod creates a typed method wrapper.
func newUserRepositoryMockDeleteUserMethod(dm *_imptest.DependencyMethod) *UserRepositoryMockDeleteUserMethod {
	return &UserRepositoryMockDeleteUserMethod{DependencyMethod: dm}
}

// newUserRepositoryMockGetUserMethod creates a typed method wrapper.
func newUserRepositoryMockGetUserMethod(dm *_imptest.DependencyMethod) *UserRepositoryMockGetUserMethod {
	return &UserRepositoryMockGetUserMethod{DependencyMethod: dm}
}

// newUserRepositoryMockSaveUserMethod creates a typed method wrapper.
func newUserRepositoryMockSaveUserMethod(dm *_imptest.DependencyMethod) *UserRepositoryMockSaveUserMethod {
	return &UserRepositoryMockSaveUserMethod{DependencyMethod: dm}
}
