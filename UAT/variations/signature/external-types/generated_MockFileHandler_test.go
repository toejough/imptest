// Code generated by impgen. DO NOT EDIT.
// impgen:hash:6f5e7694f88d668e

package externalimports_test

import (
	_imptest "github.com/toejough/imptest"
	externalimports "github.com/toejough/imptest/UAT/variations/signature/external-types"
	io "io"
	os "os"
)

type FileHandlerImp struct {
	ReadAll  *FileHandlerMockReadAllMethod
	OpenFile *FileHandlerMockOpenFileMethod
	Stats    *FileHandlerMockStatsMethod
	// Eventually provides async versions of all methods for concurrent code.
	Eventually *FileHandlerImpEventually
}

type FileHandlerImpEventually struct {
	ReadAll  *FileHandlerMockReadAllMethod
	OpenFile *FileHandlerMockOpenFileMethod
	Stats    *FileHandlerMockStatsMethod
}

type FileHandlerMockOpenFileArgs struct {
	Path string
	Mode os.FileMode
}

type FileHandlerMockOpenFileCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileHandlerMockOpenFileCall) GetArgs() FileHandlerMockOpenFileArgs {
	raw := c.RawArgs()
	return FileHandlerMockOpenFileArgs{
		Path: raw[0].(string),
		Mode: raw[1].(os.FileMode),
	}
}

// Return specifies the typed values the mock should return.
func (c *FileHandlerMockOpenFileCall) Return(result0 *os.File, result1 error) {
	c.DependencyCall.Return(result0, result1)
}

type FileHandlerMockOpenFileMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *FileHandlerMockOpenFileMethod) ArgsEqual(path string, mode os.FileMode) *FileHandlerMockOpenFileCall {
	call := m.DependencyMethod.ArgsEqual(path, mode)
	return &FileHandlerMockOpenFileCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *FileHandlerMockOpenFileMethod) ArgsShould(matchers ...any) *FileHandlerMockOpenFileCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &FileHandlerMockOpenFileCall{DependencyCall: call}
}

type FileHandlerMockReadAllArgs struct {
	R io.Reader
}

type FileHandlerMockReadAllCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileHandlerMockReadAllCall) GetArgs() FileHandlerMockReadAllArgs {
	raw := c.RawArgs()
	return FileHandlerMockReadAllArgs{
		R: raw[0].(io.Reader),
	}
}

// Return specifies the typed values the mock should return.
func (c *FileHandlerMockReadAllCall) Return(result0 []byte, result1 error) {
	c.DependencyCall.Return(result0, result1)
}

type FileHandlerMockReadAllMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *FileHandlerMockReadAllMethod) ArgsEqual(r io.Reader) *FileHandlerMockReadAllCall {
	call := m.DependencyMethod.ArgsEqual(r)
	return &FileHandlerMockReadAllCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *FileHandlerMockReadAllMethod) ArgsShould(matchers ...any) *FileHandlerMockReadAllCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &FileHandlerMockReadAllCall{DependencyCall: call}
}

type FileHandlerMockStatsArgs struct {
	Path string
}

type FileHandlerMockStatsCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileHandlerMockStatsCall) GetArgs() FileHandlerMockStatsArgs {
	raw := c.RawArgs()
	return FileHandlerMockStatsArgs{
		Path: raw[0].(string),
	}
}

// Return specifies the typed values the mock should return.
func (c *FileHandlerMockStatsCall) Return(result0 os.FileInfo, result1 error) {
	c.DependencyCall.Return(result0, result1)
}

type FileHandlerMockStatsMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *FileHandlerMockStatsMethod) ArgsEqual(path string) *FileHandlerMockStatsCall {
	call := m.DependencyMethod.ArgsEqual(path)
	return &FileHandlerMockStatsCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *FileHandlerMockStatsMethod) ArgsShould(matchers ...any) *FileHandlerMockStatsCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &FileHandlerMockStatsCall{DependencyCall: call}
}

// MockFileHandler creates a mock FileHandler and returns (mock, expectation handle).
func MockFileHandler(t _imptest.TestReporter) (externalimports.FileHandler, *FileHandlerImp) {
	ctrl := _imptest.GetOrCreateImp(t)
	imp := &FileHandlerImp{
		ReadAll:  newFileHandlerMockReadAllMethod(_imptest.NewDependencyMethod(ctrl, "ReadAll")),
		OpenFile: newFileHandlerMockOpenFileMethod(_imptest.NewDependencyMethod(ctrl, "OpenFile")),
		Stats:    newFileHandlerMockStatsMethod(_imptest.NewDependencyMethod(ctrl, "Stats")),
	}
	imp.Eventually = &FileHandlerImpEventually{
		ReadAll:  newFileHandlerMockReadAllMethod(_imptest.NewDependencyMethod(ctrl, "ReadAll").AsEventually()),
		OpenFile: newFileHandlerMockOpenFileMethod(_imptest.NewDependencyMethod(ctrl, "OpenFile").AsEventually()),
		Stats:    newFileHandlerMockStatsMethod(_imptest.NewDependencyMethod(ctrl, "Stats").AsEventually()),
	}
	mock := &mockFileHandlerImpl{ctrl: ctrl}
	return mock, imp
}

type mockFileHandlerImpl struct {
	ctrl *_imptest.Imp
}

// OpenFile implements externalimports.FileHandler.OpenFile.
func (impl *mockFileHandlerImpl) OpenFile(path string, mode os.FileMode) (*os.File, error) {
	call := &_imptest.GenericCall{
		MethodName:   "OpenFile",
		Args:         []any{path, mode},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 *os.File
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(*os.File); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// ReadAll implements externalimports.FileHandler.ReadAll.
func (impl *mockFileHandlerImpl) ReadAll(r io.Reader) ([]byte, error) {
	call := &_imptest.GenericCall{
		MethodName:   "ReadAll",
		Args:         []any{r},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 []byte
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].([]byte); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// Stats implements externalimports.FileHandler.Stats.
func (impl *mockFileHandlerImpl) Stats(path string) (os.FileInfo, error) {
	call := &_imptest.GenericCall{
		MethodName:   "Stats",
		Args:         []any{path},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 os.FileInfo
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(os.FileInfo); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// newFileHandlerMockOpenFileMethod creates a typed method wrapper.
func newFileHandlerMockOpenFileMethod(dm *_imptest.DependencyMethod) *FileHandlerMockOpenFileMethod {
	return &FileHandlerMockOpenFileMethod{DependencyMethod: dm}
}

// newFileHandlerMockReadAllMethod creates a typed method wrapper.
func newFileHandlerMockReadAllMethod(dm *_imptest.DependencyMethod) *FileHandlerMockReadAllMethod {
	return &FileHandlerMockReadAllMethod{DependencyMethod: dm}
}

// newFileHandlerMockStatsMethod creates a typed method wrapper.
func newFileHandlerMockStatsMethod(dm *_imptest.DependencyMethod) *FileHandlerMockStatsMethod {
	return &FileHandlerMockStatsMethod{DependencyMethod: dm}
}
