// Code generated by impgen. DO NOT EDIT.

package externalimports_test

import (
	externalimports "github.com/toejough/imptest/UAT/variations/signature/external-types"
	_imptest "github.com/toejough/imptest/imptest"
	io "io"
	os "os"
)

// FileHandlerMockHandle is the test handle for FileHandler.
type FileHandlerMockHandle struct {
	Mock       externalimports.FileHandler
	Method     *FileHandlerMockMethods
	Controller *_imptest.Imp
}

// FileHandlerMockMethods holds method wrappers for setting expectations.
type FileHandlerMockMethods struct {
	ReadAll  *FileHandlerMockReadAllMethod
	OpenFile *FileHandlerMockOpenFileMethod
	Stats    *FileHandlerMockStatsMethod
}

// FileHandlerMockOpenFileArgs holds typed arguments for OpenFile.
type FileHandlerMockOpenFileArgs struct {
	Path string
	Mode os.FileMode
}

// FileHandlerMockOpenFileCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type FileHandlerMockOpenFileCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileHandlerMockOpenFileCall) GetArgs() FileHandlerMockOpenFileArgs {
	raw := c.RawArgs()
	return FileHandlerMockOpenFileArgs{
		Path: raw[0].(string),
		Mode: raw[1].(os.FileMode),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *FileHandlerMockOpenFileCall) InjectReturnValues(result0 *os.File, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// FileHandlerMockOpenFileMethod wraps DependencyMethod with typed returns.
type FileHandlerMockOpenFileMethod struct {
	*_imptest.DependencyMethod
	// Eventually is the async version of this method for concurrent code.
	Eventually *FileHandlerMockOpenFileMethod
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *FileHandlerMockOpenFileMethod) ExpectCalledWithExactly(path string, mode os.FileMode) *FileHandlerMockOpenFileCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(path, mode)
	return &FileHandlerMockOpenFileCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *FileHandlerMockOpenFileMethod) ExpectCalledWithMatches(matchers ...any) *FileHandlerMockOpenFileCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &FileHandlerMockOpenFileCall{DependencyCall: call}
}

// FileHandlerMockReadAllArgs holds typed arguments for ReadAll.
type FileHandlerMockReadAllArgs struct {
	R io.Reader
}

// FileHandlerMockReadAllCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type FileHandlerMockReadAllCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileHandlerMockReadAllCall) GetArgs() FileHandlerMockReadAllArgs {
	raw := c.RawArgs()
	return FileHandlerMockReadAllArgs{
		R: raw[0].(io.Reader),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *FileHandlerMockReadAllCall) InjectReturnValues(result0 []byte, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// FileHandlerMockReadAllMethod wraps DependencyMethod with typed returns.
type FileHandlerMockReadAllMethod struct {
	*_imptest.DependencyMethod
	// Eventually is the async version of this method for concurrent code.
	Eventually *FileHandlerMockReadAllMethod
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *FileHandlerMockReadAllMethod) ExpectCalledWithExactly(r io.Reader) *FileHandlerMockReadAllCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(r)
	return &FileHandlerMockReadAllCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *FileHandlerMockReadAllMethod) ExpectCalledWithMatches(matchers ...any) *FileHandlerMockReadAllCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &FileHandlerMockReadAllCall{DependencyCall: call}
}

// FileHandlerMockStatsArgs holds typed arguments for Stats.
type FileHandlerMockStatsArgs struct {
	Path string
}

// FileHandlerMockStatsCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type FileHandlerMockStatsCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *FileHandlerMockStatsCall) GetArgs() FileHandlerMockStatsArgs {
	raw := c.RawArgs()
	return FileHandlerMockStatsArgs{
		Path: raw[0].(string),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *FileHandlerMockStatsCall) InjectReturnValues(result0 os.FileInfo, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// FileHandlerMockStatsMethod wraps DependencyMethod with typed returns.
type FileHandlerMockStatsMethod struct {
	*_imptest.DependencyMethod
	// Eventually is the async version of this method for concurrent code.
	Eventually *FileHandlerMockStatsMethod
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *FileHandlerMockStatsMethod) ExpectCalledWithExactly(path string) *FileHandlerMockStatsCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(path)
	return &FileHandlerMockStatsCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *FileHandlerMockStatsMethod) ExpectCalledWithMatches(matchers ...any) *FileHandlerMockStatsCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &FileHandlerMockStatsCall{DependencyCall: call}
}

// MockFileHandler creates a new FileHandlerMockHandle for testing.
func MockFileHandler(t _imptest.TestReporter) *FileHandlerMockHandle {
	ctrl := _imptest.NewImp(t)
	methods := &FileHandlerMockMethods{
		ReadAll:  newFileHandlerMockReadAllMethod(_imptest.NewDependencyMethod(ctrl, "ReadAll")),
		OpenFile: newFileHandlerMockOpenFileMethod(_imptest.NewDependencyMethod(ctrl, "OpenFile")),
		Stats:    newFileHandlerMockStatsMethod(_imptest.NewDependencyMethod(ctrl, "Stats")),
	}
	h := &FileHandlerMockHandle{
		Method:     methods,
		Controller: ctrl,
	}
	h.Mock = &mockFileHandlerImpl{handle: h}
	return h
}

// mockFileHandlerImpl implements externalimports.FileHandler.
type mockFileHandlerImpl struct {
	handle *FileHandlerMockHandle
}

// OpenFile implements externalimports.FileHandler.OpenFile.
func (impl *mockFileHandlerImpl) OpenFile(path string, mode os.FileMode) (*os.File, error) {
	call := &_imptest.GenericCall{
		MethodName:   "OpenFile",
		Args:         []any{path, mode},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.handle.Controller.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 *os.File
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(*os.File); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// ReadAll implements externalimports.FileHandler.ReadAll.
func (impl *mockFileHandlerImpl) ReadAll(r io.Reader) ([]byte, error) {
	call := &_imptest.GenericCall{
		MethodName:   "ReadAll",
		Args:         []any{r},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.handle.Controller.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 []byte
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].([]byte); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// Stats implements externalimports.FileHandler.Stats.
func (impl *mockFileHandlerImpl) Stats(path string) (os.FileInfo, error) {
	call := &_imptest.GenericCall{
		MethodName:   "Stats",
		Args:         []any{path},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.handle.Controller.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 os.FileInfo
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(os.FileInfo); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// newFileHandlerMockOpenFileMethod creates a typed method wrapper with Eventually initialized.
func newFileHandlerMockOpenFileMethod(dm *_imptest.DependencyMethod) *FileHandlerMockOpenFileMethod {
	m := &FileHandlerMockOpenFileMethod{DependencyMethod: dm}
	m.Eventually = &FileHandlerMockOpenFileMethod{DependencyMethod: dm.Eventually}
	return m
}

// newFileHandlerMockReadAllMethod creates a typed method wrapper with Eventually initialized.
func newFileHandlerMockReadAllMethod(dm *_imptest.DependencyMethod) *FileHandlerMockReadAllMethod {
	m := &FileHandlerMockReadAllMethod{DependencyMethod: dm}
	m.Eventually = &FileHandlerMockReadAllMethod{DependencyMethod: dm.Eventually}
	return m
}

// newFileHandlerMockStatsMethod creates a typed method wrapper with Eventually initialized.
func newFileHandlerMockStatsMethod(dm *_imptest.DependencyMethod) *FileHandlerMockStatsMethod {
	m := &FileHandlerMockStatsMethod{DependencyMethod: dm}
	m.Eventually = &FileHandlerMockStatsMethod{DependencyMethod: dm.Eventually}
	return m
}
