// Code generated by impgen. DO NOT EDIT.
// impgen:hash:0b792b5ac5b03687

package service_test

import (
	_imptest "github.com/toejough/imptest"
	storage "github.com/toejough/imptest/UAT/variations/package/dot-imports/business/storage"
)

// RepositoryImp holds method wrappers for setting expectations on Repository.
type RepositoryImp struct {
	Save   *RepositoryMockSaveMethod
	Load   *RepositoryMockLoadMethod
	Delete *RepositoryMockDeleteMethod
	// Eventually provides async versions of all methods for concurrent code.
	Eventually *RepositoryImpEventually
}

// RepositoryImpEventually holds async method wrappers for Repository.
type RepositoryImpEventually struct {
	Save   *RepositoryMockSaveMethod
	Load   *RepositoryMockLoadMethod
	Delete *RepositoryMockDeleteMethod
}

// RepositoryMockDeleteArgs holds typed arguments for Delete.
type RepositoryMockDeleteArgs struct {
	Key string
}

// RepositoryMockDeleteCall wraps DependencyCall with typed GetArgs and Return.
type RepositoryMockDeleteCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RepositoryMockDeleteCall) GetArgs() RepositoryMockDeleteArgs {
	raw := c.RawArgs()
	return RepositoryMockDeleteArgs{
		Key: raw[0].(string),
	}
}

// Return specifies the typed values the mock should return.
func (c *RepositoryMockDeleteCall) Return(result0 error) {
	c.DependencyCall.Return(result0)
}

// RepositoryMockDeleteMethod wraps DependencyMethod with typed returns.
type RepositoryMockDeleteMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *RepositoryMockDeleteMethod) ArgsEqual(key string) *RepositoryMockDeleteCall {
	call := m.DependencyMethod.ArgsEqual(key)
	return &RepositoryMockDeleteCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *RepositoryMockDeleteMethod) ArgsShould(matchers ...any) *RepositoryMockDeleteCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &RepositoryMockDeleteCall{DependencyCall: call}
}

// RepositoryMockLoadArgs holds typed arguments for Load.
type RepositoryMockLoadArgs struct {
	Key string
}

// RepositoryMockLoadCall wraps DependencyCall with typed GetArgs and Return.
type RepositoryMockLoadCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RepositoryMockLoadCall) GetArgs() RepositoryMockLoadArgs {
	raw := c.RawArgs()
	return RepositoryMockLoadArgs{
		Key: raw[0].(string),
	}
}

// Return specifies the typed values the mock should return.
func (c *RepositoryMockLoadCall) Return(result0 []byte, result1 error) {
	c.DependencyCall.Return(result0, result1)
}

// RepositoryMockLoadMethod wraps DependencyMethod with typed returns.
type RepositoryMockLoadMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *RepositoryMockLoadMethod) ArgsEqual(key string) *RepositoryMockLoadCall {
	call := m.DependencyMethod.ArgsEqual(key)
	return &RepositoryMockLoadCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *RepositoryMockLoadMethod) ArgsShould(matchers ...any) *RepositoryMockLoadCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &RepositoryMockLoadCall{DependencyCall: call}
}

// RepositoryMockSaveArgs holds typed arguments for Save.
type RepositoryMockSaveArgs struct {
	Key  string
	Data []byte
}

// RepositoryMockSaveCall wraps DependencyCall with typed GetArgs and Return.
type RepositoryMockSaveCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RepositoryMockSaveCall) GetArgs() RepositoryMockSaveArgs {
	raw := c.RawArgs()
	return RepositoryMockSaveArgs{
		Key:  raw[0].(string),
		Data: raw[1].([]byte),
	}
}

// Return specifies the typed values the mock should return.
func (c *RepositoryMockSaveCall) Return(result0 error) {
	c.DependencyCall.Return(result0)
}

// RepositoryMockSaveMethod wraps DependencyMethod with typed returns.
type RepositoryMockSaveMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *RepositoryMockSaveMethod) ArgsEqual(key string, data []byte) *RepositoryMockSaveCall {
	call := m.DependencyMethod.ArgsEqual(key, data)
	return &RepositoryMockSaveCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *RepositoryMockSaveMethod) ArgsShould(matchers ...any) *RepositoryMockSaveCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &RepositoryMockSaveCall{DependencyCall: call}
}

// MockRepository creates a mock Repository and returns (mock, expectation handle).
func MockRepository(t _imptest.TestReporter) (storage.Repository, *RepositoryImp) {
	ctrl := _imptest.GetOrCreateImp(t)
	imp := &RepositoryImp{
		Save:   newRepositoryMockSaveMethod(_imptest.NewDependencyMethod(ctrl, "Save")),
		Load:   newRepositoryMockLoadMethod(_imptest.NewDependencyMethod(ctrl, "Load")),
		Delete: newRepositoryMockDeleteMethod(_imptest.NewDependencyMethod(ctrl, "Delete")),
	}
	imp.Eventually = &RepositoryImpEventually{
		Save:   newRepositoryMockSaveMethod(_imptest.NewDependencyMethod(ctrl, "Save").AsEventually()),
		Load:   newRepositoryMockLoadMethod(_imptest.NewDependencyMethod(ctrl, "Load").AsEventually()),
		Delete: newRepositoryMockDeleteMethod(_imptest.NewDependencyMethod(ctrl, "Delete").AsEventually()),
	}
	mock := &mockRepositoryImpl{ctrl: ctrl}
	return mock, imp
}

// mockRepositoryImpl implements storage.Repository.
type mockRepositoryImpl struct {
	ctrl *_imptest.Imp
}

// Delete implements storage.Repository.Delete.
func (impl *mockRepositoryImpl) Delete(key string) error {
	call := &_imptest.GenericCall{
		MethodName:   "Delete",
		Args:         []any{key},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}

// Load implements storage.Repository.Load.
func (impl *mockRepositoryImpl) Load(key string) ([]byte, error) {
	call := &_imptest.GenericCall{
		MethodName:   "Load",
		Args:         []any{key},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 []byte
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].([]byte); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// Save implements storage.Repository.Save.
func (impl *mockRepositoryImpl) Save(key string, data []byte) error {
	call := &_imptest.GenericCall{
		MethodName:   "Save",
		Args:         []any{key, data},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}

// newRepositoryMockDeleteMethod creates a typed method wrapper.
func newRepositoryMockDeleteMethod(dm *_imptest.DependencyMethod) *RepositoryMockDeleteMethod {
	return &RepositoryMockDeleteMethod{DependencyMethod: dm}
}

// newRepositoryMockLoadMethod creates a typed method wrapper.
func newRepositoryMockLoadMethod(dm *_imptest.DependencyMethod) *RepositoryMockLoadMethod {
	return &RepositoryMockLoadMethod{DependencyMethod: dm}
}

// newRepositoryMockSaveMethod creates a typed method wrapper.
func newRepositoryMockSaveMethod(dm *_imptest.DependencyMethod) *RepositoryMockSaveMethod {
	return &RepositoryMockSaveMethod{DependencyMethod: dm}
}
