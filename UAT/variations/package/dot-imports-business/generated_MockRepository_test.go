// Code generated by impgen. DO NOT EDIT.

package service_test

import (
	storage "github.com/toejough/imptest/UAT/variations/package/dot-imports-business/storage"
	_imptest "github.com/toejough/imptest/imptest"
)

// RepositoryMockDeleteArgs holds typed arguments for Delete.
type RepositoryMockDeleteArgs struct {
	Key string
}

// RepositoryMockDeleteCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type RepositoryMockDeleteCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RepositoryMockDeleteCall) GetArgs() RepositoryMockDeleteArgs {
	raw := c.RawArgs()
	return RepositoryMockDeleteArgs{
		Key: raw[0].(string),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *RepositoryMockDeleteCall) InjectReturnValues(result0 error) {
	c.DependencyCall.InjectReturnValues(result0)
}

// RepositoryMockDeleteMethod wraps DependencyMethod with typed returns.
type RepositoryMockDeleteMethod struct {
	*_imptest.DependencyMethod
	// Eventually is the async version of this method for concurrent code.
	Eventually *RepositoryMockDeleteMethod
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *RepositoryMockDeleteMethod) ExpectCalledWithExactly(key string) *RepositoryMockDeleteCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(key)
	return &RepositoryMockDeleteCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *RepositoryMockDeleteMethod) ExpectCalledWithMatches(matchers ...any) *RepositoryMockDeleteCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &RepositoryMockDeleteCall{DependencyCall: call}
}

// RepositoryMockHandle is the test handle for Repository.
type RepositoryMockHandle struct {
	Mock       storage.Repository
	Method     *RepositoryMockMethods
	Controller *_imptest.Imp
}

// RepositoryMockLoadArgs holds typed arguments for Load.
type RepositoryMockLoadArgs struct {
	Key string
}

// RepositoryMockLoadCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type RepositoryMockLoadCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RepositoryMockLoadCall) GetArgs() RepositoryMockLoadArgs {
	raw := c.RawArgs()
	return RepositoryMockLoadArgs{
		Key: raw[0].(string),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *RepositoryMockLoadCall) InjectReturnValues(result0 []byte, result1 error) {
	c.DependencyCall.InjectReturnValues(result0, result1)
}

// RepositoryMockLoadMethod wraps DependencyMethod with typed returns.
type RepositoryMockLoadMethod struct {
	*_imptest.DependencyMethod
	// Eventually is the async version of this method for concurrent code.
	Eventually *RepositoryMockLoadMethod
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *RepositoryMockLoadMethod) ExpectCalledWithExactly(key string) *RepositoryMockLoadCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(key)
	return &RepositoryMockLoadCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *RepositoryMockLoadMethod) ExpectCalledWithMatches(matchers ...any) *RepositoryMockLoadCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &RepositoryMockLoadCall{DependencyCall: call}
}

// RepositoryMockMethods holds method wrappers for setting expectations.
type RepositoryMockMethods struct {
	Save   *RepositoryMockSaveMethod
	Load   *RepositoryMockLoadMethod
	Delete *RepositoryMockDeleteMethod
}

// RepositoryMockSaveArgs holds typed arguments for Save.
type RepositoryMockSaveArgs struct {
	Key  string
	Data []byte
}

// RepositoryMockSaveCall wraps DependencyCall with typed GetArgs and InjectReturnValues.
type RepositoryMockSaveCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RepositoryMockSaveCall) GetArgs() RepositoryMockSaveArgs {
	raw := c.RawArgs()
	return RepositoryMockSaveArgs{
		Key:  raw[0].(string),
		Data: raw[1].([]byte),
	}
}

// InjectReturnValues specifies the typed values the mock should return.
func (c *RepositoryMockSaveCall) InjectReturnValues(result0 error) {
	c.DependencyCall.InjectReturnValues(result0)
}

// RepositoryMockSaveMethod wraps DependencyMethod with typed returns.
type RepositoryMockSaveMethod struct {
	*_imptest.DependencyMethod
	// Eventually is the async version of this method for concurrent code.
	Eventually *RepositoryMockSaveMethod
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *RepositoryMockSaveMethod) ExpectCalledWithExactly(key string, data []byte) *RepositoryMockSaveCall {
	call := m.DependencyMethod.ExpectCalledWithExactly(key, data)
	return &RepositoryMockSaveCall{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *RepositoryMockSaveMethod) ExpectCalledWithMatches(matchers ...any) *RepositoryMockSaveCall {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &RepositoryMockSaveCall{DependencyCall: call}
}

// MockRepository creates a new RepositoryMockHandle for testing.
func MockRepository(t _imptest.TestReporter) *RepositoryMockHandle {
	ctrl := _imptest.NewImp(t)
	methods := &RepositoryMockMethods{
		Save:   newRepositoryMockSaveMethod(_imptest.NewDependencyMethod(ctrl, "Save")),
		Load:   newRepositoryMockLoadMethod(_imptest.NewDependencyMethod(ctrl, "Load")),
		Delete: newRepositoryMockDeleteMethod(_imptest.NewDependencyMethod(ctrl, "Delete")),
	}
	h := &RepositoryMockHandle{
		Method:     methods,
		Controller: ctrl,
	}
	h.Mock = &mockRepositoryImpl{handle: h}
	return h
}

// mockRepositoryImpl implements storage.Repository.
type mockRepositoryImpl struct {
	handle *RepositoryMockHandle
}

// Delete implements storage.Repository.Delete.
func (impl *mockRepositoryImpl) Delete(key string) error {
	call := &_imptest.GenericCall{
		MethodName:   "Delete",
		Args:         []any{key},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.handle.Controller.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}

// Load implements storage.Repository.Load.
func (impl *mockRepositoryImpl) Load(key string) ([]byte, error) {
	call := &_imptest.GenericCall{
		MethodName:   "Load",
		Args:         []any{key},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.handle.Controller.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 []byte
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].([]byte); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// Save implements storage.Repository.Save.
func (impl *mockRepositoryImpl) Save(key string, data []byte) error {
	call := &_imptest.GenericCall{
		MethodName:   "Save",
		Args:         []any{key, data},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.handle.Controller.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 error
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(error); ok {
			result1 = value
		}
	}

	return result1
}

// newRepositoryMockDeleteMethod creates a typed method wrapper with Eventually initialized.
func newRepositoryMockDeleteMethod(dm *_imptest.DependencyMethod) *RepositoryMockDeleteMethod {
	m := &RepositoryMockDeleteMethod{DependencyMethod: dm}
	m.Eventually = &RepositoryMockDeleteMethod{DependencyMethod: dm.Eventually}
	return m
}

// newRepositoryMockLoadMethod creates a typed method wrapper with Eventually initialized.
func newRepositoryMockLoadMethod(dm *_imptest.DependencyMethod) *RepositoryMockLoadMethod {
	m := &RepositoryMockLoadMethod{DependencyMethod: dm}
	m.Eventually = &RepositoryMockLoadMethod{DependencyMethod: dm.Eventually}
	return m
}

// newRepositoryMockSaveMethod creates a typed method wrapper with Eventually initialized.
func newRepositoryMockSaveMethod(dm *_imptest.DependencyMethod) *RepositoryMockSaveMethod {
	m := &RepositoryMockSaveMethod{DependencyMethod: dm}
	m.Eventually = &RepositoryMockSaveMethod{DependencyMethod: dm.Eventually}
	return m
}
