//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/go/ssa"
)

func main() {
	info := getGeneratorInfo()
	if info.pkgName == "" {
		fmt.Println("  GOPACKAGE not set; cannot search package")
		return
	}

	astFiles, fset := parsePackageFiles(info.pkgDir)

	// Pretty print the AST of the GOFILE
	if info.goFilePath != "" {
		data, err := os.ReadFile(info.goFilePath)
		if err == nil {
			fsetSingle := token.NewFileSet()
			fileAst, err := parser.ParseFile(fsetSingle, info.goFilePath, data, parser.ParseComments)
			if err == nil {
				fmt.Printf("----- AST tree of %s -----\n", info.goFilePath)
				printAstTree(fileAst, "")
				fmt.Printf("----- end AST tree %s -----\n", info.goFilePath)
			}
		}
	}

	// Pretty print the SSA form of the package
	printPackageSSA(info.pkgDir)

	// Pretty print all interfaces in the package
	fmt.Printf("----- All interfaces in package %s -----\n", info.pkgName)
	for _, fileAst := range astFiles {
		ast.Inspect(fileAst, func(n ast.Node) bool {
			ts, ok := n.(*ast.TypeSpec)
			if ok {
				if iface, ok2 := ts.Type.(*ast.InterfaceType); ok2 {
					fmt.Printf("*ast.TypeSpec (Name: %q)\n", ts.Name.Name)
					printAstTree(iface, "  ")
					return false
				}
			}
			return true
		})
	}
	fmt.Printf("----- end interfaces in package %s -----\n", info.pkgName)

	iface := findInterfaceInPackage(astFiles, info.matchName)
	writeImplementationFile(iface, info, fset)
}

// getGeneratorInfo gathers basic information about the generator call
func getGeneratorInfo() struct {
	cwd, pkgDir, pkgName, goFilePath, matchName string
} {
	cwd, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	pkgName := os.Getenv("GOPACKAGE")
	goFile := os.Getenv("GOFILE")
	goFilePath := ""
	if goFile != "" {
		if filepath.IsAbs(goFile) {
			goFilePath = goFile
		} else {
			goFilePath = filepath.Join(cwd, goFile)
		}
	}
	pkgDir := cwd // assume current dir is the package dir
	matchName := ""
	if len(os.Args) > 0 {
		matchName = os.Args[len(os.Args)-1]
	}
	return struct {
		cwd, pkgDir, pkgName, goFilePath, matchName string
	}{cwd, pkgDir, pkgName, goFilePath, matchName}
}

// parsePackageFiles reads and parses all Go files in the package directory
func parsePackageFiles(pkgDir string) ([]*ast.File, *token.FileSet) {
	entries, err := os.ReadDir(pkgDir)
	if err != nil {
		fmt.Printf("  error reading package dir %q: %v\n", pkgDir, err)
		return nil, token.NewFileSet()
	}
	var files []string
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		if len(name) > 3 && name[len(name)-3:] == ".go" && name != "generated.go" {
			files = append(files, filepath.Join(pkgDir, name))
		}
	}
	fset := token.NewFileSet()
	var astFiles []*ast.File
	for _, file := range files {
		data, err := os.ReadFile(file)
		if err != nil {
			fmt.Printf("  error reading file %q: %v\n", file, err)
			continue
		}
		f, err := parser.ParseFile(fset, file, data, parser.ParseComments)
		if err != nil {
			fmt.Printf("  error parsing file %q: %v\n", file, err)
			continue
		}
		astFiles = append(astFiles, f)
	}
	return astFiles, fset
}

// findInterfaceInPackage searches for the interface by name in the package ASTs
func findInterfaceInPackage(astFiles []*ast.File, matchName string) *ast.InterfaceType {
	for _, fileAst := range astFiles {
		var found *ast.InterfaceType
		ast.Inspect(fileAst, func(n ast.Node) bool {
			ts, ok := n.(*ast.TypeSpec)
			if ok {
				if iface, ok2 := ts.Type.(*ast.InterfaceType); ok2 && ts.Name.Name == matchName {
					found = iface
					return false
				}
			}
			return true
		})
		if found != nil {
			return found
		}
	}
	return nil
}

// writeImplementationFile writes the implementation of the found interface to generated.go
func writeImplementationFile(identifiedInterface *ast.InterfaceType, info struct {
	cwd, pkgDir, pkgName, goFilePath, matchName string
}, fset *token.FileSet) {
	if identifiedInterface == nil {
		fmt.Printf("No interface named %q found in package.\n", info.matchName)
		return
	}
	var buf bytes.Buffer
	buf.WriteString("package main\n\n")
	buf.WriteString("// Code generated by generate.go. DO NOT EDIT.\n\n")
	buf.WriteString("type interfaceImplementation struct{}\n\n")
	for _, field := range identifiedInterface.Methods.List {
		if len(field.Names) == 0 {
			continue
		}
		for _, name := range field.Names {
			ftype, ok := field.Type.(*ast.FuncType)
			if !ok {
				continue
			}
			buf.WriteString("func (interfaceImplementation) ")
			buf.WriteString(name.Name)
			buf.WriteString(renderFieldList(fset, ftype.Params, true))
			buf.WriteString(renderFieldList(fset, ftype.Results, false))
			buf.WriteString(" { panic(\"not implemented\") }\n\n")
		}
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("error formatting generated code: %v\n", err)
		return
	}
	if err := os.WriteFile("generated.go", formatted, 0644); err != nil {
		fmt.Printf("error writing generated.go: %v\n", err)
		return
	}
	fmt.Println("generated.go written successfully.")
}

// printAstTree recursively prints the AST node tree with indentation
func printAstTree(node interface{}, indent string) {
	switch n := node.(type) {
	case nil:
		return
	case *ast.Ident:
		typeName := fmt.Sprintf("%T", n)
		fmt.Printf("%s%s (Name: %q)\n", indent, typeName, n.Name)
		return
	case ast.Node:
		typeName := fmt.Sprintf("%T", n)
		fmt.Printf("%s%s\n", indent, typeName)
		indent2 := indent + "  "
		ast.Inspect(n, func(child ast.Node) bool {
			if child != n && child != nil {
				printAstTree(child, indent2)
				return false
			}
			return true
		})
	}
}

// printTypeSpecsWithInterface prints TypeSpec nodes whose immediate child is an InterfaceType
func printTypeSpecsWithInterface(node ast.Node, indent string) {
	ast.Inspect(node, func(n ast.Node) bool {
		ts, ok := n.(*ast.TypeSpec)
		if ok {
			if iface, ok2 := ts.Type.(*ast.InterfaceType); ok2 {
				fmt.Printf("%s*ast.TypeSpec (Name: %q)\n", indent, ts.Name.Name)
				printAstTree(iface, indent+"  ")
				return false // don't descend into children again
			}
		}
		return true
	})
}

// printTypeSpecsWithInterfaceName prints TypeSpec nodes whose immediate child is an InterfaceType and whose name matches
func printTypeSpecsWithInterfaceName(node ast.Node, indent, matchName string) {
	ast.Inspect(node, func(n ast.Node) bool {
		ts, ok := n.(*ast.TypeSpec)
		if ok {
			if iface, ok2 := ts.Type.(*ast.InterfaceType); ok2 && ts.Name.Name == matchName {
				fmt.Printf("%s*ast.TypeSpec (Name: %q)\n", indent, ts.Name.Name)
				printAstTree(iface, indent+"  ")
				return false // don't descend into children again
			}
		}
		return true
	})
}

// renderFieldList renders a *ast.FieldList as Go code (params/results)
func renderFieldList(fset *token.FileSet, fl *ast.FieldList, isParams bool) string {
	if fl == nil || len(fl.List) == 0 {
		if isParams {
			return "()"
		}
		return ""
	}
	var buf bytes.Buffer
	buf.WriteString("(")
	for i, field := range fl.List {
		if i > 0 {
			buf.WriteString(", ")
		}
		// Names
		for j, name := range field.Names {
			if j > 0 {
				buf.WriteString(", ")
			}
			buf.WriteString(name.Name)
		}
		// Type
		if len(field.Names) > 0 {
			buf.WriteString(" ")
		}
		buf.WriteString(exprToString(fset, field.Type))
	}
	buf.WriteString(")")
	return buf.String()
}

// exprToString renders an ast.Expr to Go code
func exprToString(fset *token.FileSet, expr ast.Expr) string {
	var buf bytes.Buffer
	printer.Fprint(&buf, fset, expr)
	return buf.String()
}

// printPackageSSA loads and prints the SSA form of the package and its test package
func printPackageSSA(pkgDir string) {
	cfg := &packages.Config{
		Mode:  packages.LoadAllSyntax,
		Dir:   pkgDir,
		Tests: true, // Load test files as well
	}
	pkgs, err := packages.Load(cfg, ".")
	if err != nil || len(pkgs) == 0 {
		fmt.Printf("error loading package for SSA: %v\n", err)
		return
	}
	prog := ssa.NewProgram(pkgs[0].Fset, ssa.SanityCheckFunctions)
	ssaPkgs := make(map[*packages.Package]*ssa.Package)

	var createAllSSA func(pkg *packages.Package)
	createAllSSA = func(pkg *packages.Package) {
		if pkg == nil {
			return
		}
		if _, ok := ssaPkgs[pkg]; ok {
			return // already created
		}
		if pkg.Types != nil && pkg.Syntax != nil && pkg.TypesInfo != nil {
			ssaPkgs[pkg] = prog.CreatePackage(pkg.Types, pkg.Syntax, pkg.TypesInfo, true)
		}
		for _, imp := range pkg.Imports {
			createAllSSA(imp)
		}
	}
	for _, pkg := range pkgs {
		createAllSSA(pkg)
	}

	prog.Build()

	// Print SSA for main package and test package
	mainPkgPath := pkgs[0].PkgPath
	var testPkgPath string
	if len(pkgs) > 1 {
		testPkgPath = pkgs[len(pkgs)-1].PkgPath // heuristic: last is test package
	}

	for _, ssaPkg := range prog.AllPackages() {
		if ssaPkg == nil || ssaPkg.Pkg == nil {
			continue
		}
		if ssaPkg.Pkg.Path() == mainPkgPath || (testPkgPath != "" && ssaPkg.Pkg.Path() == testPkgPath) {
			fmt.Printf("----- SSA for package: %s -----\n", ssaPkg.Pkg.Path())
			for name, member := range ssaPkg.Members {
				fmt.Printf("SSA Member: %s\n", name)
				fmt.Printf("  Type: %T\n", member)
				if val, ok := member.(ssa.Value); ok {
					fmt.Printf("  SSA Type: %s\n", val.Type())
				}
				if obj := member.Object(); obj != nil {
					fmt.Printf("  Object: %s (%T)\n", obj.Name(), obj)
					if obj.Type() != nil {
						fmt.Printf("  Object Underlying Type: %s\n", obj.Type().Underlying())
					}
				}
				if fn, ok := member.(*ssa.Function); ok {
					fn.WriteTo(os.Stdout)
					fmt.Println()
				} else {
					fmt.Printf("  Value: %v\n", member)
				}
			}
			fmt.Printf("----- end SSA for package: %s -----\n", ssaPkg.Pkg.Path())
		}
	}
}
