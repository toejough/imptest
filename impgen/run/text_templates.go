package run

import (
	"bytes"
	"fmt"
	"text/template"
)

// TemplateRegistry holds all parsed text templates for code generation.
// Create a registry using NewTemplateRegistry() to initialize all templates.
type TemplateRegistry struct {
	callStructTmpl                         *template.Template
	callableConstructorTmpl                *template.Template
	callableExpectPanicWithTmpl            *template.Template
	callableExpectReturnedValuesAreTmpl    *template.Template
	callableExpectReturnedValuesShouldTmpl *template.Template
	callableHeaderTmpl                     *template.Template
	callableMainStructTmpl                 *template.Template
	callableResponseStructTmpl             *template.Template
	callableResponseTypeMethodTmpl         *template.Template
	callableReturnStructTmpl               *template.Template
	callableStartMethodTmpl                *template.Template
	constructorTmpl                        *template.Template
	expectCallIsStructTmpl                 *template.Template
	getCurrentCallMethodTmpl               *template.Template
	headerTmpl                             *template.Template
	injectPanicTmpl                        *template.Template
	interfaceVerificationTmpl              *template.Template
	mainStructTmpl                         *template.Template
	mockStructTmpl                         *template.Template
	resolveTmpl                            *template.Template
	timedStructTmpl                        *template.Template
	// V2 Dependency templates
	v2DepHeaderTmpl          *template.Template
	v2DepMockStructTmpl      *template.Template
	v2DepConstructorTmpl     *template.Template
	v2DepInterfaceMethodTmpl *template.Template
	v2DepImplStructTmpl      *template.Template
	v2DepImplMethodTmpl      *template.Template
	// V2 Target wrapper templates
	v2TargetHeaderTmpl          *template.Template
	v2TargetConstructorTmpl     *template.Template
	v2TargetWrapperStructTmpl   *template.Template
	v2TargetStartMethodTmpl     *template.Template
	v2TargetWaitMethodTmpl      *template.Template
	v2TargetExpectReturnsTmpl   *template.Template
	v2TargetExpectCompletesTmpl *template.Template
	v2TargetExpectPanicTmpl     *template.Template
	v2TargetReturnsStructTmpl   *template.Template
}

// NewTemplateRegistry creates and initializes a new template registry with all templates parsed.
//
//nolint:cyclop,funlen,maintidx // Template parsing requires comprehensive initialization
func NewTemplateRegistry() (*TemplateRegistry, error) {
	registry := &TemplateRegistry{}

	var err error

	// Header template
	//nolint:lll,nolintlint
	registry.headerTmpl, err = parseTemplate("header", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

{{if .NeedsFmt}}import {{.PkgFmt}} "fmt"
{{end}}import {{.PkgImptest}} "github.com/toejough/imptest/imptest"
{{if .NeedsReflect}}import {{.PkgReflect}} "reflect"
{{end}}import {{.PkgTesting}} "testing"
import {{.PkgTime}} "time"
{{if .NeedsQualifier}}import {{.Qualifier}} "{{.PkgPath}}"
{{end}}{{range .AdditionalImports}}import {{if .Alias}}{{.Alias}} {{end}}"{{.Path}}"
{{end}}`)
	if err != nil {
		return nil, err
	}

	// Constructor template
	//nolint:lll // Template string length driven by generated code structure
	//nolint:lll,nolintlint
	registry.constructorTmpl, err = parseTemplate("constructor", `// New{{.ImpName}} creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := New{{.ImpName}}(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func New{{.ImpName}}{{.TypeParamsDecl}}(t *{{.PkgTesting}}.T) *{{.ImpName}}{{.TypeParamsUse}} {
	imp := &{{.ImpName}}{{.TypeParamsUse}}{
		Controller: {{.PkgImptest}}.NewController[*{{.CallName}}{{.TypeParamsUse}}](t),
	}
	imp.Mock = &{{.MockName}}{{.TypeParamsUse}}{imp: imp}
	imp.ExpectCallIs = &{{.ExpectCallIsName}}{{.TypeParamsUse}}{imp: imp}
	return imp
}

`)
	if err != nil {
		return nil, err
	}

	// ExpectCallIsStruct template
	//nolint:lll // Template string length driven by generated code structure
	//nolint:lll,nolintlint
	registry.expectCallIsStructTmpl, err = parseTemplate("expectCallIsStruct", `// {{.ExpectCallIsName}} provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent {{.ImpName}} to configure timeouts.
type {{.ExpectCallIsName}}{{.TypeParamsDecl}} struct {
	imp *{{.ImpName}}{{.TypeParamsUse}}
	timeout {{.PkgTime}}.Duration
}

`)
	if err != nil {
		return nil, err
	}

	// GetCurrentCallMethod template
	//nolint:lll // Template definition
	//nolint:lll,nolintlint
	registry.getCurrentCallMethodTmpl, err = parseTemplate("getCurrentCallMethod", `// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *{{.ImpName}}{{.TypeParamsUse}}) GetCurrentCall() *{{.CallName}}{{.TypeParamsUse}} {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *{{.CallName}}{{.TypeParamsUse}}) bool { return true })
	return i.currentCall
}

`)
	if err != nil {
		return nil, err
	}

	// InterfaceVerification template
	//nolint:lll,nolintlint
	registry.interfaceVerificationTmpl, err = parseTemplate("interfaceVerification", `var (
	// Compile-time verification that {{.MockName}} implements {{.InterfaceName}}.
	_ {{.InterfaceName}}{{.TypeParamsUse}} = (*{{.MockName}}{{.TypeParamsUse}})(nil)
)

`)
	if err != nil {
		return nil, err
	}

	// MainStruct template
	//nolint:lll,nolintlint
	registry.mainStructTmpl, err = parseTemplate("mainStruct", `// {{.ImpName}} is the test controller for mocking the interface.
// Create with New{{.ImpName}}(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := New{{.ImpName}}(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type {{.ImpName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.Controller[*{{.CallName}}{{.TypeParamsUse}}]
	Mock *{{.MockName}}{{.TypeParamsUse}}
	ExpectCallIs *{{.ExpectCallIsName}}{{.TypeParamsUse}}
	currentCall *{{.CallName}}{{.TypeParamsUse}}
}

`)
	if err != nil {
		return nil, err
	}

	// MockStruct template
	//nolint:lll,nolintlint
	registry.mockStructTmpl, err = parseTemplate("mockStruct", `// {{.MockName}} provides the mock implementation of the interface.
// Pass {{.MockName}} to code under test that expects the interface implementation.
// Use the parent {{.ImpName}} controller to set expectations and inject responses.
type {{.MockName}}{{.TypeParamsDecl}} struct {
	imp *{{.ImpName}}{{.TypeParamsUse}}
}

`)
	if err != nil {
		return nil, err
	}

	// TimedStruct template
	//nolint:lll,nolintlint
	registry.timedStructTmpl, err = parseTemplate("timedStruct", `// {{.TimedName}} provides timeout-configured expectation methods.
// Access via {{.ImpName}}.Within(duration) to set a timeout for expectations.
type {{.TimedName}}{{.TypeParamsDecl}} struct {
	ExpectCallIs *{{.ExpectCallIsName}}{{.TypeParamsUse}}
}

// Within configures a timeout for expectations and returns a {{.TimedName}} for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*{{.PkgTime}}.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *{{.ImpName}}{{.TypeParamsUse}}) Within(d {{.PkgTime}}.Duration) *{{.TimedName}}{{.TypeParamsUse}} {
	return &{{.TimedName}}{{.TypeParamsUse}}{
		ExpectCallIs: &{{.ExpectCallIsName}}{{.TypeParamsUse}}{imp: i, timeout: d},
	}
}

`)
	if err != nil {
		return nil, err
	}

	// InjectPanic template
	//nolint:lll,nolintlint
	registry.injectPanicTmpl, err = parseTemplate("injectPanic", `// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *{{.MethodCallName}}{{.TypeParamsUse}}) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{{.TypeParamsUse}}{Type: "panic", PanicValue: msg}
}`)
	if err != nil {
		return nil, err
	}

	// Resolve template
	//nolint:lll,nolintlint
	registry.resolveTmpl, err = parseTemplate("resolve", `// Resolve completes a void method call without error.
// Use this to unblock the mock method and allow execution to continue.
// Only applicable to methods with no return values.
func (c *{{.MethodCallName}}{{.TypeParamsUse}}) Resolve() {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{{.TypeParamsUse}}{Type: "resolve"}
}`)
	if err != nil {
		return nil, err
	}

	// CallStruct template
	//nolint:lll,nolintlint
	registry.callStructTmpl, err = parseTemplate("callStruct", `// {{.CallName}} represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{"{"}}{Method}() to access typed call details.
type {{.CallName}}{{.TypeParamsDecl}} struct {
{{range .Methods}}	{{lowerFirst .Name}} *{{.CallName}}{{.TypeParamsUse}}
{{end}}}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *{{.CallName}}{{.TypeParamsUse}}) Name() string {
{{range .Methods}}	if c.{{lowerFirst .Name}} != nil {
		return "{{.Name}}"
	}
{{end}}	return ""
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *{{.CallName}}{{.TypeParamsUse}}) Done() bool {
{{range .Methods}}	if c.{{lowerFirst .Name}} != nil {
		return c.{{lowerFirst .Name}}.done
	}
{{end}}	return false
}

{{range .Methods}}// As{{.Name}} returns the call cast to {{.CallName}} for accessing call details.
// Returns nil if the call was not to {{.Name}}.
func (c *{{$.CallName}}{{$.TypeParamsUse}}) As{{.Name}}() *{{.CallName}}{{.TypeParamsUse}} {
	return c.{{lowerFirst .Name}}
}

{{end}}`)
	if err != nil {
		return nil, err
	}

	// CallableHeader template
	//nolint:lll,nolintlint
	registry.callableHeaderTmpl, err = parseTemplate("callableHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
{{if .NeedsFmt}}	{{.PkgFmt}} "fmt"
{{end}}	{{.PkgImptest}} "github.com/toejough/imptest/imptest"
{{if .NeedsReflect}}	{{.PkgReflect}} "reflect"
{{end}}	{{.PkgTesting}} "testing"
{{if .NeedsQualifier}}	{{.Qualifier}} "{{.PkgPath}}"
{{end}}{{range .AdditionalImports}}	{{if .Alias}}{{.Alias}} {{end}}"{{.Path}}"
{{end}})

`)
	if err != nil {
		return nil, err
	}

	// CallableReturnStruct template
	//nolint:lll,nolintlint
	registry.callableReturnStructTmpl, err = parseTemplate("callableReturnStruct", `{{if .HasReturns}}// {{.ImpName}}Return holds the return values from the callable function.
// Access individual return values via Result0, Result1, etc. fields.
type {{.ImpName}}Return{{.TypeParamsDecl}} struct {
{{range .ReturnFields}}	Result{{.Index}} {{.Type}}
{{end}}}

{{end}}`)
	if err != nil {
		return nil, err
	}

	// CallableMainStruct template
	//nolint:lll,nolintlint
	registry.callableMainStructTmpl, err = parseTemplate("callableMainStruct", `// {{.ImpName}} wraps a callable function for testing.
// Create with New{{.ImpName}}(t, yourFunction), call Start() to execute,
// then use ExpectReturnedValuesAre/Should() or ExpectPanicWith() to verify behavior.
type {{.ImpName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.CallableController[{{.ReturnType}}]
	callable func({{.CallableSignature}}){{.CallableReturns}}
}

`)
	if err != nil {
		return nil, err
	}

	// CallableConstructor template
	//nolint:lll,nolintlint
	registry.callableConstructorTmpl, err = parseTemplate("callableConstructor", `// New{{.ImpName}} creates a new wrapper for testing the callable function.
// Pass the function to test and a testing.TB to enable assertion failures.
//
// Example:
//
//	wrapper := New{{.ImpName}}(t, myFunction)
//	wrapper.Start(args...).ExpectReturnedValuesAre(expectedVals...)
func New{{.ImpName}}{{.TypeParamsDecl}}(t {{.PkgTesting}}.TB, callable func({{.CallableSignature}}){{.CallableReturns}}) *{{.ImpName}}{{.TypeParamsUse}} {
	return &{{.ImpName}}{{.TypeParamsUse}}{
		CallableController: {{.PkgImptest}}.NewCallableController[{{.ReturnType}}](t),
		callable:           callable,
	}
}

`)
	if err != nil {
		return nil, err
	}

	// CallableStartMethod template
	//nolint:lll,nolintlint
	registry.callableStartMethodTmpl, err = parseTemplate("callableStartMethod", `// Start begins execution of the callable in a goroutine with the provided arguments.
// Returns the wrapper for method chaining with expectation methods.
// Captures both normal returns and panics for verification.
//
// Example:
//
//	wrapper.Start(arg1, arg2).ExpectReturnedValuesAre(expectedResult)
func (s *{{.ImpName}}{{.TypeParamsUse}}) Start({{.CallableSignature}}) *{{.ImpName}}{{.TypeParamsUse}} {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				s.PanicChan <- r
			}
		}()

{{if .HasReturns}}		{{.ReturnVars}} := s.callable({{.ParamNames}})
		s.ReturnChan <- {{.ImpName}}Return{{.TypeParamsUse}}{
{{range .ReturnFields}}			Result{{.Index}}: {{.Name}},
{{end}}		}
{{else}}		s.callable({{.ParamNames}})
		s.ReturnChan <- struct{}{}
{{end}}	}()
	return s
}

`)
	if err != nil {
		return nil, err
	}

	// CallableExpectReturnedValuesAre template
	//nolint:lll,nolintlint
	registry.callableExpectReturnedValuesAreTmpl, err = parseTemplate("callableExpectReturnedValuesAre", `// ExpectReturnedValuesAre asserts the callable returned with exactly the specified values.
// Fails the test if the values don't match exactly or if the callable panicked.
// Uses == for comparison, so reference types must be the same instance.
func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectReturnedValuesAre({{.ResultParams}}) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Returned != nil {
{{.ResultComparisons}}		return
	}

	s.T.Fatalf("expected function to return, but it panicked with: %v", s.Panicked)
}

`)
	if err != nil {
		return nil, err
	}

	// CallableExpectReturnedValuesShould template
	//nolint:lll,nolintlint
	registry.callableExpectReturnedValuesShouldTmpl, err = parseTemplate("callableExpectReturnedValuesShould", `// ExpectReturnedValuesShould asserts return values match the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Fails the test if any matcher fails or if the callable panicked.
func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectReturnedValuesShould({{.ResultParamsAny}}) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Returned != nil {
{{if .HasReturns}}		var ok bool
		var msg string
{{.ResultMatchers}}{{end}}		return
	}

	s.T.Fatalf("expected function to return, but it panicked with: %v", s.Panicked)
}

`)
	if err != nil {
		return nil, err
	}

	// CallableExpectPanicWith template
	//nolint:lll,nolintlint
	registry.callableExpectPanicWithTmpl, err = parseTemplate("callableExpectPanicWith", `// ExpectPanicWith asserts the callable panicked with a value matching the expectation.
// Use imptest.Any() to match any panic value, or imptest.Satisfies(fn) for custom matching.
// Fails the test if the callable returned normally or panicked with a different value.
func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectPanicWith(expected any) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(s.Panicked, expected)
		if !ok {
			s.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	s.T.Fatalf("expected function to panic, but it returned")
}

`)
	if err != nil {
		return nil, err
	}

	// CallableResponseStruct template
	//nolint:lll,nolintlint
	registry.callableResponseStructTmpl, err = parseTemplate("callableResponseStruct", `// {{.ImpName}}Response represents the response from the callable (either return or panic).
// Check EventType to determine if the callable returned normally or panicked.
// Access ReturnVal for return values or PanicVal for panic information.
type {{.ImpName}}Response{{.TypeParamsDecl}} struct {
	EventType string // "return" or "panic"
{{if .HasReturns}}	ReturnVal *{{.ImpName}}Return{{.TypeParamsUse}}
{{end}}	PanicVal  any
}

`)
	if err != nil {
		return nil, err
	}

	// CallableResponseTypeMethod template
	//nolint:lll,nolintlint
	registry.callableResponseTypeMethodTmpl, err = parseTemplate("callableResponseTypeMethod", `// Type returns the event type: "return" for normal returns, "panic" for panics.
func (r *{{.ImpName}}Response{{.TypeParamsUse}}) Type() string {
	return r.EventType
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Header template
	registry.v2DepHeaderTmpl, err = parseTemplate("v2DepHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	"github.com/toejough/imptest/imptest"
{{if .NeedsQualifier}}	{{.Qualifier}} "{{.PkgPath}}"
{{end}})

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Mock Struct template
	registry.v2DepMockStructTmpl, err = parseTemplate("v2DepMockStruct", `// {{.MockTypeName}} is the mock implementation returned by {{.MockName}}.
type {{.MockTypeName}} struct {
	imp *imptest.Imp
{{range .MethodNames}}	{{.}} *imptest.DependencyMethod
{{end}}}

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Constructor template
	registry.v2DepConstructorTmpl, err = parseTemplate("v2DepConstructor", `// {{.MockName}} creates a new mock for the {{.BaseName}} interface.
func {{.MockName}}(testReporter imptest.TestReporter) *{{.MockTypeName}} {
	imp, ok := testReporter.(*imptest.Imp)
	if !ok {
		imp = imptest.NewImp(testReporter)
	}

	return &{{.MockTypeName}}{
		imp: imp,
{{range .MethodNames}}		{{.}}: imptest.NewDependencyMethod(imp, "{{.}}"),
{{end}}	}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Interface Method template
	registry.v2DepInterfaceMethodTmpl, err = parseTemplate("v2DepInterfaceMethod", `// Interface returns the mock as a {{.InterfaceType}} interface implementation.
func (m *{{.MockTypeName}}) Interface() {{.InterfaceType}} {
	return &{{.ImplName}}{mock: m}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Impl Struct template
	registry.v2DepImplStructTmpl, err = parseTemplate("v2DepImplStruct", `// {{.ImplName}} implements the {{.InterfaceName}} interface by forwarding to the mock.
type {{.ImplName}} struct {
	mock *{{.MockTypeName}}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Impl Method template
	//nolint:lll // Template string driven by generated code structure
	registry.v2DepImplMethodTmpl, err = parseTemplate("v2DepImplMethod", `// {{.MethodName}} implements {{.InterfaceType}}.{{.MethodName}} by sending a call to the Controller and blocking on response.
func (impl *{{.ImplName}}) {{.MethodName}}({{.Params}}){{.Results}} {
	responseChan := make(chan imptest.GenericResponse, 1)

{{if .HasVariadic}}	args := []any{ {{.NonVariadicArgs}} }
	for _, v := range {{.VariadicArg}} {
		args = append(args, v)
	}

	call := &imptest.GenericCall{
		MethodName:   "{{.MethodName}}",
		Args:         args,
{{else}}	call := &imptest.GenericCall{
		MethodName:   "{{.MethodName}}",
		Args:         []any{ {{.Args}} },
{{end}}		ResponseChan: responseChan,
	}

	// Send call to Controller
	impl.mock.imp.CallChan <- call

	// Block waiting for test to inject response
	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

{{if .HasResults}}{{range .ResultVars}}	var {{.Name}} {{.Type}}

{{end}}{{range .ResultVars}}	if len(resp.ReturnValues) > {{.Index}} {
		if value, ok := resp.ReturnValues[{{.Index}}].({{.Type}}); ok {
			{{.Name}} = value
		}
	}

{{end}}	return {{.ReturnList}}
{{end}}}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Header template (same as v2 dependency header)
	registry.v2TargetHeaderTmpl, err = parseTemplate("v2TargetHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	"github.com/toejough/imptest/imptest"
{{if .NeedsQualifier}}	{{.Qualifier}} "{{.PkgPath}}"
{{end}})

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Constructor template
	registry.v2TargetConstructorTmpl, err = parseTemplate("v2TargetConstructor", `// {{.WrapName}} wraps the function for testing.
func {{.WrapName}}(testReporter imptest.TestReporter, fn {{.FuncSig}}) *{{.WrapperType}} {
	imp, ok := testReporter.(*imptest.Imp)
	if !ok {
		imp = imptest.NewImp(testReporter)
	}

	return &{{.WrapperType}}{
		imp:        imp,
		fn:         fn,
		returnChan: make(chan {{.ReturnsType}}, 1),
		panicChan:  make(chan any, 1),
	}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Wrapper Struct template
	registry.v2TargetWrapperStructTmpl, err = parseTemplate("v2TargetWrapperStruct", `// {{.WrapperType}} provides a fluent API for calling and verifying the function.
type {{.WrapperType}} struct {
	imp        *imptest.Imp
	fn         {{.FuncSig}}
	returnChan chan {{.ReturnsType}}
	panicChan  chan any
	returned   *{{.ReturnsType}}
	panicked   any
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Start Method template
	registry.v2TargetStartMethodTmpl, err = parseTemplate("v2TargetStartMethod", `// Start begins execution of the function in a goroutine.
func (w *{{.WrapperType}}) Start({{.Params}}) *{{.WrapperType}} {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				w.panicChan <- r
			}
		}()

{{if .HasResults}}		{{.ResultVars}} := w.fn({{.ParamNames}})
		w.returnChan <- {{.ReturnsType}}{{"{"}}{{.ReturnAssignments}}{{"}"}}
{{else}}		w.fn({{.ParamNames}})
		w.returnChan <- {{.ReturnsType}}{}
{{end}}	}()

	return w
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Wait Method template
	registry.v2TargetWaitMethodTmpl, err = parseTemplate("v2TargetWaitMethod", `// {{.WaitMethodName}} blocks until the function completes (return or panic).
func (w *{{.WrapperType}}) {{.WaitMethodName}}() {
	if w.returned != nil || w.panicked != nil {
		return
	}

	select {
	case ret := <-w.returnChan:
		w.returned = &ret
	case p := <-w.panicChan:
		w.panicked = p
	}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target ExpectReturns template (for functions with return values)
	registry.v2TargetExpectReturnsTmpl, err = parseTemplate("v2TargetExpectReturns", `// ExpectReturnsEqual verifies the function returned exact values.
func (w *{{.WrapperType}}) ExpectReturnsEqual({{.ExpectedParams}}) {
	w.imp.Helper()
	w.WaitForResponse()

	if w.panicked != nil {
		w.imp.Fatalf("expected function to return, but it panicked with: %v", w.panicked)
		return
	}

{{range .ResultChecks}}	if w.returned.{{.Field}} != {{.Expected}} {
		w.imp.Fatalf("return value {{.Index}}: expected %v, got %v", {{.Expected}}, w.returned.{{.Field}})
	}
{{end}}}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target ExpectCompletes template (for void functions)
	registry.v2TargetExpectCompletesTmpl, err = parseTemplate("v2TargetExpectCompletes", `// ExpectCompletes verifies the function completed without panicking.
func (w *{{.WrapperType}}) ExpectCompletes() {
	w.imp.Helper()
	w.WaitForCompletion()

	if w.panicked != nil {
		w.imp.Fatalf("expected function to complete, but it panicked with: %v", w.panicked)
	}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target ExpectPanic template
	registry.v2TargetExpectPanicTmpl, err = parseTemplate("v2TargetExpectPanic", `// ExpectPanicEquals verifies the function panicked with the exact value.
func (w *{{.WrapperType}}) ExpectPanicEquals(expected any) {
	w.imp.Helper()
	w.{{.WaitMethodName}}()

	if w.panicked == nil {
		w.imp.Fatalf("expected panic with %v, but function completed normally", expected)
		return
	}

	if w.panicked != expected {
		w.imp.Fatalf("expected panic with %v, got %v", expected, w.panicked)
	}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Returns Struct template
	registry.v2TargetReturnsStructTmpl, err = parseTemplate("v2TargetReturnsStruct", `// {{.ReturnsType}} provides type-safe access to return values{{if not .HasResults}} (empty for void functions){{end}}.
type {{.ReturnsType}} struct {
{{if .HasResults}}{{range .ResultFields}}	{{.Name}} {{.Type}}
{{end}}{{end}}}
`)
	if err != nil {
		return nil, err
	}

	return registry, nil
}

// WriteCallStruct generates the call struct definition.
func (r *TemplateRegistry) WriteCallStruct(buf *bytes.Buffer, data callStructTemplateData) {
	err := r.callStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callStruct template: %v", err))
	}
}

// WriteCallableConstructor generates the callable wrapper constructor.
func (r *TemplateRegistry) WriteCallableConstructor(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := r.callableConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableConstructor template: %v", err))
	}
}

// WriteCallableExpectPanicWith generates the ExpectPanicWith method for callable wrappers.
func (r *TemplateRegistry) WriteCallableExpectPanicWith(buf *bytes.Buffer, data callableTemplateData) {
	err := r.callableExpectPanicWithTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableExpectPanicWith template: %v", err))
	}
}

// WriteCallableExpectReturnedValuesAre generates the ExpectReturnedValuesAre method.
func (r *TemplateRegistry) WriteCallableExpectReturnedValuesAre(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := r.callableExpectReturnedValuesAreTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableExpectReturnedValuesAre template: %v", err))
	}
}

// WriteCallableExpectReturnedValuesShould generates the ExpectReturnedValuesShould method.
func (r *TemplateRegistry) WriteCallableExpectReturnedValuesShould(
	buf *bytes.Buffer, data callableExtendedTemplateData,
) {
	err := r.callableExpectReturnedValuesShouldTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableExpectReturnedValuesShould template: %v", err))
	}
}

// WriteCallableHeader generates the header for callable wrapper files.
func (r *TemplateRegistry) WriteCallableHeader(buf *bytes.Buffer, data baseTemplateData) {
	err := r.callableHeaderTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableHeader template: %v", err))
	}
}

// WriteCallableMainStruct generates the main callable wrapper struct.
func (r *TemplateRegistry) WriteCallableMainStruct(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := r.callableMainStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableMainStruct template: %v", err))
	}
}

// WriteCallableResponseStruct generates the response struct for callable wrappers.
func (r *TemplateRegistry) WriteCallableResponseStruct(buf *bytes.Buffer, data callableTemplateData) {
	err := r.callableResponseStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableResponseStruct template: %v", err))
	}
}

// WriteCallableResponseTypeMethod generates the Type method for response structs.
func (r *TemplateRegistry) WriteCallableResponseTypeMethod(buf *bytes.Buffer, data callableTemplateData) {
	err := r.callableResponseTypeMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableResponseTypeMethod template: %v", err))
	}
}

// WriteCallableReturnStruct generates the return struct for callable wrappers.
func (r *TemplateRegistry) WriteCallableReturnStruct(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := r.callableReturnStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableReturnStruct template: %v", err))
	}
}

// WriteCallableStartMethod generates the Start method for callable wrappers.
func (r *TemplateRegistry) WriteCallableStartMethod(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := r.callableStartMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableStartMethod template: %v", err))
	}
}

// WriteConstructor generates the constructor function for interface mocks.
func (r *TemplateRegistry) WriteConstructor(buf *bytes.Buffer, data templateData) {
	err := r.constructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute constructor template: %v", err))
	}
}

// WriteExpectCallIsStruct generates the ExpectCallIs struct definition.
func (r *TemplateRegistry) WriteExpectCallIsStruct(buf *bytes.Buffer, data templateData) {
	err := r.expectCallIsStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute expectCallIsStruct template: %v", err))
	}
}

// WriteGetCurrentCallMethod generates the GetCurrentCall method.
func (r *TemplateRegistry) WriteGetCurrentCallMethod(buf *bytes.Buffer, data templateData) {
	err := r.getCurrentCallMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute getCurrentCallMethod template: %v", err))
	}
}

// WriteHeader generates the file header for interface mock files.
func (r *TemplateRegistry) WriteHeader(buf *bytes.Buffer, data templateData) {
	err := r.headerTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute header template: %v", err))
	}
}

// WriteInjectPanic generates the InjectPanic method for a method call.
func (r *TemplateRegistry) WriteInjectPanic(buf *bytes.Buffer, data methodTemplateData) {
	err := r.injectPanicTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute injectPanic template: %v", err))
	}
}

// WriteInterfaceVerification generates the compile-time interface verification.
func (r *TemplateRegistry) WriteInterfaceVerification(buf *bytes.Buffer, data templateData) {
	err := r.interfaceVerificationTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceVerification template: %v", err))
	}
}

// WriteMainStruct generates the main controller struct definition.
func (r *TemplateRegistry) WriteMainStruct(buf *bytes.Buffer, data templateData) {
	err := r.mainStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute mainStruct template: %v", err))
	}
}

// WriteMockStruct generates the mock struct definition.
func (r *TemplateRegistry) WriteMockStruct(buf *bytes.Buffer, data templateData) {
	err := r.mockStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute mockStruct template: %v", err))
	}
}

// WriteResolve generates the Resolve method for a void method call.
func (r *TemplateRegistry) WriteResolve(buf *bytes.Buffer, data methodTemplateData) {
	err := r.resolveTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute resolve template: %v", err))
	}
}

// WriteTimedStruct generates the timed expectation struct and Within method.
func (r *TemplateRegistry) WriteTimedStruct(buf *bytes.Buffer, data templateData) {
	err := r.timedStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute timedStruct template: %v", err))
	}
}

// WriteV2DepHeader writes the v2 dependency mock header.
func (r *TemplateRegistry) WriteV2DepHeader(buf *bytes.Buffer, data any) {
	err := r.v2DepHeaderTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepHeader template: %v", err))
	}
}

// WriteV2DepMockStruct writes the v2 dependency mock struct.
func (r *TemplateRegistry) WriteV2DepMockStruct(buf *bytes.Buffer, data any) {
	err := r.v2DepMockStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepMockStruct template: %v", err))
	}
}

// WriteV2DepConstructor writes the v2 dependency mock constructor.
func (r *TemplateRegistry) WriteV2DepConstructor(buf *bytes.Buffer, data any) {
	err := r.v2DepConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepConstructor template: %v", err))
	}
}

// WriteV2DepInterfaceMethod writes the v2 dependency Interface() method.
func (r *TemplateRegistry) WriteV2DepInterfaceMethod(buf *bytes.Buffer, data any) {
	err := r.v2DepInterfaceMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepInterfaceMethod template: %v", err))
	}
}

// WriteV2DepImplStruct writes the v2 dependency impl struct.
func (r *TemplateRegistry) WriteV2DepImplStruct(buf *bytes.Buffer, data any) {
	err := r.v2DepImplStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepImplStruct template: %v", err))
	}
}

// WriteV2DepImplMethod writes a v2 dependency impl method.
func (r *TemplateRegistry) WriteV2DepImplMethod(buf *bytes.Buffer, data any) {
	err := r.v2DepImplMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepImplMethod template: %v", err))
	}
}

// WriteV2TargetHeader writes the v2 target wrapper header.
func (r *TemplateRegistry) WriteV2TargetHeader(buf *bytes.Buffer, data any) {
	err := r.v2TargetHeaderTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetHeader template: %v", err))
	}
}

// WriteV2TargetConstructor writes the v2 target wrapper constructor.
func (r *TemplateRegistry) WriteV2TargetConstructor(buf *bytes.Buffer, data any) {
	err := r.v2TargetConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetConstructor template: %v", err))
	}
}

// WriteV2TargetWrapperStruct writes the v2 target wrapper struct.
func (r *TemplateRegistry) WriteV2TargetWrapperStruct(buf *bytes.Buffer, data any) {
	err := r.v2TargetWrapperStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetWrapperStruct template: %v", err))
	}
}

// WriteV2TargetStartMethod writes the v2 target Start method.
func (r *TemplateRegistry) WriteV2TargetStartMethod(buf *bytes.Buffer, data any) {
	err := r.v2TargetStartMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetStartMethod template: %v", err))
	}
}

// WriteV2TargetWaitMethod writes the v2 target wait method.
func (r *TemplateRegistry) WriteV2TargetWaitMethod(buf *bytes.Buffer, data any) {
	err := r.v2TargetWaitMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetWaitMethod template: %v", err))
	}
}

// WriteV2TargetExpectReturns writes the v2 target ExpectReturnsEqual method.
func (r *TemplateRegistry) WriteV2TargetExpectReturns(buf *bytes.Buffer, data any) {
	err := r.v2TargetExpectReturnsTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetExpectReturns template: %v", err))
	}
}

// WriteV2TargetExpectCompletes writes the v2 target ExpectCompletes method.
func (r *TemplateRegistry) WriteV2TargetExpectCompletes(buf *bytes.Buffer, data any) {
	err := r.v2TargetExpectCompletesTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetExpectCompletes template: %v", err))
	}
}

// WriteV2TargetExpectPanic writes the v2 target ExpectPanicEquals method.
func (r *TemplateRegistry) WriteV2TargetExpectPanic(buf *bytes.Buffer, data any) {
	err := r.v2TargetExpectPanicTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetExpectPanic template: %v", err))
	}
}

// WriteV2TargetReturnsStruct writes the v2 target returns struct.
func (r *TemplateRegistry) WriteV2TargetReturnsStruct(buf *bytes.Buffer, data any) {
	err := r.v2TargetReturnsStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetReturnsStruct template: %v", err))
	}
}

// parseTemplate is a helper function that parses a template with consistent error handling.
// Returns the parsed template or an error with a descriptive message.
func parseTemplate(name, content string) (*template.Template, error) {
	funcMap := template.FuncMap{
		"lowerFirst": lowerFirst,
	}

	tmpl, err := template.New(name).Funcs(funcMap).Parse(content)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s template: %w", name, err)
	}

	return tmpl, nil
}
