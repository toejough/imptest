package run

import (
	"bytes"
	"fmt"
	"text/template"
)

// Template definitions using text/template instead of quicktemplate
//
//nolint:gochecknoglobals // text/template requires global template variables
var (
	headerTmpl                             *template.Template
	constructorTmpl                        *template.Template
	expectCallIsStructTmpl                 *template.Template
	getCurrentCallMethodTmpl               *template.Template
	interfaceVerificationTmpl              *template.Template
	mainStructTmpl                         *template.Template
	mockStructTmpl                         *template.Template
	timedStructTmpl                        *template.Template
	injectPanicTmpl                        *template.Template
	resolveTmpl                            *template.Template
	callStructTmpl                         *template.Template
	callableHeaderTmpl                     *template.Template
	callableReturnStructTmpl               *template.Template
	callableMainStructTmpl                 *template.Template
	callableConstructorTmpl                *template.Template
	callableStartMethodTmpl                *template.Template
	callableExpectReturnedValuesAreTmpl    *template.Template
	callableExpectReturnedValuesShouldTmpl *template.Template
	callableExpectPanicWithTmpl            *template.Template
	callableResponseStructTmpl             *template.Template
	callableResponseTypeMethodTmpl         *template.Template
	callableAsReturnMethodTmpl             *template.Template
	callableGetResponseMethodTmpl          *template.Template
)

//nolint:gochecknoinits,cyclop,funlen,maintidx // text/template init unavoidable
func init() {
	var err error

	// Header template
	//nolint:lll,nolintlint
	headerTmpl, err = template.New("header").Parse(`// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

{{if .ImptestAlias}}import {{.ImptestAlias}} "github.com/toejough/imptest/imptest"{{else -}}
import "github.com/toejough/imptest/imptest"{{end}}
{{if .NeedsReflect}}{{if .ReflectAlias}}import {{.ReflectAlias}} "reflect"{{else}}import "reflect"{{end}}
{{end}}{{if .TestingAlias}}import {{.TestingAlias}} "testing"{{else}}import "testing"{{end}}
{{if .TimePath}}{{if .TimeAlias}}import {{.TimeAlias}} "{{.TimePath}}"{{else}}import "{{.TimePath}}"{{end}}
{{end}}{{if .NeedsQualifier}}import {{.Qualifier}} "{{.PkgPath}}"
{{end}}`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse header template: %v", err))
	}

	// Constructor template
	//nolint:lll // Template string length driven by generated code structure
	//nolint:lll,nolintlint
	constructorTmpl, err = template.New("constructor").Parse(`// New{{.ImpName}} creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := New{{.ImpName}}(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func New{{.ImpName}}{{.TypeParamsDecl}}(t *{{if .TestingAlias}}{{.TestingAlias}}{{else}}testing{{end}}.T) *{{.ImpName}}{{.TypeParamsUse}} {
	imp := &{{.ImpName}}{{.TypeParamsUse}}{
		Controller: {{if .ImptestAlias}}{{.ImptestAlias}}{{else}}imptest{{end}}.NewController[*{{.CallName}}{{.TypeParamsUse}}](t),
	}
	imp.Mock = &{{.MockName}}{{.TypeParamsUse}}{imp: imp}
	imp.ExpectCallIs = &{{.ExpectCallIsName}}{{.TypeParamsUse}}{imp: imp}
	return imp
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse constructor template: %v", err))
	}

	// ExpectCallIsStruct template
	//nolint:lll // Template string length driven by generated code structure
	//nolint:lll,nolintlint
	expectCallIsStructTmpl, err = template.New("expectCallIsStruct").Parse(`// {{.ExpectCallIsName}} provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent {{.ImpName}} to configure timeouts.
type {{.ExpectCallIsName}}{{.TypeParamsDecl}} struct {
	imp *{{.ImpName}}{{.TypeParamsUse}}
	timeout {{if .TimeAlias}}{{.TimeAlias}}{{else}}time{{end}}.Duration
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse expectCallIsStruct template: %v", err))
	}

	// GetCurrentCallMethod template
	//nolint:lll // Template definition
	//nolint:lll,nolintlint
	getCurrentCallMethodTmpl, err = template.New("getCurrentCallMethod").Parse(`// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *{{.ImpName}}{{.TypeParamsUse}}) GetCurrentCall() *{{.CallName}}{{.TypeParamsUse}} {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *{{.CallName}}{{.TypeParamsUse}}) bool { return true })
	return i.currentCall
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse getCurrentCallMethod template: %v", err))
	}

	// InterfaceVerification template
	//nolint:lll,nolintlint
	interfaceVerificationTmpl, err = template.New("interfaceVerification").Parse(`var (
	// Compile-time verification that {{.MockName}} implements {{.InterfaceName}}.
	_ {{.InterfaceName}}{{.TypeParamsUse}} = (*{{.MockName}}{{.TypeParamsUse}})(nil)
)

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse interfaceVerification template: %v", err))
	}

	// MainStruct template
	//nolint:lll,nolintlint
	mainStructTmpl, err = template.New("mainStruct").Parse(`// {{.ImpName}} is the test controller for mocking the interface.
// Create with New{{.ImpName}}(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := New{{.ImpName}}(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type {{.ImpName}}{{.TypeParamsDecl}} struct {
	*imptest.Controller[*{{.CallName}}{{.TypeParamsUse}}]
	Mock *{{.MockName}}{{.TypeParamsUse}}
	ExpectCallIs *{{.ExpectCallIsName}}{{.TypeParamsUse}}
	currentCall *{{.CallName}}{{.TypeParamsUse}}
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse mainStruct template: %v", err))
	}

	// MockStruct template
	//nolint:lll,nolintlint
	mockStructTmpl, err = template.New("mockStruct").Parse(`// {{.MockName}} provides the mock implementation of the interface.
// Pass {{.MockName}} to code under test that expects the interface implementation.
// Use the parent {{.ImpName}} controller to set expectations and inject responses.
type {{.MockName}}{{.TypeParamsDecl}} struct {
	imp *{{.ImpName}}{{.TypeParamsUse}}
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse mockStruct template: %v", err))
	}

	// TimedStruct template
	//nolint:lll,nolintlint
	timedStructTmpl, err = template.New("timedStruct").Parse(`// {{.TimedName}} provides timeout-configured expectation methods.
// Access via {{.ImpName}}.Within(duration) to set a timeout for expectations.
type {{.TimedName}}{{.TypeParamsDecl}} struct {
	ExpectCallIs *{{.ExpectCallIsName}}{{.TypeParamsUse}}
}

// Within configures a timeout for expectations and returns a {{.TimedName}} for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*{{if .TimeAlias}}{{.TimeAlias}}{{else}}time{{end}}.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *{{.ImpName}}{{.TypeParamsUse}}) Within(d {{if .TimeAlias}}{{.TimeAlias}}{{else}}time{{end}}.Duration) *{{.TimedName}}{{.TypeParamsUse}} {
	return &{{.TimedName}}{{.TypeParamsUse}}{
		ExpectCallIs: &{{.ExpectCallIsName}}{{.TypeParamsUse}}{imp: i, timeout: d},
	}
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse timedStruct template: %v", err))
	}

	// InjectPanic template
	//nolint:lll,nolintlint
	injectPanicTmpl, err = template.New("injectPanic").Parse(`// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *{{.MethodCallName}}{{.TypeParamsUse}}) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{{.TypeParamsUse}}{Type: "panic", PanicValue: msg}
}`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse injectPanic template: %v", err))
	}

	// Resolve template
	//nolint:lll,nolintlint
	resolveTmpl, err = template.New("resolve").Parse(`// Resolve completes a void method call without error.
// Use this to unblock the mock method and allow execution to continue.
// Only applicable to methods with no return values.
func (c *{{.MethodCallName}}{{.TypeParamsUse}}) Resolve() {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{{.TypeParamsUse}}{Type: "resolve"}
}`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse resolve template: %v", err))
	}

	// CallStruct template
	//nolint:lll,nolintlint
	callStructTmpl, err = template.New("callStruct").Parse(`// {{.CallName}} represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{"{"}}{Method}() to access typed call details.
type {{.CallName}}{{.TypeParamsDecl}} struct {
{{range .Methods}}	{{.Name}} *{{.CallName}}{{.TypeParamsUse}}
{{end}}}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *{{.CallName}}{{.TypeParamsUse}}) Name() string {
{{range .Methods}}	if c.{{.Name}} != nil {
		return "{{.Name}}"
	}
{{end}}	return ""
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *{{.CallName}}{{.TypeParamsUse}}) Done() bool {
{{range .Methods}}	if c.{{.Name}} != nil {
		return c.{{.Name}}.done
	}
{{end}}	return false
}

{{range .Methods}}// As{{.Name}} returns the call cast to {{.CallName}} for accessing call details.
// Returns nil if the call was not to {{.Name}}.
func (c *{{$.CallName}}{{$.TypeParamsUse}}) As{{.Name}}() *{{.CallName}}{{.TypeParamsUse}} {
	return c.{{.Name}}
}

{{end}}`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callStruct template: %v", err))
	}

	// CallableHeader template
	//nolint:lll,nolintlint
	callableHeaderTmpl, err = template.New("callableHeader").Parse(`// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	{{if .ImptestAlias}}{{.ImptestAlias}} {{end}}"github.com/toejough/imptest/imptest"
{{if .NeedsReflect}}	{{if .ReflectAlias}}{{.ReflectAlias}} {{end}}"reflect"
{{end}}	{{if .TestingAlias}}{{.TestingAlias}} {{end}}"testing"
{{if .NeedsQualifier}}	{{.Qualifier}} "{{.PkgPath}}"
{{end}})

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableHeader template: %v", err))
	}

	// CallableReturnStruct template
	//nolint:lll,nolintlint
	callableReturnStructTmpl, err = template.New("callableReturnStruct").Parse(`{{if .HasReturns}}// {{.ImpName}}Return holds the return values from the callable function.
// Access individual return values via Result0, Result1, etc. fields.
type {{.ImpName}}Return{{.TypeParamsDecl}} struct {
{{range .ReturnFields}}	Result{{.Index}} {{.Type}}
{{end}}}

{{end}}`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableReturnStruct template: %v", err))
	}

	// CallableMainStruct template
	//nolint:lll,nolintlint
	callableMainStructTmpl, err = template.New("callableMainStruct").Parse(`// {{.ImpName}} wraps a callable function for testing.
// Create with New{{.ImpName}}(t, yourFunction), call Start() to execute,
// then use ExpectReturnedValuesAre/Should() or ExpectPanicWith() to verify behavior.
type {{.ImpName}}{{.TypeParamsDecl}} struct {
	*imptest.CallableController[{{.ReturnType}}]
	callable func({{.CallableSignature}}){{.CallableReturns}}
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableMainStruct template: %v", err))
	}

	// CallableConstructor template
	//nolint:lll,nolintlint
	callableConstructorTmpl, err = template.New("callableConstructor").Parse(`// New{{.ImpName}} creates a new wrapper for testing the callable function.
// Pass the function to test and a testing.TB to enable assertion failures.
//
// Example:
//
//	wrapper := New{{.ImpName}}(t, myFunction)
//	wrapper.Start(args...).ExpectReturnedValuesAre(expectedVals...)
func New{{.ImpName}}{{.TypeParamsDecl}}(t {{if .TestingAlias}}{{.TestingAlias}}{{else}}testing{{end}}.TB, callable func({{.CallableSignature}}){{.CallableReturns}}) *{{.ImpName}}{{.TypeParamsUse}} {
	return &{{.ImpName}}{{.TypeParamsUse}}{
		CallableController: {{if .ImptestAlias}}{{.ImptestAlias}}{{else}}imptest{{end}}.NewCallableController[{{.ReturnType}}](t),
		callable:           callable,
	}
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableConstructor template: %v", err))
	}

	// CallableStartMethod template
	//nolint:lll,nolintlint
	callableStartMethodTmpl, err = template.New("callableStartMethod").Parse(`// Start begins execution of the callable in a goroutine with the provided arguments.
// Returns the wrapper for method chaining with expectation methods.
// Captures both normal returns and panics for verification.
//
// Example:
//
//	wrapper.Start(arg1, arg2).ExpectReturnedValuesAre(expectedResult)
func (s *{{.ImpName}}{{.TypeParamsUse}}) Start({{.CallableSignature}}) *{{.ImpName}}{{.TypeParamsUse}} {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				s.PanicChan <- r
			}
		}()

{{if .HasReturns}}		{{.ReturnVars}} := s.callable({{.ParamNames}})
		s.ReturnChan <- {{.ImpName}}Return{{.TypeParamsUse}}{
{{range .ReturnFields}}			Result{{.Index}}: {{.Name}},
{{end}}		}
{{else}}		s.callable({{.ParamNames}})
		s.ReturnChan <- struct{}{}
{{end}}	}()
	return s
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableStartMethod template: %v", err))
	}

	// CallableExpectReturnedValuesAre template
	//nolint:lll,nolintlint
	callableExpectReturnedValuesAreTmpl, err = template.New("callableExpectReturnedValuesAre").Parse(`// ExpectReturnedValuesAre asserts the callable returned with exactly the specified values.
// Fails the test if the values don't match exactly or if the callable panicked.
// Uses == for comparison, so reference types must be the same instance.
func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectReturnedValuesAre({{.ResultParams}}) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Returned != nil {
{{.ResultComparisons}}		return
	}

	s.T.Fatalf("expected function to return, but it panicked with: %v", s.Panicked)
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableExpectReturnedValuesAre template: %v", err))
	}

	// CallableExpectReturnedValuesShould template
	//nolint:lll,nolintlint
	callableExpectReturnedValuesShouldTmpl, err = template.New("callableExpectReturnedValuesShould").Parse(`// ExpectReturnedValuesShould asserts return values match the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Fails the test if any matcher fails or if the callable panicked.
func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectReturnedValuesShould({{.ResultParamsAny}}) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Returned != nil {
{{if .HasReturns}}		var ok bool
		var msg string
{{.ResultMatchers}}{{end}}		return
	}

	s.T.Fatalf("expected function to return, but it panicked with: %v", s.Panicked)
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableExpectReturnedValuesShould template: %v", err))
	}

	// CallableExpectPanicWith template
	//nolint:lll,nolintlint
	callableExpectPanicWithTmpl, err = template.New("callableExpectPanicWith").Parse(`// ExpectPanicWith asserts the callable panicked with a value matching the expectation.
// Use imptest.Any() to match any panic value, or imptest.Satisfies(fn) for custom matching.
// Fails the test if the callable returned normally or panicked with a different value.
func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectPanicWith(expected any) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Panicked != nil {
		ok, msg := imptest.MatchValue(s.Panicked, expected)
		if !ok {
			s.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	s.T.Fatalf("expected function to panic, but it returned")
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableExpectPanicWith template: %v", err))
	}

	// CallableResponseStruct template
	//nolint:lll,nolintlint
	callableResponseStructTmpl, err = template.New("callableResponseStruct").Parse(`// {{.ImpName}}Response represents the response from the callable (either return or panic).
// Check EventType to determine if the callable returned normally or panicked.
// Use AsReturn() to get return values as a slice, or access PanicVal directly.
type {{.ImpName}}Response{{.TypeParamsDecl}} struct {
	EventType string // "return" or "panic"
{{if .HasReturns}}	ReturnVal *{{.ImpName}}Return{{.TypeParamsUse}}
{{end}}	PanicVal  any
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableResponseStruct template: %v", err))
	}

	// CallableResponseTypeMethod template
	//nolint:lll,nolintlint
	callableResponseTypeMethodTmpl, err = template.New("callableResponseTypeMethod").Parse(`// Type returns the event type: "return" for normal returns, "panic" for panics.
func (r *{{.ImpName}}Response{{.TypeParamsUse}}) Type() string {
	return r.EventType
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableResponseTypeMethod template: %v", err))
	}

	// CallableAsReturnMethod template
	//nolint:lll,nolintlint
	callableAsReturnMethodTmpl, err = template.New("callableAsReturnMethod").Parse(`// AsReturn converts the return values to a slice of any for generic processing.
// Returns nil if the response was a panic or if there are no return values.
func (r *{{.ImpName}}Response{{.TypeParamsUse}}) AsReturn() []any {
{{if .HasReturns}}	if r.ReturnVal == nil {
		return nil
	}
	return []any{ {{range $i, $field := .ReturnFields}}{{if $i}}, {{end}}r.ReturnVal.Result{{$i}}{{end}} }
{{else}}	return nil
{{end}}}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableAsReturnMethod template: %v", err))
	}

	// CallableGetResponseMethod template
	//nolint:lll,nolintlint
	callableGetResponseMethodTmpl, err = template.New("callableGetResponseMethod").Parse(`// GetResponse waits for and returns the callable's response.
// Use this when you need to inspect the response without asserting specific values.
// The response indicates whether the callable returned or panicked.
func (s *{{.ImpName}}{{.TypeParamsUse}}) GetResponse() *{{.ImpName}}Response{{.TypeParamsUse}} {
	s.WaitForResponse()

	if s.Returned != nil {
		return &{{.ImpName}}Response{{.TypeParamsUse}}{
			EventType: "ReturnEvent",
{{if .HasReturns}}			ReturnVal: s.Returned,
{{end}}		}
	}

	return &{{.ImpName}}Response{{.TypeParamsUse}}{
		EventType: "PanicEvent",
		PanicVal:  s.Panicked,
	}
}

`)
	if err != nil {
		panic(fmt.Sprintf("failed to parse callableGetResponseMethod template: %v", err))
	}
}

// Write* functions that match the quicktemplate API

// WriteHeader generates the file header for interface mock files.
func WriteHeader(buf *bytes.Buffer, data templateData) {
	err := headerTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute header template: %v", err))
	}
}

// WriteConstructor generates the constructor function for interface mocks.
func WriteConstructor(buf *bytes.Buffer, data templateData) {
	err := constructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute constructor template: %v", err))
	}
}

// WriteExpectCallIsStruct generates the ExpectCallIs struct definition.
func WriteExpectCallIsStruct(buf *bytes.Buffer, data templateData) {
	err := expectCallIsStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute expectCallIsStruct template: %v", err))
	}
}

// WriteGetCurrentCallMethod generates the GetCurrentCall method.
func WriteGetCurrentCallMethod(buf *bytes.Buffer, data templateData) {
	err := getCurrentCallMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute getCurrentCallMethod template: %v", err))
	}
}

// WriteInterfaceVerification generates the compile-time interface verification.
func WriteInterfaceVerification(buf *bytes.Buffer, data templateData) {
	err := interfaceVerificationTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceVerification template: %v", err))
	}
}

// WriteMainStruct generates the main controller struct definition.
func WriteMainStruct(buf *bytes.Buffer, data templateData) {
	err := mainStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute mainStruct template: %v", err))
	}
}

// WriteMockStruct generates the mock struct definition.
func WriteMockStruct(buf *bytes.Buffer, data templateData) {
	err := mockStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute mockStruct template: %v", err))
	}
}

// WriteTimedStruct generates the timed expectation struct and Within method.
func WriteTimedStruct(buf *bytes.Buffer, data templateData) {
	err := timedStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute timedStruct template: %v", err))
	}
}

// WriteInjectPanic generates the InjectPanic method for a method call.
func WriteInjectPanic(buf *bytes.Buffer, data methodTemplateData) {
	err := injectPanicTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute injectPanic template: %v", err))
	}
}

// WriteResolve generates the Resolve method for a void method call.
func WriteResolve(buf *bytes.Buffer, data methodTemplateData) {
	err := resolveTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute resolve template: %v", err))
	}
}

// WriteCallStruct generates the call struct definition.
func WriteCallStruct(buf *bytes.Buffer, data callStructTemplateData) {
	err := callStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callStruct template: %v", err))
	}
}

// WriteCallableHeader generates the header for callable wrapper files.
func WriteCallableHeader(buf *bytes.Buffer, data baseTemplateData) {
	err := callableHeaderTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableHeader template: %v", err))
	}
}

// WriteCallableReturnStruct generates the return struct for callable wrappers.
func WriteCallableReturnStruct(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := callableReturnStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableReturnStruct template: %v", err))
	}
}

// WriteCallableMainStruct generates the main callable wrapper struct.
func WriteCallableMainStruct(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := callableMainStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableMainStruct template: %v", err))
	}
}

// WriteCallableConstructor generates the callable wrapper constructor.
func WriteCallableConstructor(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := callableConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableConstructor template: %v", err))
	}
}

// WriteCallableStartMethod generates the Start method for callable wrappers.
func WriteCallableStartMethod(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := callableStartMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableStartMethod template: %v", err))
	}
}

// WriteCallableExpectReturnedValuesAre generates the ExpectReturnedValuesAre method.
func WriteCallableExpectReturnedValuesAre(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := callableExpectReturnedValuesAreTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableExpectReturnedValuesAre template: %v", err))
	}
}

// WriteCallableExpectReturnedValuesShould generates the ExpectReturnedValuesShould method.
func WriteCallableExpectReturnedValuesShould(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := callableExpectReturnedValuesShouldTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableExpectReturnedValuesShould template: %v", err))
	}
}

// WriteCallableExpectPanicWith generates the ExpectPanicWith method for callable wrappers.
func WriteCallableExpectPanicWith(buf *bytes.Buffer, data callableTemplateData) {
	err := callableExpectPanicWithTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableExpectPanicWith template: %v", err))
	}
}

// WriteCallableResponseStruct generates the response struct for callable wrappers.
func WriteCallableResponseStruct(buf *bytes.Buffer, data callableTemplateData) {
	err := callableResponseStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableResponseStruct template: %v", err))
	}
}

// WriteCallableResponseTypeMethod generates the Type method for response structs.
func WriteCallableResponseTypeMethod(buf *bytes.Buffer, data callableTemplateData) {
	err := callableResponseTypeMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableResponseTypeMethod template: %v", err))
	}
}

// WriteCallableAsReturnMethod generates the AsReturn method for response structs.
func WriteCallableAsReturnMethod(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := callableAsReturnMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableAsReturnMethod template: %v", err))
	}
}

// WriteCallableGetResponseMethod generates the GetResponse method for callable wrappers.
func WriteCallableGetResponseMethod(buf *bytes.Buffer, data callableTemplateData) {
	err := callableGetResponseMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableGetResponseMethod template: %v", err))
	}
}
