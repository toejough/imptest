package run

import (
	"bytes"
	"fmt"
	"text/template"
)

// TemplateRegistry holds all parsed text templates for code generation.
// Create a registry using NewTemplateRegistry() to initialize all templates.
type TemplateRegistry struct {
	// V2 Dependency templates
	v2DepHeaderTmpl          *template.Template
	v2DepMockStructTmpl      *template.Template
	v2DepConstructorTmpl     *template.Template
	v2DepInterfaceMethodTmpl *template.Template
	v2DepImplStructTmpl      *template.Template
	v2DepImplMethodTmpl      *template.Template
	v2DepArgsStructTmpl      *template.Template
	v2DepCallWrapperTmpl     *template.Template
	v2DepMethodWrapperTmpl   *template.Template
	// V2 Target wrapper templates
	v2TargetHeaderTmpl          *template.Template
	v2TargetConstructorTmpl     *template.Template
	v2TargetWrapperStructTmpl   *template.Template
	v2TargetStartMethodTmpl     *template.Template
	v2TargetWaitMethodTmpl      *template.Template
	v2TargetExpectReturnsTmpl   *template.Template
	v2TargetExpectCompletesTmpl *template.Template
	v2TargetExpectPanicTmpl     *template.Template
	v2TargetReturnsStructTmpl   *template.Template
}

// NewTemplateRegistry creates and initializes a new template registry with all templates parsed.
//
//nolint:cyclop,funlen // Template parsing requires comprehensive initialization
func NewTemplateRegistry() (*TemplateRegistry, error) {
	registry := &TemplateRegistry{}

	var err error

	// V2 Dependency Header template
	registry.v2DepHeaderTmpl, err = parseTemplate("v2DepHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	{{.PkgImptest}} "github.com/toejough/imptest/imptest"{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Mock Struct template
	//nolint:lll // Template docstring
	registry.v2DepMockStructTmpl, err = parseTemplate("v2DepMockStruct", `// {{.MockTypeName}} is the mock for {{.InterfaceName}}.
type {{.MockTypeName}}{{.TypeParamsDecl}} struct {
	imp *{{.PkgImptest}}.Imp
{{range .Methods}}{{if .HasParams}}	{{.MethodName}} *{{.MethodTypeName}}{{$.TypeParamsUse}}
{{else}}	{{.MethodName}} *{{$.PkgImptest}}.DependencyMethod
{{end}}{{end}}}

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Constructor template
	//nolint:lll // Template docstring
	registry.v2DepConstructorTmpl, err = parseTemplate("v2DepConstructor", `// {{.MockName}} creates a new {{.MockTypeName}} for testing.
func {{.MockName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter) *{{.MockTypeName}}{{.TypeParamsUse}} {
	imp := {{.PkgImptest}}.NewImp(t)
	return &{{.MockTypeName}}{{.TypeParamsUse}}{
		imp: imp,
{{range .Methods}}{{if .HasParams}}		{{.MethodName}}: &{{.MethodTypeName}}{{$.TypeParamsUse}}{DependencyMethod: {{$.PkgImptest}}.NewDependencyMethod(imp, "{{.MethodName}}")},
{{else}}		{{.MethodName}}: {{$.PkgImptest}}.NewDependencyMethod(imp, "{{.MethodName}}"),
{{end}}{{end}}	}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Interface Method template
	//nolint:lll // Template docstring
	registry.v2DepInterfaceMethodTmpl, err = parseTemplate("v2DepInterfaceMethod", `// Interface returns the {{.InterfaceName}} implementation that can be passed to code under test.
func (m *{{.MockTypeName}}{{.TypeParamsUse}}) Interface() {{.InterfaceType}} {
	return &{{.ImplName}}{{.TypeParamsUse}}{mock: m}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Impl Struct template
	registry.v2DepImplStructTmpl, err = parseTemplate("v2DepImplStruct", `// {{.ImplName}} implements {{.InterfaceType}}.
type {{.ImplName}}{{.TypeParamsDecl}} struct {
	mock *{{.MockTypeName}}{{.TypeParamsUse}}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Impl Method template
	//nolint:lll // Template docstring
	registry.v2DepImplMethodTmpl, err = parseTemplate("v2DepImplMethod", `// {{.MethodName}} implements {{.InterfaceType}}.{{.MethodName}}.
func (impl *{{.ImplName}}{{.TypeParamsUse}}) {{.MethodName}}({{.Params}}){{.Results}} {
	{{if .HasVariadic}}callArgs := []any{ {{.NonVariadicArgs}} }
	for _, v := range {{.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	{{end}}call := &{{.PkgImptest}}.GenericCall{
		MethodName: "{{.MethodName}}",
		Args: {{if .HasVariadic}}callArgs{{else}}[]any{ {{.Args}} }{{end}},
		ResponseChan: make(chan {{.PkgImptest}}.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}
	{{if .HasResults}}{{range .ResultVars}}
	var {{.Name}} {{.Type}}
	if len(resp.ReturnValues) > {{.Index}} {
		if value, ok := resp.ReturnValues[{{.Index}}].({{.Type}}); ok {
			{{.Name}} = value
		}
	}
	{{end}}
	return {{.ReturnList}}{{end}}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Args Struct template
	//nolint:lll // Template string
	registry.v2DepArgsStructTmpl, err = parseTemplate("v2DepArgsStruct", `{{if .HasParams}}// {{.ArgsTypeName}} holds typed arguments for {{.MethodName}}.
type {{.ArgsTypeName}}{{.TypeParamsDecl}} struct {
{{range .ParamFields}}	{{.Name}} {{.Type}}
{{end}}}

{{end}}`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Call Wrapper template
	//nolint:lll // Template string
	registry.v2DepCallWrapperTmpl, err = parseTemplate("v2DepCallWrapper", `{{if .HasParams}}// {{.CallTypeName}} wraps DependencyCall with typed GetArgs.
type {{.CallTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *{{.CallTypeName}}{{.TypeParamsUse}}) GetArgs() {{.ArgsTypeName}}{{.TypeParamsUse}} {
	raw := c.RawArgs()
	return {{.ArgsTypeName}}{{.TypeParamsUse}}{
{{range .ParamFields}}		{{.Name}}: raw[{{.Index}}].({{.Type}}),
{{end}}	}
}
{{end}}
`)
	if err != nil {
		return nil, err
	}

	// V2 Dependency Method Wrapper template
	//nolint:lll // Template strings naturally exceed line length
	registry.v2DepMethodWrapperTmpl, err = parseTemplate("v2DepMethodWrapper", `{{if .HasParams}}// {{.MethodTypeName}} wraps DependencyMethod with typed returns.
type {{.MethodTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyMethod
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *{{.MethodTypeName}}{{.TypeParamsUse}}) ExpectCalledWithExactly({{.TypedParams}}) *{{.CallTypeName}}{{.TypeParamsUse}} {
	{{if .HasVariadic}}callArgs := []any{ {{if .NonVariadicArgs}}{{.NonVariadicArgs}}{{end}} }
	for _, v := range {{.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	call := m.DependencyMethod.ExpectCalledWithExactly(callArgs...){{else}}call := m.DependencyMethod.ExpectCalledWithExactly({{.ArgNames}}){{end}}
	return &{{.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *{{.MethodTypeName}}{{.TypeParamsUse}}) ExpectCalledWithMatches(matchers ...any) *{{.CallTypeName}}{{.TypeParamsUse}} {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &{{.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}
{{end}}
`)
	if err != nil {
		return nil, err
	}

	// V2 Target Header template
	registry.v2TargetHeaderTmpl, err = parseTemplate("v2TargetHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	{{.PkgImptest}} "github.com/toejough/imptest/imptest"{{if .NeedsReflect}}
	{{.PkgReflect}} "reflect"{{end}}{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Constructor template
	//nolint:lll // Template docstring
	registry.v2TargetConstructorTmpl, err = parseTemplate("v2TargetConstructor", `// {{.WrapName}} wraps a function for testing.
func {{.WrapName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter, fn {{.FuncSig}}) *{{.WrapperType}}{{.TypeParamsUse}} {
	return &{{.WrapperType}}{{.TypeParamsUse}}{
		CallableController: {{.PkgImptest}}.NewCallableController[{{.ReturnsType}}Return{{.TypeParamsUse}}](t),
		callable:           fn,
	}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Wrapper Struct template
	//nolint:lll // Template docstring
	registry.v2TargetWrapperStructTmpl, err = parseTemplate("v2TargetWrapperStruct", `// {{.WrapperType}} wraps a function for testing.
type {{.WrapperType}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.CallableController[{{.ReturnsType}}Return{{.TypeParamsUse}}]
	callable {{.FuncSig}}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Start Method template
	//nolint:lll // Template docstring
	registry.v2TargetStartMethodTmpl, err = parseTemplate("v2TargetStartMethod", `// Start executes the wrapped function in a goroutine.
func (w *{{.WrapperType}}{{.TypeParamsUse}}) Start({{.Params}}) *{{.WrapperType}}{{.TypeParamsUse}} {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				w.PanicChan <- r
			}
		}()
		{{if .HasResults}}{{.ResultVars}} := w.callable({{.ParamNames}})
		w.ReturnChan <- {{.ReturnsType}}Return{{.TypeParamsUse}}{ {{.ReturnAssignments}} }{{else}}w.callable({{.ParamNames}})
		w.ReturnChan <- {{.ReturnsType}}Return{{.TypeParamsUse}}{}{{end}}
	}()
	return w
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Wait Method template - NOT USED (CallableController provides WaitForResponse/WaitForCompletion)
	registry.v2TargetWaitMethodTmpl, err = parseTemplate("v2TargetWaitMethod", ``)
	if err != nil {
		return nil, err
	}

	// V2 Target Expect Returns template
	//nolint:lll // Template docstring
	registry.v2TargetExpectReturnsTmpl, err = parseTemplate("v2TargetExpectReturns", `// ExpectReturnsEqual verifies the function returned the expected values.
func (w *{{.WrapperType}}{{.TypeParamsUse}}) ExpectReturnsEqual({{.ExpectedParams}}) {
	w.T.Helper()
	w.WaitForResponse()

	if w.Returned != nil {
		{{range .ResultChecks}}if !_reflect.DeepEqual(w.Returned.{{.Field}}, {{.Expected}}) {
			w.T.Fatalf("expected return value {{.Index}} to be %v, got %v", {{.Expected}}, w.Returned.{{.Field}})
		}
		{{end}}return
	}

	w.T.Fatalf("expected function to return, but it panicked with: %v", w.Panicked)
}

// ExpectReturnsMatch verifies the return values match the given matchers.
func (w *{{.WrapperType}}{{.TypeParamsUse}}) ExpectReturnsMatch({{.MatcherParams}}) {
	w.T.Helper()
	w.WaitForResponse()

	if w.Returned != nil {
		var ok bool
		var msg string
		{{range .ResultChecks}}ok, msg = {{$.PkgImptest}}.MatchValue(w.Returned.{{.Field}}, {{.Expected}})
		if !ok {
			w.T.Fatalf("return value {{.Index}}: %s", msg)
		}
		{{end}}return
	}

	w.T.Fatalf("expected function to return, but it panicked with: %v", w.Panicked)
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Expect Completes template
	//nolint:lll // Template docstring
	registry.v2TargetExpectCompletesTmpl, err = parseTemplate("v2TargetExpectCompletes", `// ExpectCompletes verifies the function completes without panicking.
func (w *{{.WrapperType}}{{.TypeParamsUse}}) ExpectCompletes() {
	w.T.Helper()
	w.WaitForResponse()

	if w.Panicked != nil {
		w.T.Fatalf("expected function to complete, but it panicked with: %v", w.Panicked)
	}
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Expect Panic template
	//nolint:lll // Template docstring
	registry.v2TargetExpectPanicTmpl, err = parseTemplate("v2TargetExpectPanic", `// ExpectPanicEquals verifies the function panics with the expected value.
func (w *{{.WrapperType}}{{.TypeParamsUse}}) ExpectPanicEquals(expected any) {
	w.T.Helper()
	w.WaitForResponse()

	if w.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(w.Panicked, expected)
		if !ok {
			w.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	w.T.Fatalf("expected function to panic, but it returned")
}

// ExpectPanicMatches verifies the function panics with a value matching the given matcher.
func (w *{{.WrapperType}}{{.TypeParamsUse}}) ExpectPanicMatches(matcher any) {
	w.T.Helper()
	w.WaitForResponse()

	if w.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(w.Panicked, matcher)
		if !ok {
			w.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	w.T.Fatalf("expected function to panic, but it returned")
}

`)
	if err != nil {
		return nil, err
	}

	// V2 Target Returns Struct template
	//nolint:lll // Template docstring
	registry.v2TargetReturnsStructTmpl, err = parseTemplate("v2TargetReturnsStruct", `// {{.ReturnsType}}Return holds the return values from the wrapped function.
type {{.ReturnsType}}Return{{.TypeParamsDecl}} struct {
	{{if .HasResults}}{{range .ResultFields}}{{.Name}} {{.Type}}
	{{end}}{{end}}}

`)
	if err != nil {
		return nil, err
	}

	return registry, nil
}

// WriteV2DepArgsStruct writes the v2 dependency args struct.
func (r *TemplateRegistry) WriteV2DepArgsStruct(buf *bytes.Buffer, data any) {
	err := r.v2DepArgsStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepArgsStruct template: %v", err))
	}
}

// WriteV2DepCallWrapper writes the v2 dependency call wrapper.
func (r *TemplateRegistry) WriteV2DepCallWrapper(buf *bytes.Buffer, data any) {
	err := r.v2DepCallWrapperTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepCallWrapper template: %v", err))
	}
}

// WriteV2DepConstructor writes the v2 dependency mock constructor.
func (r *TemplateRegistry) WriteV2DepConstructor(buf *bytes.Buffer, data any) {
	err := r.v2DepConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepConstructor template: %v", err))
	}
}

// WriteV2DepHeader writes the v2 dependency mock header.
func (r *TemplateRegistry) WriteV2DepHeader(buf *bytes.Buffer, data any) {
	err := r.v2DepHeaderTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepHeader template: %v", err))
	}
}

// WriteV2DepImplMethod writes a v2 dependency implementation method.
func (r *TemplateRegistry) WriteV2DepImplMethod(buf *bytes.Buffer, data any) {
	err := r.v2DepImplMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepImplMethod template: %v", err))
	}
}

// WriteV2DepImplStruct writes the v2 dependency implementation struct.
func (r *TemplateRegistry) WriteV2DepImplStruct(buf *bytes.Buffer, data any) {
	err := r.v2DepImplStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepImplStruct template: %v", err))
	}
}

// WriteV2DepInterfaceMethod writes the v2 dependency Interface() method.
func (r *TemplateRegistry) WriteV2DepInterfaceMethod(buf *bytes.Buffer, data any) {
	err := r.v2DepInterfaceMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepInterfaceMethod template: %v", err))
	}
}

// WriteV2DepMethodWrapper writes the v2 dependency method wrapper.
func (r *TemplateRegistry) WriteV2DepMethodWrapper(buf *bytes.Buffer, data any) {
	err := r.v2DepMethodWrapperTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepMethodWrapper template: %v", err))
	}
}

// WriteV2DepMockStruct writes the v2 dependency mock struct.
func (r *TemplateRegistry) WriteV2DepMockStruct(buf *bytes.Buffer, data any) {
	err := r.v2DepMockStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2DepMockStruct template: %v", err))
	}
}

// WriteV2TargetConstructor writes the v2 target wrapper constructor.
func (r *TemplateRegistry) WriteV2TargetConstructor(buf *bytes.Buffer, data any) {
	err := r.v2TargetConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetConstructor template: %v", err))
	}
}

// WriteV2TargetExpectCompletes writes the v2 target ExpectCompletes method.
func (r *TemplateRegistry) WriteV2TargetExpectCompletes(buf *bytes.Buffer, data any) {
	err := r.v2TargetExpectCompletesTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetExpectCompletes template: %v", err))
	}
}

// WriteV2TargetExpectPanic writes the v2 target ExpectPanic methods.
func (r *TemplateRegistry) WriteV2TargetExpectPanic(buf *bytes.Buffer, data any) {
	err := r.v2TargetExpectPanicTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetExpectPanic template: %v", err))
	}
}

// WriteV2TargetExpectReturns writes the v2 target ExpectReturns methods.
func (r *TemplateRegistry) WriteV2TargetExpectReturns(buf *bytes.Buffer, data any) {
	err := r.v2TargetExpectReturnsTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetExpectReturns template: %v", err))
	}
}

// WriteV2TargetHeader writes the v2 target wrapper header.
func (r *TemplateRegistry) WriteV2TargetHeader(buf *bytes.Buffer, data any) {
	err := r.v2TargetHeaderTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetHeader template: %v", err))
	}
}

// WriteV2TargetReturnsStruct writes the v2 target returns struct.
func (r *TemplateRegistry) WriteV2TargetReturnsStruct(buf *bytes.Buffer, data any) {
	err := r.v2TargetReturnsStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetReturnsStruct template: %v", err))
	}
}

// WriteV2TargetStartMethod writes the v2 target Start method.
func (r *TemplateRegistry) WriteV2TargetStartMethod(buf *bytes.Buffer, data any) {
	err := r.v2TargetStartMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetStartMethod template: %v", err))
	}
}

// WriteV2TargetWaitMethod writes the v2 target Wait method.
func (r *TemplateRegistry) WriteV2TargetWaitMethod(buf *bytes.Buffer, data any) {
	err := r.v2TargetWaitMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetWaitMethod template: %v", err))
	}
}

// WriteV2TargetWrapperStruct writes the v2 target wrapper struct.
func (r *TemplateRegistry) WriteV2TargetWrapperStruct(buf *bytes.Buffer, data any) {
	err := r.v2TargetWrapperStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute v2TargetWrapperStruct template: %v", err))
	}
}

// parseTemplate is a helper function that parses a template with consistent error handling.
// Returns the parsed template or an error with a descriptive message.
func parseTemplate(name, content string) (*template.Template, error) {
	tmpl, err := template.New(name).Parse(content)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s template: %w", name, err)
	}

	return tmpl, nil
}
