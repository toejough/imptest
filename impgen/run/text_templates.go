package run

import (
	"bytes"
	"fmt"
	"text/template"
)

// TemplateRegistry holds all parsed text templates for code generation.
// Create a registry using NewTemplateRegistry() to initialize all templates.
type TemplateRegistry struct {
	// Dependency templates
	depHeaderTmpl          *template.Template
	depMockStructTmpl      *template.Template
	depConstructorTmpl     *template.Template
	depInterfaceMethodTmpl *template.Template
	depImplStructTmpl      *template.Template
	depImplMethodTmpl      *template.Template
	depArgsStructTmpl      *template.Template
	depCallWrapperTmpl     *template.Template
	depMethodWrapperTmpl   *template.Template
	// Target wrapper templates
	targetHeaderTmpl           *template.Template
	targetConstructorTmpl      *template.Template
	targetWrapperStructTmpl    *template.Template
	targetCallHandleStructTmpl *template.Template
	targetStartMethodTmpl      *template.Template
	targetWaitMethodTmpl       *template.Template
	targetExpectReturnsTmpl    *template.Template
	targetExpectCompletesTmpl  *template.Template
	targetExpectPanicTmpl      *template.Template
	targetReturnsStructTmpl    *template.Template
	// Interface Target wrapper templates
	interfaceTargetHeaderTmpl                 *template.Template
	interfaceTargetWrapperStructTmpl          *template.Template
	interfaceTargetConstructorTmpl            *template.Template
	interfaceTargetMethodWrapperFuncTmpl      *template.Template
	interfaceTargetMethodWrapperStructTmpl    *template.Template
	interfaceTargetMethodCallHandleStructTmpl *template.Template
	interfaceTargetMethodStartTmpl            *template.Template
	interfaceTargetMethodReturnsTmpl          *template.Template
	interfaceTargetMethodExpectReturnsTmpl    *template.Template
	interfaceTargetMethodExpectCompletesTmpl  *template.Template
	interfaceTargetMethodExpectPanicTmpl      *template.Template
	// Function dependency templates
	funcDepMockStructTmpl    *template.Template
	funcDepConstructorTmpl   *template.Template
	funcDepFuncMethodTmpl    *template.Template
	funcDepMethodWrapperTmpl *template.Template
}

// NewTemplateRegistry creates and initializes a new template registry with all templates parsed.
//
//nolint:cyclop,funlen,gocyclo,gocognit,maintidx // Template parsing requires comprehensive initialization
func NewTemplateRegistry() (*TemplateRegistry, error) {
	registry := &TemplateRegistry{}

	var err error

	// Dependency Header template
	registry.depHeaderTmpl, err = parseTemplate("depHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	{{.PkgImptest}} "github.com/toejough/imptest/imptest"{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`)
	if err != nil {
		return nil, err
	}

	// Dependency Mock Struct template
	//nolint:lll // Template docstring
	registry.depMockStructTmpl, err = parseTemplate("depMockStruct", `// {{.MockTypeName}} is the mock for {{.InterfaceName}}.
type {{.MockTypeName}}{{.TypeParamsDecl}} struct {
	imp *{{.PkgImptest}}.Imp
{{range .Methods}}{{if .HasParams}}	{{.MethodName}} *{{.MethodTypeName}}{{$.TypeParamsUse}}
{{else}}	{{.MethodName}} *{{$.PkgImptest}}.DependencyMethod
{{end}}{{end}}}

`)
	if err != nil {
		return nil, err
	}

	// Dependency Constructor template
	//nolint:lll // Template docstring
	registry.depConstructorTmpl, err = parseTemplate("depConstructor", `// {{.MockName}} creates a new {{.MockTypeName}} for testing.
func {{.MockName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter) *{{.MockTypeName}}{{.TypeParamsUse}} {
	imp := {{.PkgImptest}}.NewImp(t)
	return &{{.MockTypeName}}{{.TypeParamsUse}}{
		imp: imp,
{{range .Methods}}{{if .HasParams}}		{{.MethodName}}: &{{.MethodTypeName}}{{$.TypeParamsUse}}{DependencyMethod: {{$.PkgImptest}}.NewDependencyMethod(imp, "{{.MethodName}}")},
{{else}}		{{.MethodName}}: {{$.PkgImptest}}.NewDependencyMethod(imp, "{{.MethodName}}"),
{{end}}{{end}}	}
}

`)
	if err != nil {
		return nil, err
	}

	// Dependency Interface Method template
	//nolint:lll // Template docstring
	registry.depInterfaceMethodTmpl, err = parseTemplate("depInterfaceMethod", `// Interface returns the {{.InterfaceName}} implementation that can be passed to code under test.
func (m *{{.MockTypeName}}{{.TypeParamsUse}}) Interface() {{.InterfaceType}} {
	return &{{.ImplName}}{{.TypeParamsUse}}{mock: m}
}

`)
	if err != nil {
		return nil, err
	}

	// Dependency Impl Struct template
	registry.depImplStructTmpl, err = parseTemplate("depImplStruct", `// {{.ImplName}} implements {{.InterfaceType}}.
type {{.ImplName}}{{.TypeParamsDecl}} struct {
	mock *{{.MockTypeName}}{{.TypeParamsUse}}
}

`)
	if err != nil {
		return nil, err
	}

	// Dependency Impl Method template
	//nolint:lll // Template docstring
	registry.depImplMethodTmpl, err = parseTemplate("depImplMethod", `// {{.MethodName}} implements {{.InterfaceType}}.{{.MethodName}}.
func (impl *{{.ImplName}}{{.TypeParamsUse}}) {{.MethodName}}({{.Params}}){{.Results}} {
	{{if .HasVariadic}}callArgs := []any{ {{.NonVariadicArgs}} }
	for _, v := range {{.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	{{end}}call := &{{.PkgImptest}}.GenericCall{
		MethodName: "{{.MethodName}}",
		Args: {{if .HasVariadic}}callArgs{{else}}[]any{ {{.Args}} }{{end}},
		ResponseChan: make(chan {{.PkgImptest}}.GenericResponse, 1),
	}
	impl.mock.imp.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}
	{{if .HasResults}}{{range .ResultVars}}
	var {{.Name}} {{.Type}}
	if len(resp.ReturnValues) > {{.Index}} {
		if value, ok := resp.ReturnValues[{{.Index}}].({{.Type}}); ok {
			{{.Name}} = value
		}
	}
	{{end}}
	return {{.ReturnList}}{{end}}
}

`)
	if err != nil {
		return nil, err
	}

	// Dependency Args Struct template
	//nolint:lll // Template string
	registry.depArgsStructTmpl, err = parseTemplate("depArgsStruct", `{{if .HasParams}}// {{.ArgsTypeName}} holds typed arguments for {{.MethodName}}.
type {{.ArgsTypeName}}{{.TypeParamsDecl}} struct {
{{range .ParamFields}}	{{.Name}} {{.Type}}
{{end}}}

{{end}}`)
	if err != nil {
		return nil, err
	}

	// Dependency Call Wrapper template
	//nolint:lll // Template string
	registry.depCallWrapperTmpl, err = parseTemplate("depCallWrapper", `{{if or .HasParams .HasResults}}// {{.CallTypeName}} wraps DependencyCall with typed GetArgs{{if .HasResults}} and InjectReturnValues{{end}}.
type {{.CallTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyCall
}
{{if .HasParams}}
// GetArgs returns the typed arguments for this call.
func (c *{{.CallTypeName}}{{.TypeParamsUse}}) GetArgs() {{.ArgsTypeName}}{{.TypeParamsUse}} {
	raw := c.RawArgs()
	return {{.ArgsTypeName}}{{.TypeParamsUse}}{
{{range .ParamFields}}		{{.Name}}: raw[{{.Index}}].({{.Type}}),
{{end}}	}
}
{{end}}{{if .HasResults}}
// InjectReturnValues specifies the typed values the mock should return.
func (c *{{.CallTypeName}}{{.TypeParamsUse}}) InjectReturnValues({{.TypedReturnParams}}) {
	c.DependencyCall.InjectReturnValues({{.ReturnParamNames}})
}
{{end}}{{end}}
`)
	if err != nil {
		return nil, err
	}

	// Dependency Method Wrapper template
	//nolint:lll // Template strings naturally exceed line length
	registry.depMethodWrapperTmpl, err = parseTemplate("depMethodWrapper", `{{if .HasParams}}// {{.MethodTypeName}} wraps DependencyMethod with typed returns.
type {{.MethodTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyMethod
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *{{.MethodTypeName}}{{.TypeParamsUse}}) ExpectCalledWithExactly({{.TypedParams}}) *{{.CallTypeName}}{{.TypeParamsUse}} {
	{{if .HasVariadic}}callArgs := []any{ {{if .NonVariadicArgs}}{{.NonVariadicArgs}}{{end}} }
	for _, v := range {{.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	call := m.DependencyMethod.ExpectCalledWithExactly(callArgs...){{else}}call := m.DependencyMethod.ExpectCalledWithExactly({{.ArgNames}}){{end}}
	return &{{.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *{{.MethodTypeName}}{{.TypeParamsUse}}) ExpectCalledWithMatches(matchers ...any) *{{.CallTypeName}}{{.TypeParamsUse}} {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &{{.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *{{.MethodTypeName}}{{.TypeParamsUse}}) Eventually() *{{.MethodTypeName}}{{.TypeParamsUse}} {
	return &{{.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: m.DependencyMethod.Eventually()}
}
{{end}}
`)
	if err != nil {
		return nil, err
	}

	// Target Header template
	registry.targetHeaderTmpl, err = parseTemplate("targetHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	{{.PkgImptest}} "github.com/toejough/imptest/imptest"{{if .NeedsReflect}}
	{{.PkgReflect}} "reflect"{{end}}{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`)
	if err != nil {
		return nil, err
	}

	// Target Constructor template
	//nolint:lll // Template docstring
	registry.targetConstructorTmpl, err = parseTemplate("targetConstructor", `// {{.WrapName}} wraps a function for testing.
func {{.WrapName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter, fn {{.FuncSig}}) *{{.WrapperType}}{{.TypeParamsUse}} {
	return &{{.WrapperType}}{{.TypeParamsUse}}{
		t:        t,
		callable: fn,
	}
}

`)
	if err != nil {
		return nil, err
	}

	// Target Wrapper Struct template
	//nolint:lll // Template docstring
	registry.targetWrapperStructTmpl, err = parseTemplate("targetWrapperStruct", `// {{.WrapperType}} wraps a function for testing.
type {{.WrapperType}}{{.TypeParamsDecl}} struct {
	t        {{.PkgImptest}}.TestReporter
	callable {{.FuncSig}}
}

`)
	if err != nil {
		return nil, err
	}

	// Target CallHandle Struct template
	//nolint:lll // Template docstring
	registry.targetCallHandleStructTmpl, err = parseTemplate("targetCallHandleStruct", `// {{.CallHandleType}} represents a single call to the wrapped function.
type {{.CallHandleType}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.CallableController[{{.ReturnsType}}Return{{.TypeParamsUse}}]
}

`)
	if err != nil {
		return nil, err
	}

	// Target Start Method template
	//nolint:lll // Template docstring
	registry.targetStartMethodTmpl, err = parseTemplate("targetStartMethod", `// Start executes the wrapped function in a goroutine.
func (w *{{.WrapperType}}{{.TypeParamsUse}}) Start({{.Params}}) *{{.CallHandleType}}{{.TypeParamsUse}} {
	handle := &{{.CallHandleType}}{{.TypeParamsUse}}{
		CallableController: {{.PkgImptest}}.NewCallableController[{{.ReturnsType}}Return{{.TypeParamsUse}}](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		{{if .HasResults}}{{.ResultVars}} := w.callable({{.ParamNames}})
		handle.ReturnChan <- {{.ReturnsType}}Return{{.TypeParamsUse}}{ {{.ReturnAssignments}} }{{else}}w.callable({{.ParamNames}})
		handle.ReturnChan <- {{.ReturnsType}}Return{{.TypeParamsUse}}{}{{end}}
	}()
	return handle
}

`)
	if err != nil {
		return nil, err
	}

	// Target Wait Method template - NOT USED (CallableController provides WaitForResponse/WaitForCompletion)
	registry.targetWaitMethodTmpl, err = parseTemplate("targetWaitMethod", ``)
	if err != nil {
		return nil, err
	}

	// Target Expect Returns template
	//nolint:lll // Template docstring
	registry.targetExpectReturnsTmpl, err = parseTemplate("targetExpectReturns", `// ExpectReturnsEqual verifies the function returned the expected values.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectReturnsEqual({{.ExpectedParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		{{range .ResultChecks}}if !_reflect.DeepEqual(h.Returned.{{.Field}}, {{.Expected}}) {
			h.T.Fatalf("expected return value {{.Index}} to be %v, got %v", {{.Expected}}, h.Returned.{{.Field}})
		}
		{{end}}return
	}

	h.T.Fatalf("expected function to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnsMatch verifies the return values match the given matchers.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectReturnsMatch({{.MatcherParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		{{range .ResultChecks}}ok, msg = {{$.PkgImptest}}.MatchValue(h.Returned.{{.Field}}, {{.Expected}})
		if !ok {
			h.T.Fatalf("return value {{.Index}}: %s", msg)
		}
		{{end}}return
	}

	h.T.Fatalf("expected function to return, but it panicked with: %v", h.Panicked)
}

`)
	if err != nil {
		return nil, err
	}

	// Target Expect Completes template
	//nolint:lll // Template docstring
	registry.targetExpectCompletesTmpl, err = parseTemplate("targetExpectCompletes", `// ExpectCompletes verifies the function completes without panicking.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected function to complete, but it panicked with: %v", h.Panicked)
	}
}

`)
	if err != nil {
		return nil, err
	}

	// Target Expect Panic template
	//nolint:lll // Template docstring
	registry.targetExpectPanicTmpl, err = parseTemplate("targetExpectPanic", `// ExpectPanicEquals verifies the function panics with the expected value.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectPanicEquals(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected function to panic, but it returned")
}

// ExpectPanicMatches verifies the function panics with a value matching the given matcher.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectPanicMatches(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected function to panic, but it returned")
}

`)
	if err != nil {
		return nil, err
	}

	// Target Returns Struct template
	//nolint:lll // Template docstring
	registry.targetReturnsStructTmpl, err = parseTemplate("targetReturnsStruct", `// {{.ReturnsType}}Return holds the return values from the wrapped function.
type {{.ReturnsType}}Return{{.TypeParamsDecl}} struct {
	{{if .HasResults}}{{range .ResultFields}}{{.Name}} {{.Type}}
	{{end}}{{end}}}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Header template
	//nolint:lll // Template definition
	registry.interfaceTargetHeaderTmpl, err = parseTemplate("interfaceTargetHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	"testing"
	{{.PkgImptest}} "github.com/toejough/imptest/imptest"{{if .NeedsReflect}}
	{{.PkgReflect}} "reflect"{{end}}{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Wrapper Struct template
	//nolint:lll // Template docstring
	registry.interfaceTargetWrapperStructTmpl, err = parseTemplate("interfaceTargetWrapperStruct", `// {{.WrapperType}} wraps an implementation of {{.InterfaceType}} to intercept method calls.
type {{.WrapperType}} struct {
	{{.ImplName}} {{if .IsStructType}}*{{end}}{{.InterfaceType}}
{{range .Methods}}	{{.MethodName}} *{{.WrapperType}}
{{end}}}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Constructor template
	//nolint:lll // Template docstring
	registry.interfaceTargetConstructorTmpl, err = parseTemplate("interfaceTargetConstructor", `// {{.WrapName}} creates a new wrapper for the given {{.InterfaceType}} implementation.
func {{.WrapName}}(t *testing.T, {{.ImplName}} {{if .IsStructType}}*{{end}}{{.InterfaceType}}) *{{.WrapperType}} {
	w := &{{.WrapperType}}{
		{{.ImplName}}: {{.ImplName}},
	}
{{range .Methods}}	w.{{.MethodName}} = {{.WrapName}}(t, func({{.Params}}){{if .HasResults}} {{.ReturnsType}}{{end}} {
{{if .HasResults}}		{{.ResultVars}} := w.{{$.ImplName}}.{{.MethodName}}({{.ParamNames}})
		return {{.ReturnsType}}{ {{.ReturnAssignments}} }
{{else}}		w.{{$.ImplName}}.{{.MethodName}}({{.ParamNames}})
		return {{.ReturnsType}}{}
{{end}}	})
{{end}}	return w
}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Method Wrapper Function template
	//nolint:lll // Template definition
	registry.interfaceTargetMethodWrapperFuncTmpl, err = parseTemplate("interfaceTargetMethodWrapperFunc", `func {{.WrapName}}(t *testing.T, fn func({{.Params}}){{if .HasResults}} {{.ReturnsType}}{{end}}) *{{.WrapperType}} {
	return &{{.WrapperType}}{t: t, fn: fn}
}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Method Wrapper Struct template
	//nolint:lll // Template definition
	registry.interfaceTargetMethodWrapperStructTmpl, err = parseTemplate("interfaceTargetMethodWrapperStruct", `type {{.WrapperType}} struct {
	t *testing.T
	fn func({{.Params}}){{if .HasResults}} {{.ReturnsType}}{{end}}
}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Method CallHandle Struct template
	//nolint:lll // Template definition
	registry.interfaceTargetMethodCallHandleStructTmpl, err = parseTemplate("interfaceTargetMethodCallHandleStruct", `// {{.CallHandleType}} represents a single call to the wrapped method.
type {{.CallHandleType}} struct {
	*{{.PkgImptest}}.CallableController[{{.ReturnsType}}]
}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Method Start template
	//nolint:lll // Template definition
	registry.interfaceTargetMethodStartTmpl, err = parseTemplate("interfaceTargetMethodStart", `// Start executes the wrapped method in a goroutine.
func (w *{{.WrapperType}}) Start({{.Params}}) *{{.CallHandleType}} {
	handle := &{{.CallHandleType}}{
		CallableController: {{.PkgImptest}}.NewCallableController[{{.ReturnsType}}](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn({{.ParamNames}})
		handle.ReturnChan <- returns
	}()
	return handle
}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Method Returns template
	//nolint:lll // Template definition
	registry.interfaceTargetMethodReturnsTmpl, err = parseTemplate("interfaceTargetMethodReturns", `type {{.ReturnsType}} struct {
{{range .ResultFields}}	{{.Name}} {{.Type}}
{{end}}}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Method Expect Returns template
	//nolint:lll // Template docstring
	registry.interfaceTargetMethodExpectReturnsTmpl, err = parseTemplate("interfaceTargetMethodExpectReturns", `// ExpectReturnsEqual verifies the method returned the expected values.
func (h *{{.CallHandleType}}) ExpectReturnsEqual({{.ExpectedParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		{{range .ResultChecks}}if !_reflect.DeepEqual(h.Returned.{{.Field}}, {{.Expected}}) {
			h.T.Fatalf("expected return value {{.Index}} to be %v, got %v", {{.Expected}}, h.Returned.{{.Field}})
		}
		{{end}}return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnsMatch verifies the return values match the given matchers.
func (h *{{.CallHandleType}}) ExpectReturnsMatch({{.MatcherParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		{{range .ResultChecks}}ok, msg = {{$.PkgImptest}}.MatchValue(h.Returned.{{.Field}}, {{.Expected}})
		if !ok {
			h.T.Fatalf("return value {{.Index}}: %s", msg)
		}
		{{end}}return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Method Expect Completes template
	//nolint:lll // Template docstring
	registry.interfaceTargetMethodExpectCompletesTmpl, err = parseTemplate("interfaceTargetMethodExpectCompletes", `// ExpectCompletes verifies the method completes without panicking.
func (h *{{.CallHandleType}}) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Method Expect Panic template
	//nolint:lll // Template docstring
	registry.interfaceTargetMethodExpectPanicTmpl, err = parseTemplate("interfaceTargetMethodExpectPanic", `// ExpectPanicEquals verifies the method panics with the expected value.
func (h *{{.CallHandleType}}) ExpectPanicEquals(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectPanicMatches verifies the method panics with a value matching the given matcher.
func (h *{{.CallHandleType}}) ExpectPanicMatches(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

`)
	if err != nil {
		return nil, err
	}

	// Interface Target Call Record Struct template - REMOVED (call tracking eliminated)

	// Function Dependency Mock Struct template
	//nolint:lll // Template docstring
	registry.funcDepMockStructTmpl, err = parseTemplate("funcDepMockStruct", `// {{.MockTypeName}} is the mock for {{.FuncName}} function.
type {{.MockTypeName}}{{.TypeParamsDecl}} struct {
	imp *{{.PkgImptest}}.Imp
{{if .Method.HasParams}}	*{{.Method.MethodTypeName}}{{.TypeParamsUse}}
{{else}}	*{{.PkgImptest}}.DependencyMethod
{{end}}}

`)
	if err != nil {
		return nil, err
	}

	// Function Dependency Constructor template
	//nolint:lll // Template docstring
	registry.funcDepConstructorTmpl, err = parseTemplate("funcDepConstructor", `// {{.MockName}} creates a new {{.MockTypeName}} for testing.
func {{.MockName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter) *{{.MockTypeName}}{{.TypeParamsUse}} {
	imp := {{.PkgImptest}}.NewImp(t)
	return &{{.MockTypeName}}{{.TypeParamsUse}}{
		imp: imp,
{{if .Method.HasParams}}		{{.Method.MethodTypeName}}: &{{.Method.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: {{.PkgImptest}}.NewDependencyMethod(imp, "{{.FuncName}}")},
{{else}}		DependencyMethod: {{.PkgImptest}}.NewDependencyMethod(imp, "{{.FuncName}}"),
{{end}}	}
}

`)
	if err != nil {
		return nil, err
	}

	// Function Dependency Func Method template - returns a function with the same signature
	//nolint:lll // Template docstring
	registry.funcDepFuncMethodTmpl, err = parseTemplate("funcDepFuncMethod", `// Func returns a function that forwards calls to the mock.
func (m *{{.MockTypeName}}{{.TypeParamsUse}}) Func() {{.FuncSig}} {
	return func({{.Method.Params}}){{.Method.Results}} {
		{{if .Method.HasVariadic}}callArgs := []any{ {{.Method.NonVariadicArgs}} }
		for _, v := range {{.Method.VariadicArg}} {
			callArgs = append(callArgs, v)
		}
		{{end}}call := &{{.PkgImptest}}.GenericCall{
			MethodName: "{{.FuncName}}",
			Args: {{if .Method.HasVariadic}}callArgs{{else}}[]any{ {{.Method.Args}} }{{end}},
			ResponseChan: make(chan {{.PkgImptest}}.GenericResponse, 1),
		}
		m.imp.CallChan <- call
		resp := <-call.ResponseChan
		if resp.Type == "panic" {
			panic(resp.PanicValue)
		}
		{{if .Method.HasResults}}{{range .Method.ResultVars}}
		var {{.Name}} {{.Type}}
		if len(resp.ReturnValues) > {{.Index}} {
			if value, ok := resp.ReturnValues[{{.Index}}].({{.Type}}); ok {
				{{.Name}} = value
			}
		}
		{{end}}
		return {{.Method.ReturnList}}{{end}}
	}
}

`)
	if err != nil {
		return nil, err
	}

	// Function Dependency Method Wrapper template
	//nolint:lll // Template strings naturally exceed line length
	registry.funcDepMethodWrapperTmpl, err = parseTemplate("funcDepMethodWrapper", `{{if .Method.HasParams}}// {{.Method.MethodTypeName}} wraps DependencyMethod with typed returns.
type {{.Method.MethodTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyMethod
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *{{.Method.MethodTypeName}}{{.TypeParamsUse}}) ExpectCalledWithExactly({{.Method.TypedParams}}) *{{.Method.CallTypeName}}{{.TypeParamsUse}} {
	{{if .Method.HasVariadic}}callArgs := []any{ {{if .Method.NonVariadicArgs}}{{.Method.NonVariadicArgs}}{{end}} }
	for _, v := range {{.Method.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	call := m.DependencyMethod.ExpectCalledWithExactly(callArgs...){{else}}call := m.DependencyMethod.ExpectCalledWithExactly({{.Method.ArgNames}}){{end}}
	return &{{.Method.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *{{.Method.MethodTypeName}}{{.TypeParamsUse}}) ExpectCalledWithMatches(matchers ...any) *{{.Method.CallTypeName}}{{.TypeParamsUse}} {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &{{.Method.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

// Eventually switches to unordered mode for concurrent code.
// Waits indefinitely for a matching call; mismatches are queued.
// Returns typed wrapper preserving type-safe GetArgs() access.
func (m *{{.Method.MethodTypeName}}{{.TypeParamsUse}}) Eventually() *{{.Method.MethodTypeName}}{{.TypeParamsUse}} {
	return &{{.Method.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: m.DependencyMethod.Eventually()}
}
{{end}}
`)
	if err != nil {
		return nil, err
	}

	return registry, nil
}

// WriteDepArgsStruct writes the dependency args struct.
func (r *TemplateRegistry) WriteDepArgsStruct(buf *bytes.Buffer, data any) {
	err := r.depArgsStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute depArgsStruct template: %v", err))
	}
}

// WriteDepCallWrapper writes the dependency call wrapper.
func (r *TemplateRegistry) WriteDepCallWrapper(buf *bytes.Buffer, data any) {
	err := r.depCallWrapperTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute depCallWrapper template: %v", err))
	}
}

// WriteDepConstructor writes the dependency mock constructor.
func (r *TemplateRegistry) WriteDepConstructor(buf *bytes.Buffer, data any) {
	err := r.depConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute depConstructor template: %v", err))
	}
}

// WriteDepHeader writes the dependency mock header.
func (r *TemplateRegistry) WriteDepHeader(buf *bytes.Buffer, data any) {
	err := r.depHeaderTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute depHeader template: %v", err))
	}
}

// WriteDepImplMethod writes a dependency implementation method.
func (r *TemplateRegistry) WriteDepImplMethod(buf *bytes.Buffer, data any) {
	err := r.depImplMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute depImplMethod template: %v", err))
	}
}

// WriteDepImplStruct writes the dependency implementation struct.
func (r *TemplateRegistry) WriteDepImplStruct(buf *bytes.Buffer, data any) {
	err := r.depImplStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute depImplStruct template: %v", err))
	}
}

// WriteDepInterfaceMethod writes the dependency Interface() method.
func (r *TemplateRegistry) WriteDepInterfaceMethod(buf *bytes.Buffer, data any) {
	err := r.depInterfaceMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute depInterfaceMethod template: %v", err))
	}
}

// WriteDepMethodWrapper writes the dependency method wrapper.
func (r *TemplateRegistry) WriteDepMethodWrapper(buf *bytes.Buffer, data any) {
	err := r.depMethodWrapperTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute depMethodWrapper template: %v", err))
	}
}

// WriteDepMockStruct writes the dependency mock struct.
func (r *TemplateRegistry) WriteDepMockStruct(buf *bytes.Buffer, data any) {
	err := r.depMockStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute depMockStruct template: %v", err))
	}
}

// WriteFuncDepConstructor writes the function dependency mock constructor.
func (r *TemplateRegistry) WriteFuncDepConstructor(buf *bytes.Buffer, data any) {
	err := r.funcDepConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute funcDepConstructor template: %v", err))
	}
}

// WriteFuncDepFuncMethod writes the function dependency Func() method.
func (r *TemplateRegistry) WriteFuncDepFuncMethod(buf *bytes.Buffer, data any) {
	err := r.funcDepFuncMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute funcDepFuncMethod template: %v", err))
	}
}

// WriteFuncDepMethodWrapper writes the function dependency method wrapper.
func (r *TemplateRegistry) WriteFuncDepMethodWrapper(buf *bytes.Buffer, data any) {
	err := r.funcDepMethodWrapperTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute funcDepMethodWrapper template: %v", err))
	}
}

// WriteFuncDepMockStruct writes the function dependency mock struct.
func (r *TemplateRegistry) WriteFuncDepMockStruct(buf *bytes.Buffer, data any) {
	err := r.funcDepMockStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute funcDepMockStruct template: %v", err))
	}
}

// WriteInterfaceTargetConstructor writes the interface target constructor.
func (r *TemplateRegistry) WriteInterfaceTargetConstructor(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetConstructor template: %v", err))
	}
}

// WriteInterfaceTargetHeader writes the interface target header.
func (r *TemplateRegistry) WriteInterfaceTargetHeader(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetHeaderTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetHeader template: %v", err))
	}
}

// WriteInterfaceTargetMethodCallHandleStruct writes the interface target method call handle struct.
func (r *TemplateRegistry) WriteInterfaceTargetMethodCallHandleStruct(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetMethodCallHandleStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetMethodCallHandleStruct template: %v", err))
	}
}

// WriteInterfaceTargetMethodExpectCompletes writes the interface target method ExpectCompletes method.
func (r *TemplateRegistry) WriteInterfaceTargetMethodExpectCompletes(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetMethodExpectCompletesTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetMethodExpectCompletes template: %v", err))
	}
}

// WriteInterfaceTargetMethodExpectPanic writes the interface target method ExpectPanic methods.
func (r *TemplateRegistry) WriteInterfaceTargetMethodExpectPanic(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetMethodExpectPanicTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetMethodExpectPanic template: %v", err))
	}
}

// WriteInterfaceTargetMethodExpectReturns writes the interface target method ExpectReturns methods.
func (r *TemplateRegistry) WriteInterfaceTargetMethodExpectReturns(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetMethodExpectReturnsTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetMethodExpectReturns template: %v", err))
	}
}

// WriteInterfaceTargetMethodReturns writes the interface target method returns struct and methods.
func (r *TemplateRegistry) WriteInterfaceTargetMethodReturns(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetMethodReturnsTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetMethodReturns template: %v", err))
	}
}

// WriteInterfaceTargetMethodStart writes the interface target method Start method.
func (r *TemplateRegistry) WriteInterfaceTargetMethodStart(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetMethodStartTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetMethodStart template: %v", err))
	}
}

// WriteInterfaceTargetMethodWrapperFunc writes the interface target method wrapper function.
func (r *TemplateRegistry) WriteInterfaceTargetMethodWrapperFunc(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetMethodWrapperFuncTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetMethodWrapperFunc template: %v", err))
	}
}

// WriteInterfaceTargetMethodWrapperStruct writes the interface target method wrapper struct.
func (r *TemplateRegistry) WriteInterfaceTargetMethodWrapperStruct(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetMethodWrapperStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetMethodWrapperStruct template: %v", err))
	}
}

// WriteInterfaceTargetWrapperStruct writes the interface target wrapper struct.
func (r *TemplateRegistry) WriteInterfaceTargetWrapperStruct(buf *bytes.Buffer, data any) {
	err := r.interfaceTargetWrapperStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceTargetWrapperStruct template: %v", err))
	}
}

// WriteTargetCallHandleStruct writes the target call handle struct.
func (r *TemplateRegistry) WriteTargetCallHandleStruct(buf *bytes.Buffer, data any) {
	err := r.targetCallHandleStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute targetCallHandleStruct template: %v", err))
	}
}

// WriteTargetConstructor writes the target wrapper constructor.
func (r *TemplateRegistry) WriteTargetConstructor(buf *bytes.Buffer, data any) {
	err := r.targetConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute targetConstructor template: %v", err))
	}
}

// WriteTargetExpectCompletes writes the target ExpectCompletes method.
func (r *TemplateRegistry) WriteTargetExpectCompletes(buf *bytes.Buffer, data any) {
	err := r.targetExpectCompletesTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute targetExpectCompletes template: %v", err))
	}
}

// WriteTargetExpectPanic writes the target ExpectPanic methods.
func (r *TemplateRegistry) WriteTargetExpectPanic(buf *bytes.Buffer, data any) {
	err := r.targetExpectPanicTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute targetExpectPanic template: %v", err))
	}
}

// WriteTargetExpectReturns writes the target ExpectReturns methods.
func (r *TemplateRegistry) WriteTargetExpectReturns(buf *bytes.Buffer, data any) {
	err := r.targetExpectReturnsTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute targetExpectReturns template: %v", err))
	}
}

// WriteTargetHeader writes the target wrapper header.
func (r *TemplateRegistry) WriteTargetHeader(buf *bytes.Buffer, data any) {
	err := r.targetHeaderTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute targetHeader template: %v", err))
	}
}

// WriteTargetReturnsStruct writes the target returns struct.
func (r *TemplateRegistry) WriteTargetReturnsStruct(buf *bytes.Buffer, data any) {
	err := r.targetReturnsStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute targetReturnsStruct template: %v", err))
	}
}

// WriteTargetStartMethod writes the target Start method.
func (r *TemplateRegistry) WriteTargetStartMethod(buf *bytes.Buffer, data any) {
	err := r.targetStartMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute targetStartMethod template: %v", err))
	}
}

// WriteTargetWaitMethod writes the target Wait method.
func (r *TemplateRegistry) WriteTargetWaitMethod(buf *bytes.Buffer, data any) {
	err := r.targetWaitMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute targetWaitMethod template: %v", err))
	}
}

// WriteTargetWrapperStruct writes the target wrapper struct.
func (r *TemplateRegistry) WriteTargetWrapperStruct(buf *bytes.Buffer, data any) {
	err := r.targetWrapperStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute targetWrapperStruct template: %v", err))
	}
}

// parseTemplate is a helper function that parses a template with consistent error handling.
// Returns the parsed template or an error with a descriptive message.
func parseTemplate(name, content string) (*template.Template, error) {
	tmpl, err := template.New(name).Parse(content)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s template: %w", name, err)
	}

	return tmpl, nil
}
