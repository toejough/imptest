package run

import (
	"bytes"
	"fmt"
	"text/template"
)

// TemplateRegistry holds all parsed text templates for code generation.
// Create a registry using NewTemplateRegistry() to initialize all templates.
type TemplateRegistry struct {
	callStructTmpl                         *template.Template
	callableConstructorTmpl                *template.Template
	callableExpectPanicWithTmpl            *template.Template
	callableExpectReturnedValuesAreTmpl    *template.Template
	callableExpectReturnedValuesShouldTmpl *template.Template
	callableHeaderTmpl                     *template.Template
	callableMainStructTmpl                 *template.Template
	callableResponseStructTmpl             *template.Template
	callableResponseTypeMethodTmpl         *template.Template
	callableReturnStructTmpl               *template.Template
	callableStartMethodTmpl                *template.Template
	constructorTmpl                        *template.Template
	expectCallIsStructTmpl                 *template.Template
	getCurrentCallMethodTmpl               *template.Template
	headerTmpl                             *template.Template
	injectPanicTmpl                        *template.Template
	interfaceVerificationTmpl              *template.Template
	mainStructTmpl                         *template.Template
	mockStructTmpl                         *template.Template
	resolveTmpl                            *template.Template
	timedStructTmpl                        *template.Template
}

// NewTemplateRegistry creates and initializes a new template registry with all templates parsed.
//
//nolint:cyclop,funlen,maintidx // Template parsing requires comprehensive initialization
func NewTemplateRegistry() (*TemplateRegistry, error) {
	registry := &TemplateRegistry{}

	var err error

	// Header template
	//nolint:lll,nolintlint
	registry.headerTmpl, err = parseTemplate("header", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import {{.PkgImptest}} "github.com/toejough/imptest/imptest"
{{if .NeedsReflect}}import {{.PkgReflect}} "reflect"
{{end}}import {{.PkgTesting}} "testing"
import {{.PkgTime}} "time"
{{if .NeedsQualifier}}import {{.Qualifier}} "{{.PkgPath}}"
{{end}}`)
	if err != nil {
		return nil, err
	}

	// Constructor template
	//nolint:lll // Template string length driven by generated code structure
	//nolint:lll,nolintlint
	registry.constructorTmpl, err = parseTemplate("constructor", `// New{{.ImpName}} creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := New{{.ImpName}}(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func New{{.ImpName}}{{.TypeParamsDecl}}(t *{{.PkgTesting}}.T) *{{.ImpName}}{{.TypeParamsUse}} {
	imp := &{{.ImpName}}{{.TypeParamsUse}}{
		Controller: {{.PkgImptest}}.NewController[*{{.CallName}}{{.TypeParamsUse}}](t),
	}
	imp.Mock = &{{.MockName}}{{.TypeParamsUse}}{imp: imp}
	imp.ExpectCallIs = &{{.ExpectCallIsName}}{{.TypeParamsUse}}{imp: imp}
	return imp
}

`)
	if err != nil {
		return nil, err
	}

	// ExpectCallIsStruct template
	//nolint:lll // Template string length driven by generated code structure
	//nolint:lll,nolintlint
	registry.expectCallIsStructTmpl, err = parseTemplate("expectCallIsStruct", `// {{.ExpectCallIsName}} provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent {{.ImpName}} to configure timeouts.
type {{.ExpectCallIsName}}{{.TypeParamsDecl}} struct {
	imp *{{.ImpName}}{{.TypeParamsUse}}
	timeout {{.PkgTime}}.Duration
}

`)
	if err != nil {
		return nil, err
	}

	// GetCurrentCallMethod template
	//nolint:lll // Template definition
	//nolint:lll,nolintlint
	registry.getCurrentCallMethodTmpl, err = parseTemplate("getCurrentCallMethod", `// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *{{.ImpName}}{{.TypeParamsUse}}) GetCurrentCall() *{{.CallName}}{{.TypeParamsUse}} {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *{{.CallName}}{{.TypeParamsUse}}) bool { return true })
	return i.currentCall
}

`)
	if err != nil {
		return nil, err
	}

	// InterfaceVerification template
	//nolint:lll,nolintlint
	registry.interfaceVerificationTmpl, err = parseTemplate("interfaceVerification", `var (
	// Compile-time verification that {{.MockName}} implements {{.InterfaceName}}.
	_ {{.InterfaceName}}{{.TypeParamsUse}} = (*{{.MockName}}{{.TypeParamsUse}})(nil)
)

`)
	if err != nil {
		return nil, err
	}

	// MainStruct template
	//nolint:lll,nolintlint
	registry.mainStructTmpl, err = parseTemplate("mainStruct", `// {{.ImpName}} is the test controller for mocking the interface.
// Create with New{{.ImpName}}(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := New{{.ImpName}}(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type {{.ImpName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.Controller[*{{.CallName}}{{.TypeParamsUse}}]
	Mock *{{.MockName}}{{.TypeParamsUse}}
	ExpectCallIs *{{.ExpectCallIsName}}{{.TypeParamsUse}}
	currentCall *{{.CallName}}{{.TypeParamsUse}}
}

`)
	if err != nil {
		return nil, err
	}

	// MockStruct template
	//nolint:lll,nolintlint
	registry.mockStructTmpl, err = parseTemplate("mockStruct", `// {{.MockName}} provides the mock implementation of the interface.
// Pass {{.MockName}} to code under test that expects the interface implementation.
// Use the parent {{.ImpName}} controller to set expectations and inject responses.
type {{.MockName}}{{.TypeParamsDecl}} struct {
	imp *{{.ImpName}}{{.TypeParamsUse}}
}

`)
	if err != nil {
		return nil, err
	}

	// TimedStruct template
	//nolint:lll,nolintlint
	registry.timedStructTmpl, err = parseTemplate("timedStruct", `// {{.TimedName}} provides timeout-configured expectation methods.
// Access via {{.ImpName}}.Within(duration) to set a timeout for expectations.
type {{.TimedName}}{{.TypeParamsDecl}} struct {
	ExpectCallIs *{{.ExpectCallIsName}}{{.TypeParamsUse}}
}

// Within configures a timeout for expectations and returns a {{.TimedName}} for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*{{.PkgTime}}.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *{{.ImpName}}{{.TypeParamsUse}}) Within(d {{.PkgTime}}.Duration) *{{.TimedName}}{{.TypeParamsUse}} {
	return &{{.TimedName}}{{.TypeParamsUse}}{
		ExpectCallIs: &{{.ExpectCallIsName}}{{.TypeParamsUse}}{imp: i, timeout: d},
	}
}

`)
	if err != nil {
		return nil, err
	}

	// InjectPanic template
	//nolint:lll,nolintlint
	registry.injectPanicTmpl, err = parseTemplate("injectPanic", `// InjectPanic causes the mocked method to panic with the given value.
// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *{{.MethodCallName}}{{.TypeParamsUse}}) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{{.TypeParamsUse}}{Type: "panic", PanicValue: msg}
}`)
	if err != nil {
		return nil, err
	}

	// Resolve template
	//nolint:lll,nolintlint
	registry.resolveTmpl, err = parseTemplate("resolve", `// Resolve completes a void method call without error.
// Use this to unblock the mock method and allow execution to continue.
// Only applicable to methods with no return values.
func (c *{{.MethodCallName}}{{.TypeParamsUse}}) Resolve() {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{{.TypeParamsUse}}{Type: "resolve"}
}`)
	if err != nil {
		return nil, err
	}

	// CallStruct template
	//nolint:lll,nolintlint
	registry.callStructTmpl, err = parseTemplate("callStruct", `// {{.CallName}} represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{"{"}}{Method}() to access typed call details.
type {{.CallName}}{{.TypeParamsDecl}} struct {
{{range .Methods}}	{{lowerFirst .Name}} *{{.CallName}}{{.TypeParamsUse}}
{{end}}}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *{{.CallName}}{{.TypeParamsUse}}) Name() string {
{{range .Methods}}	if c.{{lowerFirst .Name}} != nil {
		return "{{.Name}}"
	}
{{end}}	return ""
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *{{.CallName}}{{.TypeParamsUse}}) Done() bool {
{{range .Methods}}	if c.{{lowerFirst .Name}} != nil {
		return c.{{lowerFirst .Name}}.done
	}
{{end}}	return false
}

{{range .Methods}}// As{{.Name}} returns the call cast to {{.CallName}} for accessing call details.
// Returns nil if the call was not to {{.Name}}.
func (c *{{$.CallName}}{{$.TypeParamsUse}}) As{{.Name}}() *{{.CallName}}{{.TypeParamsUse}} {
	return c.{{lowerFirst .Name}}
}

{{end}}`)
	if err != nil {
		return nil, err
	}

	// CallableHeader template
	//nolint:lll,nolintlint
	registry.callableHeaderTmpl, err = parseTemplate("callableHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	{{.PkgImptest}} "github.com/toejough/imptest/imptest"
{{if .NeedsReflect}}	{{.PkgReflect}} "reflect"
{{end}}	{{.PkgTesting}} "testing"
{{if .NeedsQualifier}}	{{.Qualifier}} "{{.PkgPath}}"
{{end}})

`)
	if err != nil {
		return nil, err
	}

	// CallableReturnStruct template
	//nolint:lll,nolintlint
	registry.callableReturnStructTmpl, err = parseTemplate("callableReturnStruct", `{{if .HasReturns}}// {{.ImpName}}Return holds the return values from the callable function.
// Access individual return values via Result0, Result1, etc. fields.
type {{.ImpName}}Return{{.TypeParamsDecl}} struct {
{{range .ReturnFields}}	Result{{.Index}} {{.Type}}
{{end}}}

{{end}}`)
	if err != nil {
		return nil, err
	}

	// CallableMainStruct template
	//nolint:lll,nolintlint
	registry.callableMainStructTmpl, err = parseTemplate("callableMainStruct", `// {{.ImpName}} wraps a callable function for testing.
// Create with New{{.ImpName}}(t, yourFunction), call Start() to execute,
// then use ExpectReturnedValuesAre/Should() or ExpectPanicWith() to verify behavior.
type {{.ImpName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.CallableController[{{.ReturnType}}]
	callable func({{.CallableSignature}}){{.CallableReturns}}
}

`)
	if err != nil {
		return nil, err
	}

	// CallableConstructor template
	//nolint:lll,nolintlint
	registry.callableConstructorTmpl, err = parseTemplate("callableConstructor", `// New{{.ImpName}} creates a new wrapper for testing the callable function.
// Pass the function to test and a testing.TB to enable assertion failures.
//
// Example:
//
//	wrapper := New{{.ImpName}}(t, myFunction)
//	wrapper.Start(args...).ExpectReturnedValuesAre(expectedVals...)
func New{{.ImpName}}{{.TypeParamsDecl}}(t {{.PkgTesting}}.TB, callable func({{.CallableSignature}}){{.CallableReturns}}) *{{.ImpName}}{{.TypeParamsUse}} {
	return &{{.ImpName}}{{.TypeParamsUse}}{
		CallableController: {{.PkgImptest}}.NewCallableController[{{.ReturnType}}](t),
		callable:           callable,
	}
}

`)
	if err != nil {
		return nil, err
	}

	// CallableStartMethod template
	//nolint:lll,nolintlint
	registry.callableStartMethodTmpl, err = parseTemplate("callableStartMethod", `// Start begins execution of the callable in a goroutine with the provided arguments.
// Returns the wrapper for method chaining with expectation methods.
// Captures both normal returns and panics for verification.
//
// Example:
//
//	wrapper.Start(arg1, arg2).ExpectReturnedValuesAre(expectedResult)
func (s *{{.ImpName}}{{.TypeParamsUse}}) Start({{.CallableSignature}}) *{{.ImpName}}{{.TypeParamsUse}} {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				s.PanicChan <- r
			}
		}()

{{if .HasReturns}}		{{.ReturnVars}} := s.callable({{.ParamNames}})
		s.ReturnChan <- {{.ImpName}}Return{{.TypeParamsUse}}{
{{range .ReturnFields}}			Result{{.Index}}: {{.Name}},
{{end}}		}
{{else}}		s.callable({{.ParamNames}})
		s.ReturnChan <- struct{}{}
{{end}}	}()
	return s
}

`)
	if err != nil {
		return nil, err
	}

	// CallableExpectReturnedValuesAre template
	//nolint:lll,nolintlint
	registry.callableExpectReturnedValuesAreTmpl, err = parseTemplate("callableExpectReturnedValuesAre", `// ExpectReturnedValuesAre asserts the callable returned with exactly the specified values.
// Fails the test if the values don't match exactly or if the callable panicked.
// Uses == for comparison, so reference types must be the same instance.
func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectReturnedValuesAre({{.ResultParams}}) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Returned != nil {
{{.ResultComparisons}}		return
	}

	s.T.Fatalf("expected function to return, but it panicked with: %v", s.Panicked)
}

`)
	if err != nil {
		return nil, err
	}

	// CallableExpectReturnedValuesShould template
	//nolint:lll,nolintlint
	registry.callableExpectReturnedValuesShouldTmpl, err = parseTemplate("callableExpectReturnedValuesShould", `// ExpectReturnedValuesShould asserts return values match the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Fails the test if any matcher fails or if the callable panicked.
func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectReturnedValuesShould({{.ResultParamsAny}}) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Returned != nil {
{{if .HasReturns}}		var ok bool
		var msg string
{{.ResultMatchers}}{{end}}		return
	}

	s.T.Fatalf("expected function to return, but it panicked with: %v", s.Panicked)
}

`)
	if err != nil {
		return nil, err
	}

	// CallableExpectPanicWith template
	//nolint:lll,nolintlint
	registry.callableExpectPanicWithTmpl, err = parseTemplate("callableExpectPanicWith", `// ExpectPanicWith asserts the callable panicked with a value matching the expectation.
// Use imptest.Any() to match any panic value, or imptest.Satisfies(fn) for custom matching.
// Fails the test if the callable returned normally or panicked with a different value.
func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectPanicWith(expected any) {
	s.T.Helper()
	s.WaitForResponse()

	if s.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(s.Panicked, expected)
		if !ok {
			s.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	s.T.Fatalf("expected function to panic, but it returned")
}

`)
	if err != nil {
		return nil, err
	}

	// CallableResponseStruct template
	//nolint:lll,nolintlint
	registry.callableResponseStructTmpl, err = parseTemplate("callableResponseStruct", `// {{.ImpName}}Response represents the response from the callable (either return or panic).
// Check EventType to determine if the callable returned normally or panicked.
// Access ReturnVal for return values or PanicVal for panic information.
type {{.ImpName}}Response{{.TypeParamsDecl}} struct {
	EventType string // "return" or "panic"
{{if .HasReturns}}	ReturnVal *{{.ImpName}}Return{{.TypeParamsUse}}
{{end}}	PanicVal  any
}

`)
	if err != nil {
		return nil, err
	}

	// CallableResponseTypeMethod template
	//nolint:lll,nolintlint
	registry.callableResponseTypeMethodTmpl, err = parseTemplate("callableResponseTypeMethod", `// Type returns the event type: "return" for normal returns, "panic" for panics.
func (r *{{.ImpName}}Response{{.TypeParamsUse}}) Type() string {
	return r.EventType
}

`)
	if err != nil {
		return nil, err
	}

	return registry, nil
}

// WriteCallStruct generates the call struct definition.
func (r *TemplateRegistry) WriteCallStruct(buf *bytes.Buffer, data callStructTemplateData) {
	err := r.callStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callStruct template: %v", err))
	}
}

// WriteCallableConstructor generates the callable wrapper constructor.
func (r *TemplateRegistry) WriteCallableConstructor(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := r.callableConstructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableConstructor template: %v", err))
	}
}

// WriteCallableExpectPanicWith generates the ExpectPanicWith method for callable wrappers.
func (r *TemplateRegistry) WriteCallableExpectPanicWith(buf *bytes.Buffer, data callableTemplateData) {
	err := r.callableExpectPanicWithTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableExpectPanicWith template: %v", err))
	}
}

// WriteCallableExpectReturnedValuesAre generates the ExpectReturnedValuesAre method.
func (r *TemplateRegistry) WriteCallableExpectReturnedValuesAre(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := r.callableExpectReturnedValuesAreTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableExpectReturnedValuesAre template: %v", err))
	}
}

// WriteCallableExpectReturnedValuesShould generates the ExpectReturnedValuesShould method.
func (r *TemplateRegistry) WriteCallableExpectReturnedValuesShould(
	buf *bytes.Buffer, data callableExtendedTemplateData,
) {
	err := r.callableExpectReturnedValuesShouldTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableExpectReturnedValuesShould template: %v", err))
	}
}

// WriteCallableHeader generates the header for callable wrapper files.
func (r *TemplateRegistry) WriteCallableHeader(buf *bytes.Buffer, data baseTemplateData) {
	err := r.callableHeaderTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableHeader template: %v", err))
	}
}

// WriteCallableMainStruct generates the main callable wrapper struct.
func (r *TemplateRegistry) WriteCallableMainStruct(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := r.callableMainStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableMainStruct template: %v", err))
	}
}

// WriteCallableResponseStruct generates the response struct for callable wrappers.
func (r *TemplateRegistry) WriteCallableResponseStruct(buf *bytes.Buffer, data callableTemplateData) {
	err := r.callableResponseStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableResponseStruct template: %v", err))
	}
}

// WriteCallableResponseTypeMethod generates the Type method for response structs.
func (r *TemplateRegistry) WriteCallableResponseTypeMethod(buf *bytes.Buffer, data callableTemplateData) {
	err := r.callableResponseTypeMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableResponseTypeMethod template: %v", err))
	}
}

// WriteCallableReturnStruct generates the return struct for callable wrappers.
func (r *TemplateRegistry) WriteCallableReturnStruct(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := r.callableReturnStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableReturnStruct template: %v", err))
	}
}

// WriteCallableStartMethod generates the Start method for callable wrappers.
func (r *TemplateRegistry) WriteCallableStartMethod(buf *bytes.Buffer, data callableExtendedTemplateData) {
	err := r.callableStartMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute callableStartMethod template: %v", err))
	}
}

// WriteConstructor generates the constructor function for interface mocks.
func (r *TemplateRegistry) WriteConstructor(buf *bytes.Buffer, data templateData) {
	err := r.constructorTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute constructor template: %v", err))
	}
}

// WriteExpectCallIsStruct generates the ExpectCallIs struct definition.
func (r *TemplateRegistry) WriteExpectCallIsStruct(buf *bytes.Buffer, data templateData) {
	err := r.expectCallIsStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute expectCallIsStruct template: %v", err))
	}
}

// WriteGetCurrentCallMethod generates the GetCurrentCall method.
func (r *TemplateRegistry) WriteGetCurrentCallMethod(buf *bytes.Buffer, data templateData) {
	err := r.getCurrentCallMethodTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute getCurrentCallMethod template: %v", err))
	}
}

// WriteHeader generates the file header for interface mock files.
func (r *TemplateRegistry) WriteHeader(buf *bytes.Buffer, data templateData) {
	err := r.headerTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute header template: %v", err))
	}
}

// WriteInjectPanic generates the InjectPanic method for a method call.
func (r *TemplateRegistry) WriteInjectPanic(buf *bytes.Buffer, data methodTemplateData) {
	err := r.injectPanicTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute injectPanic template: %v", err))
	}
}

// WriteInterfaceVerification generates the compile-time interface verification.
func (r *TemplateRegistry) WriteInterfaceVerification(buf *bytes.Buffer, data templateData) {
	err := r.interfaceVerificationTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute interfaceVerification template: %v", err))
	}
}

// WriteMainStruct generates the main controller struct definition.
func (r *TemplateRegistry) WriteMainStruct(buf *bytes.Buffer, data templateData) {
	err := r.mainStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute mainStruct template: %v", err))
	}
}

// WriteMockStruct generates the mock struct definition.
func (r *TemplateRegistry) WriteMockStruct(buf *bytes.Buffer, data templateData) {
	err := r.mockStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute mockStruct template: %v", err))
	}
}

// WriteResolve generates the Resolve method for a void method call.
func (r *TemplateRegistry) WriteResolve(buf *bytes.Buffer, data methodTemplateData) {
	err := r.resolveTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute resolve template: %v", err))
	}
}

// WriteTimedStruct generates the timed expectation struct and Within method.
func (r *TemplateRegistry) WriteTimedStruct(buf *bytes.Buffer, data templateData) {
	err := r.timedStructTmpl.Execute(buf, data)
	if err != nil {
		panic(fmt.Sprintf("failed to execute timedStruct template: %v", err))
	}
}

// parseTemplate is a helper function that parses a template with consistent error handling.
// Returns the parsed template or an error with a descriptive message.
func parseTemplate(name, content string) (*template.Template, error) {
	funcMap := template.FuncMap{
		"lowerFirst": lowerFirst,
	}

	tmpl, err := template.New(name).Funcs(funcMap).Parse(content)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s template: %w", name, err)
	}

	return tmpl, nil
}
