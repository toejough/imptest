package run

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"strings"
	"unicode"
)

// callableGenerator holds state for generating callable wrapper code.
type callableGenerator struct {
	codeWriter

	pkgName   string
	impName   string
	funcDecl  *ast.FuncDecl
	pkgPath   string
	qualifier string
}

// hasReturns returns true if the function has return values.
func (g *callableGenerator) hasReturns() bool {
	return g.funcDecl.Type.Results != nil && len(g.funcDecl.Type.Results.List) > 0
}

// returnTypeName returns the appropriate type name for return channels and fields.
// Returns "{impName}Return" if the function has returns, otherwise "struct{}".
func (g *callableGenerator) returnTypeName() string {
	if g.hasReturns() {
		return g.impName + "Return"
	}

	return "struct{}"
}

// numReturns returns the total number of return values.
// This should only be called when hasReturns() is true.
func (g *callableGenerator) numReturns() int {
	count := 0

	for _, field := range g.funcDecl.Type.Results.List {
		if len(field.Names) > 0 {
			count += len(field.Names)
		} else {
			count++
		}
	}

	return count
}

// generateHeader writes the package declaration and imports.
func (g *callableGenerator) generateHeader() {
	g.pf("// Code generated by impgen. DO NOT EDIT.\n\n")
	g.pf("package %s\n\n", g.pkgName)

	if g.pkgPath != "" {
		g.pf(`import (
	"reflect"
	"testing"
	%s "%s"
)

`, g.qualifier, g.pkgPath)
	} else {
		g.pf(`import (
	"reflect"
	"testing"
)

`)
	}
}

// generateReturnStruct generates the return value struct if function has returns.
func (g *callableGenerator) generateReturnStruct() {
	if !g.hasReturns() {
		return
	}

	g.pf("type %sReturn struct {\n", g.impName)

	resultIdx := 0

	for _, field := range g.funcDecl.Type.Results.List {
		numNames := len(field.Names)
		if numNames == 0 {
			numNames = 1
		}

		for range numNames {
			g.pf("\tVal%d ", resultIdx)
			_ = g.printTypeWithQualifier(field.Type)
			g.pf("\n")

			resultIdx++
		}
	}

	g.pf("}\n\n")
}

// generateMainStruct generates the main wrapper struct.
func (g *callableGenerator) generateMainStruct() {
	g.pf("type %s struct {\n", g.impName)
	g.pf("\tt          testing.TB\n")
	g.pf("\tcallable   func(")
	g.writeParamsWithQualifiers(g.funcDecl.Type.Params)
	g.pf(")")

	if g.hasReturns() {
		g.pf(" (")
		g.writeResultTypesWithQualifiers()
		g.pf(")")
	}

	retType := g.returnTypeName()
	g.pf(`

	returnChan chan %s
	panicChan  chan any
	returned   *%s
	panicked   any
}

`, retType, retType)
}

// generateConstructor generates the New{ImpName} constructor function.
func (g *callableGenerator) generateConstructor() {
	g.pf("func New%s(t testing.TB, callable func(", g.impName)
	g.writeParamsWithQualifiers(g.funcDecl.Type.Params)
	g.pf(")")

	if g.hasReturns() {
		g.pf(" (")
		g.writeResultTypesWithQualifiers()
		g.pf(")")
	}

	g.pf(`) *%s {
	return &%s{
		t:          t,
		callable:   callable,
		returnChan: make(chan %s, 1),
		panicChan:  make(chan any, 1),
	}
}

`, g.impName, g.impName, g.returnTypeName())
}

// generateStartMethod generates the Start method.
func (g *callableGenerator) generateStartMethod() {
	g.pf("func (s *%s) Start(", g.impName)
	g.writeParamsWithQualifiers(g.funcDecl.Type.Params)
	g.pf(") *%s {\n", g.impName)
	g.pf(`	go func() {
		defer func() {
			if r := recover(); r != nil {
				s.panicChan <- r
			}
		}()

`)

	if g.hasReturns() {
		returnVars := g.returnVarNames()
		g.pf("\t\t%s := s.callable(", strings.Join(returnVars, ", "))
		g.writeParamNames()
		g.pf(")\n")
		g.pf("\t\ts.returnChan <- %sReturn{\n", g.impName)

		for i, name := range returnVars {
			g.pf("\t\t\tVal%d: %s,\n", i, name)
		}

		g.pf("\t\t}\n")
	} else {
		g.pf("\t\ts.callable(")
		g.writeParamNames()
		g.pf(")\n")
		g.pf("\t\ts.returnChan <- struct{}{}\n")
	}

	g.pf("\t}()\n")
	g.pf("\treturn s\n")
	g.pf("}\n\n")
}

// generateExpectReturnedValuesMethod generates the ExpectReturnedValues method.
func (g *callableGenerator) generateExpectReturnedValuesMethod() {
	g.pf("func (s *%s) ExpectReturnedValues(", g.impName)
	g.writeResultsWithQualifiers()
	g.pf(") {\n")
	g.pf("\ts.t.Helper()\n\n")
	g.pf("\t// Check if we already have a return value or panic\n")
	g.pf("\tif s.returned != nil {\n")

	g.writeReturnValueComparisons("s.returned")

	g.pf("\t\treturn\n")
	g.pf("\t}\n\n")
	g.pf("\tif s.panicked != nil {\n")
	g.pf("\t\ts.t.Fatalf(\"expected function to return, but it panicked with: %%v\", s.panicked)\n")
	g.pf("\t}\n\n")
	g.pf("\t// Wait for either return or panic\n")
	g.pf("\tselect {\n")
	g.pf("\tcase ret := <-s.returnChan:\n")
	g.pf("\t\ts.returned = &ret\n")

	g.writeReturnValueComparisons("ret")

	g.pf("\tcase p := <-s.panicChan:\n")
	g.pf("\t\ts.panicked = p\n")
	g.pf("\t\ts.t.Fatalf(\"expected function to return, but it panicked with: %%v\", p)\n")
	g.pf("\t}\n")
	g.pf("}\n\n")
}

// generateExpectPanicWithMethod generates the ExpectPanicWith method.
func (g *callableGenerator) generateExpectPanicWithMethod() {
	g.pf(`func (s *%s) ExpectPanicWith(expected any) {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.panicked != nil {
		if !reflect.DeepEqual(s.panicked, expected) {
			s.t.Fatalf("expected panic with %%v, got %%v", expected, s.panicked)
		}
		return
	}

	if s.returned != nil {
		s.t.Fatalf("expected function to panic, but it returned")
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		s.t.Fatalf("expected function to panic, but it returned")
	case p := <-s.panicChan:
		s.panicked = p
		if !reflect.DeepEqual(p, expected) {
			s.t.Fatalf("expected panic with %%v, got %%v", expected, p)
		}
	}
}

`, g.impName)
}

// generateResponseStruct generates the response struct.
func (g *callableGenerator) generateResponseStruct() {
	g.pf("type %sResponse struct {\n", g.impName)
	g.pf("\tEventType string // \"return\" or \"panic\"\n")

	if g.hasReturns() {
		g.pf("\tReturnVal *%sReturn\n", g.impName)
	}

	g.pf("\tPanicVal  any\n")
	g.pf("}\n\n")
}

// generateResponseMethods generates methods on the response struct.
func (g *callableGenerator) generateResponseMethods() {
	// Type method
	g.pf(`func (r *%sResponse) Type() string {
	return r.EventType
}

`, g.impName)

	// AsReturn method
	g.pf("func (r *%sResponse) AsReturn() []any {\n", g.impName)

	if g.hasReturns() {
		numReturns := g.numReturns()
		g.pf("\tif r.ReturnVal == nil {\n")
		g.pf("\t\treturn nil\n")
		g.pf("\t}\n")
		g.pf("\treturn []any{")

		for i := range numReturns {
			if i > 0 {
				g.pf(", ")
			}

			g.pf("r.ReturnVal.Val%d", i)
		}

		g.pf("}\n")
	} else {
		g.pf("\treturn nil\n")
	}

	g.pf("}\n\n")
}

// generateGetResponseMethod generates the GetResponse method.
func (g *callableGenerator) generateGetResponseMethod() {
	g.pf(`func (s *%s) GetResponse() *%sResponse {
	// Check if we already have a return value or panic
	if s.returned != nil {
		return &%sResponse{
			EventType: "ReturnEvent",
`, g.impName, g.impName, g.impName)

	if g.hasReturns() {
		g.pf("\t\t\tReturnVal: s.returned,\n")
	}

	g.pf(`		}
	}

	if s.panicked != nil {
		return &%sResponse{
			EventType: "PanicEvent",
			PanicVal:  s.panicked,
		}
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		return &%sResponse{
			EventType: "ReturnEvent",
`, g.impName, g.impName)

	if g.hasReturns() {
		g.pf("\t\t\tReturnVal: &ret,\n")
	}

	g.pf(`		}
	case p := <-s.panicChan:
		s.panicked = p
		return &%sResponse{
			EventType: "PanicEvent",
			PanicVal:  p,
		}
	}
}

`, g.impName)
}

// Helper methods

// returnVarNames generates return variable names for the function call.
func (g *callableGenerator) returnVarNames() []string {
	numReturns := g.numReturns()
	vars := make([]string, numReturns)

	for i := range vars {
		vars[i] = fmt.Sprintf("ret%d", i)
	}

	return vars
}

// writeParamsWithQualifiers writes function parameters with package qualifiers.
func (g *callableGenerator) writeParamsWithQualifiers(params *ast.FieldList) {
	if params == nil || len(params.List) == 0 {
		return
	}

	for i, field := range params.List {
		if i > 0 {
			g.pf(", ")
		}

		if len(field.Names) > 0 {
			for j, name := range field.Names {
				if j > 0 {
					g.pf(", ")
				}

				g.pf("%s", name.Name)
			}

			g.pf(" ")
		}

		_ = g.printTypeWithQualifier(field.Type)
	}
}

// writeResultTypesWithQualifiers writes function return types (without names).
func (g *callableGenerator) writeResultTypesWithQualifiers() {
	if !g.hasReturns() {
		return
	}

	first := true

	for _, field := range g.funcDecl.Type.Results.List {
		numNames := len(field.Names)
		if numNames == 0 {
			numNames = 1
		}

		for range numNames {
			if !first {
				g.pf(", ")
			}

			first = false
			_ = g.printTypeWithQualifier(field.Type)
		}
	}
}

// writeResultsWithQualifiers writes function return values with names.
func (g *callableGenerator) writeResultsWithQualifiers() {
	if !g.hasReturns() {
		return
	}

	for fieldIdx, field := range g.funcDecl.Type.Results.List {
		if fieldIdx > 0 {
			g.pf(", ")
		}

		numNames := len(field.Names)
		if numNames == 0 {
			numNames = 1
		}

		for nameIdx := range numNames {
			if nameIdx > 0 {
				g.pf(", ")
			}

			g.pf("v%d", fieldIdx*numNames+nameIdx+1)
			g.pf(" ")
		}

		_ = g.printTypeWithQualifier(field.Type)
	}
}

// writeParamNames writes only parameter names for function calls.
func (g *callableGenerator) writeParamNames() {
	params := g.funcDecl.Type.Params
	if params == nil || len(params.List) == 0 {
		return
	}

	first := true

	for _, field := range params.List {
		for _, name := range field.Names {
			if !first {
				g.pf(", ")
			}

			g.pf("%s", name.Name)

			first = false
		}
	}
}

// writeReturnValueComparisons writes comparisons for return values.
func (g *callableGenerator) writeReturnValueComparisons(varName string) {
	if !g.hasReturns() {
		return
	}

	resultIdx := 0

	for fieldIdx, field := range g.funcDecl.Type.Results.List {
		numNames := len(field.Names)
		if numNames == 0 {
			numNames = 1
		}

		for nameIdx := range numNames {
			resultName := fmt.Sprintf("v%d", fieldIdx*numNames+nameIdx+1)
			g.pf("\t\tif %s.Val%d != %s {\n", varName, resultIdx, resultName)
			g.pf("\t\t\ts.t.Fatalf(\"expected return value %%d to be %%v, got %%v\", %d, %s, %s.Val%d)\n",
				resultIdx, resultName, varName, resultIdx)
			g.pf("\t\t}\n")

			resultIdx++
		}
	}
}

// printTypeWithQualifier prints a type expression with package qualifier if needed.
//
//nolint:cyclop // AST type switching requires checking multiple cases
func (g *callableGenerator) printTypeWithQualifier(expr ast.Expr) error {
	switch typeExpr := expr.(type) {
	case *ast.Ident:
		if g.qualifier != "" && len(typeExpr.Name) > 0 &&
			typeExpr.Name[0] >= 'A' && typeExpr.Name[0] <= 'Z' {
			g.pf("%s.", g.qualifier)
		}

		g.pf("%s", typeExpr.Name)
	case *ast.StarExpr:
		g.pf("*")
		return g.printTypeWithQualifier(typeExpr.X)
	case *ast.ArrayType:
		g.pf("[")

		if typeExpr.Len != nil {
			printer.Fprint(&g.buf, g.fset, typeExpr.Len)
		}

		g.pf("]")

		return g.printTypeWithQualifier(typeExpr.Elt)
	default:
		err := printer.Fprint(&g.buf, g.fset, expr)
		if err != nil {
			return fmt.Errorf("error printing type expression: %w", err)
		}
	}

	return nil
}

// Functions

// generateCallableWrapperCode generates a type-safe wrapper for a callable function.
func generateCallableWrapperCode(
	astFiles []*ast.File,
	info generatorInfo,
	fset *token.FileSet,
	pkgImportPath string,
) (string, error) {
	funcDecl, err := findFunctionInAST(astFiles, info.localInterfaceName, pkgImportPath)
	if err != nil {
		return "", err
	}

	pkgPath, qualifier := getCallablePackageInfo(funcDecl, info.interfaceName)

	gen := &callableGenerator{
		codeWriter: codeWriter{fset: fset},
		pkgName:    info.pkgName,
		impName:    info.impName,
		funcDecl:   funcDecl,
		pkgPath:    pkgPath,
		qualifier:  qualifier,
	}

	gen.generateHeader()
	gen.generateReturnStruct()
	gen.generateMainStruct()
	gen.generateConstructor()
	gen.generateStartMethod()
	gen.generateExpectReturnedValuesMethod()
	gen.generateExpectPanicWithMethod()
	gen.generateResponseStruct()
	gen.generateResponseMethods()
	gen.generateGetResponseMethod()

	formatted, err := format.Source(gen.bytes())
	if err != nil {
		return "", fmt.Errorf("error formatting generated code: %w", err)
	}

	return string(formatted), nil
}

// getCallablePackageInfo extracts package info for a callable function.
func getCallablePackageInfo(funcDecl *ast.FuncDecl, interfaceName string) (pkgPath, pkgName string) {
	if !strings.Contains(interfaceName, ".") {
		return "", ""
	}

	parts := strings.Split(interfaceName, ".")

	if !callableFuncUsesExportedTypes(funcDecl) {
		return "", ""
	}

	pkgName = parts[0]
	pkgPath = "github.com/toejough/imptest/UAT/" + pkgName

	return pkgPath, pkgName
}

// callableFuncUsesExportedTypes checks if a function uses exported types.
func callableFuncUsesExportedTypes(funcDecl *ast.FuncDecl) bool {
	if funcDecl.Type.Params != nil {
		for _, field := range funcDecl.Type.Params.List {
			if callableHasExportedIdent(field.Type) {
				return true
			}
		}
	}

	if funcDecl.Type.Results != nil {
		for _, field := range funcDecl.Type.Results.List {
			if callableHasExportedIdent(field.Type) {
				return true
			}
		}
	}

	return false
}

// callableHasExportedIdent checks if an expression contains an exported identifier.
func callableHasExportedIdent(expr ast.Expr) bool {
	switch typeExpr := expr.(type) {
	case *ast.Ident:
		if unicode.IsUpper(rune(typeExpr.Name[0])) && !callableIsBuiltinType(typeExpr.Name) {
			return true
		}
	case *ast.StarExpr:
		return callableHasExportedIdent(typeExpr.X)
	case *ast.ArrayType:
		return callableHasExportedIdent(typeExpr.Elt)
	case *ast.MapType:
		return callableHasExportedIdent(typeExpr.Key) || callableHasExportedIdent(typeExpr.Value)
	case *ast.ChanType:
		return callableHasExportedIdent(typeExpr.Value)
	case *ast.SelectorExpr:
		return true
	}

	return false
}

// callableIsBuiltinType checks if a type name is a Go builtin.
func callableIsBuiltinType(name string) bool {
	builtins := map[string]bool{
		"bool": true, "byte": true, "complex64": true, "complex128": true,
		"error": true, "float32": true, "float64": true, "int": true,
		"int8": true, "int16": true, "int32": true, "int64": true,
		"rune": true, "string": true, "uint": true, "uint8": true,
		"uint16": true, "uint32": true, "uint64": true, "uintptr": true,
		"any": true,
	}

	return builtins[name]
}
