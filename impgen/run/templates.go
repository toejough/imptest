package run

import (
	"strings"
	"text/template"
)

// Code generation templates for the mock implementation generator.
// Using text/template reduces repetitive pf() calls and makes the generated
// code structure more visible.

// Template Variables

// Interface generator templates
//
//nolint:gochecknoglobals // Global templates are compile-time validated and immutable
var (
	headerTemplate = mustParse("header", `package {{.PkgName}}

// Code generated by impgen. DO NOT EDIT.

import "sync"
import "testing"
import "time"

`)

	mockStructTemplate = mustParse("mockStruct", `type {{.MockName}} struct {
	imp *{{.ImpName}}
}

`)

	mainStructTemplate = mustParse("mainStruct", `type {{.ImpName}} struct {
	t *testing.T
	Mock *{{.MockName}}
	callChan chan *{{.CallName}}
	ExpectCallTo *{{.ExpectCallToName}}
	currentCall *{{.CallName}}
	callQueue []*{{.CallName}}
	queueLock sync.Mutex
}

`)

	expectCallToStructTemplate = mustParse("expectCallToStruct",
		`type {{.ExpectCallToName}} struct {
	imp *{{.ImpName}}
	timeout time.Duration
}

`)

	timedStructTemplate = mustParse("timedStruct", `type {{.TimedName}} struct {
	ExpectCallTo *{{.ExpectCallToName}}
}

func (i *{{.ImpName}}) Within(d time.Duration) *{{.TimedName}} {
	return &{{.TimedName}}{
		ExpectCallTo: &{{.ExpectCallToName}}{imp: i, timeout: d},
	}
}

`)

	getCallMethodTemplate = mustParse("getCallMethod",
		`func (i *{{.ImpName}}) GetCall(
	d time.Duration, validator func(*{{.CallName}}) bool,
) *{{.CallName}} {
	i.queueLock.Lock()
	defer i.queueLock.Unlock()

	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			return call
		}
	}

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it
			i.callQueue = append(i.callQueue, call)
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

`)

	getCurrentCallMethodTemplate = mustParse("getCurrentCallMethod",
		`func (i *{{.ImpName}}) GetCurrentCall() *{{.CallName}} {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *{{.CallName}}) bool { return true })
	return i.currentCall
}

`)

	constructorTemplate = mustParse("constructor",
		`func New{{.ImpName}}(t *testing.T) *{{.ImpName}} {
	imp := &{{.ImpName}}{
		t: t,
		callChan: make(chan *{{.CallName}}, 1),
	}
	imp.Mock = &{{.MockName}}{imp: imp}
	imp.ExpectCallTo = &{{.ExpectCallToName}}{imp: imp}
	return imp
}

`)

	injectPanicMethodTemplate = mustParse("injectPanic",
		`func (c *{{.MethodCallName}}) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{Type: "panic", PanicValue: msg}
}
`)

	resolveMethodTemplate = mustParse("resolve",
		`func (c *{{.MethodCallName}}) Resolve() {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{Type: "resolve"}
}
`)

	callStructTemplate = mustParse("callStruct", `type {{.CallName}} struct {
{{range .Methods}}	{{.Name}} *{{.CallName}}
{{end}}}

func (c *{{.CallName}}) Name() string {
{{range .Methods}}	if c.{{.Name}} != nil {
		return "{{.Name}}"
	}
{{end}}	return ""
}

func (c *{{.CallName}}) Done() bool {
{{range .Methods}}	if c.{{.Name}} != nil {
		return c.{{.Name}}.done
	}
{{end}}	return false
}

{{range .Methods}}func (c *{{$.CallName}}) As{{.Name}}() *{{.CallName}} { return c.{{.Name}} }

{{end}}`)

	// Callable generator templates.

	callableHeaderTemplate = mustParse("callableHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	"reflect"
	"testing"
{{if .PkgPath}}	{{.Qualifier}} "{{.PkgPath}}"
{{end}})

`)

	callableMainStructTemplate = mustParse("callableMainStruct", `type {{.ImpName}} struct {
	t          testing.TB
	callable   func({{.CallableSignature}}){{.CallableReturns}}

	returnChan chan {{.ReturnType}}
	panicChan  chan any
	returned   *{{.ReturnType}}
	panicked   any
}

`)

	callableConstructorTemplate = mustParse("callableConstructor",
		`func New{{.ImpName}}(t testing.TB, callable func({{.CallableSignature}}){{.CallableReturns}}) *{{.ImpName}} {
	return &{{.ImpName}}{
		t:          t,
		callable:   callable,
		returnChan: make(chan {{.ReturnType}}, 1),
		panicChan:  make(chan any, 1),
	}
}

`)

	callableReturnStructTemplate = mustParse("callableReturnStruct",
		`{{if .HasReturns}}type {{.ImpName}}Return struct {
{{range .ReturnFields}}	Result{{.Index}} {{.Type}}
{{end}}}

{{end}}`)

	callableExpectPanicWithTemplate = mustParse("callableExpectPanicWith",
		`func (s *{{.ImpName}}) ExpectPanicWith(expected any) {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.panicked != nil {
		if !reflect.DeepEqual(s.panicked, expected) {
			s.t.Fatalf("expected panic with %v, got %v", expected, s.panicked)
		}
		return
	}

	if s.returned != nil {
		s.t.Fatalf("expected function to panic, but it returned")
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		s.t.Fatalf("expected function to panic, but it returned")
	case p := <-s.panicChan:
		s.panicked = p
		if !reflect.DeepEqual(p, expected) {
			s.t.Fatalf("expected panic with %v, got %v", expected, p)
		}
	}
}

`)

	callableResponseStructTemplate = mustParse("callableResponseStruct",
		`type {{.ImpName}}Response struct {
	EventType string // "return" or "panic"
{{if .HasReturns}}	ReturnVal *{{.ImpName}}Return
{{end}}	PanicVal  any
}

`)

	callableResponseTypeMethodTemplate = mustParse("callableResponseTypeMethod",
		`func (r *{{.ImpName}}Response) Type() string {
	return r.EventType
}

`)

	callableStartMethodTemplate = mustParse("callableStartMethod",
		`func (s *{{.ImpName}}) Start({{.CallableSignature}}) *{{.ImpName}} {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				s.panicChan <- r
			}
		}()

{{if .HasReturns}}		{{.ReturnVars}} := s.callable({{.ParamNames}})
		s.returnChan <- {{.ImpName}}Return{
{{range .ReturnFields}}			Result{{.Index}}: {{.Name}},
{{end}}		}
{{else}}		s.callable({{.ParamNames}})
		s.returnChan <- struct{}{}
{{end}}	}()
	return s
}

`)

	callableExpectReturnedValuesTemplate = mustParse("callableExpectReturnedValues",
		`func (s *{{.ImpName}}) ExpectReturnedValues({{.ResultParams}}) {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.returned != nil {
{{.ResultComparisons}}		return
	}

	if s.panicked != nil {
		s.t.Fatalf("expected function to return, but it panicked with: %v", s.panicked)
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
{{.ResultComparisons2}}	case p := <-s.panicChan:
		s.panicked = p
		s.t.Fatalf("expected function to return, but it panicked with: %v", p)
	}
}

`)

	callableGetResponseMethodTemplate = mustParse("callableGetResponseMethod",
		`func (s *{{.ImpName}}) GetResponse() *{{.ImpName}}Response {
	// Check if we already have a return value or panic
	if s.returned != nil {
		return &{{.ImpName}}Response{
			EventType: "ReturnEvent",
{{if .HasReturns}}			ReturnVal: s.returned,
{{end}}		}
	}

	if s.panicked != nil {
		return &{{.ImpName}}Response{
			EventType: "PanicEvent",
			PanicVal:  s.panicked,
		}
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		return &{{.ImpName}}Response{
			EventType: "ReturnEvent",
{{if .HasReturns}}			ReturnVal: &ret,
{{end}}		}
	case p := <-s.panicChan:
		s.panicked = p
		return &{{.ImpName}}Response{
			EventType: "PanicEvent",
			PanicVal:  p,
		}
	}
}

`)

	callableAsReturnMethodTemplate = mustParse("callableAsReturnMethod",
		`func (r *{{.ImpName}}Response) AsReturn() []any {
{{if .HasReturns}}	if r.ReturnVal == nil {
		return nil
	}
	return []any{ {{- range $i, $_ := .ReturnFields}}{{if $i}}, {{end}}r.ReturnVal.Result{{$i}}{{end -}} }
{{else}}	return nil
{{end}}}

`)
)

// Types

// templateData holds common data passed to templates.
type templateData struct {
	ImpName          string
	MockName         string
	CallName         string
	ExpectCallToName string
	TimedName        string
	PkgName          string
	MethodNames      []string
}

// methodTemplateData holds data for method-specific templates.
type methodTemplateData struct {
	templateData

	MethodName     string
	MethodCallName string
}

// callStructMethodData holds data for generating call struct methods with method field info.
type callStructMethodData struct {
	Name     string // Method name (e.g., "DoSomething")
	CallName string // Full call struct name (e.g., "MyImpDoSomethingCall")
}

// callStructTemplateData holds data for generating the call struct and its methods.
type callStructTemplateData struct {
	templateData

	Methods []callStructMethodData
}

// callableTemplateData holds data for callable wrapper templates.
type callableTemplateData struct {
	PkgName    string
	ImpName    string
	PkgPath    string
	Qualifier  string
	HasReturns bool
	ReturnType string // "{ImpName}Return" or "struct{}"
	NumReturns int
}

// Functions

// mustParse is a helper to parse template strings and panic on error.
func mustParse(name, text string) *template.Template {
	return template.Must(template.New(name).Parse(text))
}

// executeTemplate executes a template and returns the result as a string.
func executeTemplate(tmpl *template.Template, data any) string {
	var buf strings.Builder

	err := tmpl.Execute(&buf, data)
	if err != nil {
		// Templates are compile-time validated, so this should never happen
		panic("template execution failed: " + err.Error())
	}

	return buf.String()
}
