package run

import (
	"strings"
	"text/template"
)

// Code generation templates for the mock implementation generator.
// Using text/template reduces repetitive pf() calls and makes the generated
// code structure more visible.

// Template Variables

// Interface generator templates
//
//nolint:gochecknoglobals // Global templates are compile-time validated and immutable
var (
	headerTemplate = mustParse("header", `package {{.PkgName}}

// Code generated by impgen. DO NOT EDIT.

{{if .NeedsImptest}}import "github.com/toejough/imptest/imptest"
{{end}}{{if .NeedsReflect}}import "reflect"
{{end}}import "sync"
import "testing"
import "time"

`)

	mockStructTemplate = mustParse("mockStruct", `type {{.MockName}}{{.TypeParamsDecl}} struct {
	imp *{{.ImpName}}{{.TypeParamsUse}}
}

`)

	mainStructTemplate = mustParse("mainStruct", `type {{.ImpName}}{{.TypeParamsDecl}} struct {
	t *testing.T
	Mock *{{.MockName}}{{.TypeParamsUse}}
	callChan chan *{{.CallName}}
	ExpectCallIs *{{.ExpectCallIsName}}{{.TypeParamsUse}}
	currentCall *{{.CallName}}
	callQueue []*{{.CallName}}
	queueLock sync.Mutex
}

`)

	expectCallIsStructTemplate = mustParse("expectCallIsStruct",
		`type {{.ExpectCallIsName}}{{.TypeParamsDecl}} struct {
	imp *{{.ImpName}}{{.TypeParamsUse}}
	timeout time.Duration
}

`)

	timedStructTemplate = mustParse("timedStruct", `type {{.TimedName}}{{.TypeParamsDecl}} struct {
	ExpectCallIs *{{.ExpectCallIsName}}{{.TypeParamsUse}}
}

func (i *{{.ImpName}}{{.TypeParamsUse}}) Within(d time.Duration) *{{.TimedName}}{{.TypeParamsUse}} {
	return &{{.TimedName}}{{.TypeParamsUse}}{
		ExpectCallIs: &{{.ExpectCallIsName}}{{.TypeParamsUse}}{imp: i, timeout: d},
	}
}

`)

	getCallMethodTemplate = mustParse("getCallMethod",
		`func (i *{{.ImpName}}{{.TypeParamsUse}}) GetCall(
	d time.Duration, validator func(*{{.CallName}}) bool,
) *{{.CallName}} {
	i.queueLock.Lock()

	// Check queue first while holding lock
	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			i.queueLock.Unlock()
			return call
		}
	}

	// Release lock before blocking on channel to avoid deadlock
	i.queueLock.Unlock()

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it - need lock to access shared queue
			i.queueLock.Lock()
			i.callQueue = append(i.callQueue, call)
			i.queueLock.Unlock()
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

`)

	getCurrentCallMethodTemplate = mustParse("getCurrentCallMethod",
		`func (i *{{.ImpName}}{{.TypeParamsUse}}) GetCurrentCall() *{{.CallName}} {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *{{.CallName}}) bool { return true })
	return i.currentCall
}

`)

	constructorTemplate = mustParse("constructor",
		`func New{{.ImpName}}{{.TypeParamsDecl}}(t *testing.T) *{{.ImpName}}{{.TypeParamsUse}} {
	imp := &{{.ImpName}}{{.TypeParamsUse}}{
		t: t,
		callChan: make(chan *{{.CallName}}, 1),
	}
	imp.Mock = &{{.MockName}}{{.TypeParamsUse}}{imp: imp}
	imp.ExpectCallIs = &{{.ExpectCallIsName}}{{.TypeParamsUse}}{imp: imp}
	return imp
}

`)

	injectPanicMethodTemplate = mustParse("injectPanic",
		`func (c *{{.MethodCallName}}) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{Type: "panic", PanicValue: msg}
}
`)

	resolveMethodTemplate = mustParse("resolve",
		`func (c *{{.MethodCallName}}) Resolve() {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{Type: "resolve"}
}
`)

	callStructTemplate = mustParse("callStruct", `type {{.CallName}} struct {
{{range .Methods}}	{{.Name}} *{{.CallName}}
{{end}}}

func (c *{{.CallName}}) Name() string {
{{range .Methods}}	if c.{{.Name}} != nil {
		return "{{.Name}}"
	}
{{end}}	return ""
}

func (c *{{.CallName}}) Done() bool {
{{range .Methods}}	if c.{{.Name}} != nil {
		return c.{{.Name}}.done
	}
{{end}}	return false
}

{{range .Methods}}func (c *{{$.CallName}}) As{{.Name}}() *{{.CallName}} { return c.{{.Name}} }

{{end}}`)

	// Callable generator templates.

	callableHeaderTemplate = mustParse("callableHeader", `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	"github.com/toejough/imptest/imptest"
	"testing"
{{if .PkgPath}}	{{.Qualifier}} "{{.PkgPath}}"
{{end}})

`)

	callableMainStructTemplate = mustParse("callableMainStruct", `type {{.ImpName}}{{.TypeParamsDecl}} struct {
	t          testing.TB
	callable   func({{.CallableSignature}}){{.CallableReturns}}

	returnChan chan {{.ReturnType}}
	panicChan  chan any
	returned   *{{.ReturnType}}
	panicked   any
}

`)

	callableConstructorTemplate = mustParse("callableConstructor",
		`func New{{.ImpName}}{{.TypeParamsDecl}}(t testing.TB, callable func({{.CallableSignature}}){{.CallableReturns}}) *{{.ImpName}}{{.TypeParamsUse}} {
	return &{{.ImpName}}{{.TypeParamsUse}}{
		t:          t,
		callable:   callable,
		returnChan: make(chan {{.ReturnType}}, 1),
		panicChan:  make(chan any, 1),
	}
}

`)

	callableReturnStructTemplate = mustParse("callableReturnStruct",
		`{{if .HasReturns}}type {{.ImpName}}Return{{.TypeParamsDecl}} struct {
{{range .ReturnFields}}	Result{{.Index}} {{.Type}}
{{end}}}

{{end}}`)

	callableExpectPanicWithTemplate = mustParse("callableExpectPanicWith",
		`func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectPanicWith(expected any) {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.panicked != nil {
		ok, msg := imptest.MatchValue(s.panicked, expected)
		if !ok {
			s.t.Fatalf("panic value: %s", msg)
		}
		return
	}

	if s.returned != nil {
		s.t.Fatalf("expected function to panic, but it returned")
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		s.t.Fatalf("expected function to panic, but it returned")
	case p := <-s.panicChan:
		s.panicked = p
		ok, msg := imptest.MatchValue(p, expected)
		if !ok {
			s.t.Fatalf("panic value: %s", msg)
		}
	}
}

`)

	callableResponseStructTemplate = mustParse("callableResponseStruct",
		`type {{.ImpName}}Response{{.TypeParamsDecl}} struct {
	EventType string // "return" or "panic"
{{if .HasReturns}}	ReturnVal *{{.ImpName}}Return{{.TypeParamsUse}}
{{end}}	PanicVal  any
}

`)

	callableResponseTypeMethodTemplate = mustParse("callableResponseTypeMethod",
		`func (r *{{.ImpName}}Response{{.TypeParamsUse}}) Type() string {
	return r.EventType
}

`)

	callableStartMethodTemplate = mustParse("callableStartMethod",
		`func (s *{{.ImpName}}{{.TypeParamsUse}}) Start({{.CallableSignature}}) *{{.ImpName}}{{.TypeParamsUse}} {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				s.panicChan <- r
			}
		}()

{{if .HasReturns}}		{{.ReturnVars}} := s.callable({{.ParamNames}})
		s.returnChan <- {{.ImpName}}Return{{.TypeParamsUse}}{
{{range .ReturnFields}}			Result{{.Index}}: {{.Name}},
{{end}}		}
{{else}}		s.callable({{.ParamNames}})
		s.returnChan <- struct{}{}
{{end}}	}()
	return s
}

`)

	callableExpectReturnedValuesAreTemplate = mustParse("callableExpectReturnedValuesAre",
		`func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectReturnedValuesAre({{.ResultParams}}) {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.returned != nil {
{{.ResultComparisons}}		return
	}

	if s.panicked != nil {
		s.t.Fatalf("expected function to return, but it panicked with: %v", s.panicked)
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
{{.ResultComparisons2}}	case p := <-s.panicChan:
		s.panicked = p
		s.t.Fatalf("expected function to return, but it panicked with: %v", p)
	}
}

`)

	callableExpectReturnedValuesShouldTemplate = mustParse("callableExpectReturnedValuesShould",
		`func (s *{{.ImpName}}{{.TypeParamsUse}}) ExpectReturnedValuesShould({{.ResultParams}}) {
	s.t.Helper()

	// Check if we already have a return value or panic
	if s.returned != nil {
{{.ResultComparisons}}		return
	}

	if s.panicked != nil {
		s.t.Fatalf("expected function to return, but it panicked with: %v", s.panicked)
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
{{.ResultComparisons2}}	case p := <-s.panicChan:
		s.panicked = p
		s.t.Fatalf("expected function to return, but it panicked with: %v", p)
	}
}

`)

	callableGetResponseMethodTemplate = mustParse("callableGetResponseMethod",
		`func (s *{{.ImpName}}{{.TypeParamsUse}}) GetResponse() *{{.ImpName}}Response{{.TypeParamsUse}} {
	// Check if we already have a return value or panic
	if s.returned != nil {
		return &{{.ImpName}}Response{{.TypeParamsUse}}{
			EventType: "ReturnEvent",
{{if .HasReturns}}			ReturnVal: s.returned,
{{end}}		}
	}

	if s.panicked != nil {
		return &{{.ImpName}}Response{{.TypeParamsUse}}{
			EventType: "PanicEvent",
			PanicVal:  s.panicked,
		}
	}

	// Wait for either return or panic
	select {
	case ret := <-s.returnChan:
		s.returned = &ret
		return &{{.ImpName}}Response{{.TypeParamsUse}}{
			EventType: "ReturnEvent",
{{if .HasReturns}}			ReturnVal: &ret,
{{end}}		}
	case p := <-s.panicChan:
		s.panicked = p
		return &{{.ImpName}}Response{{.TypeParamsUse}}{
			EventType: "PanicEvent",
			PanicVal:  p,
		}
	}
}

`)

	callableAsReturnMethodTemplate = mustParse("callableAsReturnMethod",
		`func (r *{{.ImpName}}Response{{.TypeParamsUse}}) AsReturn() []any {
{{if .HasReturns}}	if r.ReturnVal == nil {
		return nil
	}
	return []any{ {{- range $i, $_ := .ReturnFields}}{{if $i}}, {{end}}r.ReturnVal.Result{{$i}}{{end -}} }
{{else}}	return nil
{{end}}}

`)
)

// Types

// templateData holds common data passed to templates.
type templateData struct {
	ImpName          string
	MockName         string
	CallName         string
	ExpectCallIsName string
	TimedName        string
	PkgName          string
	MethodNames      []string
	TypeParamsDecl   string // Type parameters with constraints, e.g., "[T any, U comparable]"
	TypeParamsUse    string // Type parameters for instantiation, e.g., "[T, U]"
	NeedsReflect     bool   // Whether reflect import is needed for DeepEqual
	NeedsImptest     bool   // Whether imptest import is needed for matchers
}

// methodTemplateData holds data for method-specific templates.
type methodTemplateData struct {
	templateData

	MethodName     string
	MethodCallName string
}

// callStructMethodData holds data for generating call struct methods with method field info.
type callStructMethodData struct {
	Name     string // Method name (e.g., "DoSomething")
	CallName string // Full call struct name (e.g., "MyImpDoSomethingCall")
}

// callStructTemplateData holds data for generating the call struct and its methods.
type callStructTemplateData struct {
	templateData

	Methods []callStructMethodData
}

// callableTemplateData holds data for callable wrapper templates.
type callableTemplateData struct {
	PkgName        string
	ImpName        string
	PkgPath        string
	Qualifier      string
	HasReturns     bool
	ReturnType     string // "{ImpName}Return" or "struct{}"
	NumReturns     int
	TypeParamsDecl string // Type parameters with constraints, e.g., "[T any, U comparable]"
	TypeParamsUse  string // Type parameters for instantiation, e.g., "[T, U]"
}

// Functions

// mustParse is a helper to parse template strings and panic on error.
func mustParse(name, text string) *template.Template {
	return template.Must(template.New(name).Parse(text))
}

// executeTemplate executes a template and returns the result as a string.
func executeTemplate(tmpl *template.Template, data any) string {
	var buf strings.Builder

	err := tmpl.Execute(&buf, data)
	if err != nil {
		// Templates are compile-time validated, so this should never happen
		panic("template execution failed: " + err.Error())
	}

	return buf.String()
}
