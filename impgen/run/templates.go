package run

import (
	"strings"
	"text/template"
)

// Code generation templates for the mock implementation generator.
// Using text/template reduces repetitive pf() calls and makes the generated
// code structure more visible.

// templateData holds common data passed to templates.
type templateData struct {
	ImpName          string
	MockName         string
	CallName         string
	ExpectCallToName string
	TimedName        string
	PkgName          string
	MethodNames      []string
}

// methodTemplateData holds data for method-specific templates.
type methodTemplateData struct {
	templateData

	MethodName     string
	MethodCallName string
}

// mustParse is a helper to parse template strings and panic on error.
func mustParse(name, text string) *template.Template {
	return template.Must(template.New(name).Parse(text))
}

// Templates as raw strings - easier to read and maintain than multiple pf() calls.
//
//nolint:gochecknoglobals // Global templates are compile-time validated and immutable
var (
	headerTemplate = mustParse("header", `package {{.PkgName}}

// Code generated by impgen. DO NOT EDIT.

import "sync"
import "testing"
import "time"

`)

	mockStructTemplate = mustParse("mockStruct", `type {{.MockName}} struct {
	imp *{{.ImpName}}
}

`)

	mainStructTemplate = mustParse("mainStruct", `type {{.ImpName}} struct {
	t *testing.T
	Mock *{{.MockName}}
	callChan chan *{{.CallName}}
	ExpectCallTo *{{.ExpectCallToName}}
	currentCall *{{.CallName}}
	callQueue []*{{.CallName}}
	queueLock sync.Mutex
}

`)

	expectCallToStructTemplate = mustParse("expectCallToStruct",
		`type {{.ExpectCallToName}} struct {
	imp *{{.ImpName}}
	timeout time.Duration
}

`)

	timedStructTemplate = mustParse("timedStruct", `type {{.TimedName}} struct {
	ExpectCallTo *{{.ExpectCallToName}}
}

func (i *{{.ImpName}}) Within(d time.Duration) *{{.TimedName}} {
	return &{{.TimedName}}{
		ExpectCallTo: &{{.ExpectCallToName}}{imp: i, timeout: d},
	}
}

`)

	getCallMethodTemplate = mustParse("getCallMethod",
		`func (i *{{.ImpName}}) GetCall(
	d time.Duration, validator func(*{{.CallName}}) bool,
) *{{.CallName}} {
	i.queueLock.Lock()
	defer i.queueLock.Unlock()

	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			return call
		}
	}

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it
			i.callQueue = append(i.callQueue, call)
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

`)

	getCurrentCallMethodTemplate = mustParse("getCurrentCallMethod",
		`func (i *{{.ImpName}}) GetCurrentCall() *{{.CallName}} {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *{{.CallName}}) bool { return true })
	return i.currentCall
}

`)

	constructorTemplate = mustParse("constructor",
		`func New{{.ImpName}}(t *testing.T) *{{.ImpName}} {
	imp := &{{.ImpName}}{
		t: t,
		callChan: make(chan *{{.CallName}}, 1),
	}
	imp.Mock = &{{.MockName}}{imp: imp}
	imp.ExpectCallTo = &{{.ExpectCallToName}}{imp: imp}
	return imp
}

`)

	injectPanicMethodTemplate = mustParse("injectPanic",
		`func (c *{{.MethodCallName}}) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{Type: "panic", PanicValue: msg}
}
`)

	resolveMethodTemplate = mustParse("resolve",
		`func (c *{{.MethodCallName}}) Resolve() {
	c.done = true
	c.responseChan <- {{.MethodCallName}}Response{Type: "resolve"}
}
`)
)

// executeTemplate executes a template and returns the result as a string.
func executeTemplate(tmpl *template.Template, data any) string {
	var buf strings.Builder

	err := tmpl.Execute(&buf, data)
	if err != nil {
		// Templates are compile-time validated, so this should never happen
		panic("template execution failed: " + err.Error())
	}

	return buf.String()
}
