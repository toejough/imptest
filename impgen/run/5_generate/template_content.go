//nolint:lll // Template strings naturally exceed line length
package generate

// unexported constants.
const (
	tmplDepArgsStruct = `{{if .HasParams}}// {{.ArgsTypeName}} holds typed arguments for {{.MethodName}}.
type {{.ArgsTypeName}}{{.TypeParamsDecl}} struct {
{{range .ParamFields}}	{{.Name}} {{.Type}}
{{end}}}

{{end}}`
	tmplDepCallWrapper = `{{if or .HasParams .HasResults}}// {{.CallTypeName}} wraps DependencyCall with typed GetArgs{{if .HasResults}} and InjectReturnValues{{end}}.
type {{.CallTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyCall
}
{{if .HasParams}}
// GetArgs returns the typed arguments for this call.
func (c *{{.CallTypeName}}{{.TypeParamsUse}}) GetArgs() {{.ArgsTypeName}}{{.TypeParamsUse}} {
	raw := c.RawArgs()
	return {{.ArgsTypeName}}{{.TypeParamsUse}}{
{{range .ParamFields}}		{{.Name}}: raw[{{.Index}}].({{.Type}}),
{{end}}	}
}
{{end}}{{if .HasResults}}
// InjectReturnValues specifies the typed values the mock should return.
func (c *{{.CallTypeName}}{{.TypeParamsUse}}) InjectReturnValues({{.TypedReturnParams}}) {
	c.DependencyCall.InjectReturnValues({{.ReturnParamNames}})
}
{{end}}{{end}}
`
	tmplDepConstructor = `// {{.MockName}} creates a new {{.MockTypeName}}Handle for testing.
func {{.MockName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter) *{{.MockTypeName}}Handle{{.TypeParamsUse}} {
	ctrl := {{.PkgImptest}}.GetOrCreateImp(t)
	methods := &{{.MockTypeName}}Methods{{.TypeParamsUse}}{
{{range .Methods}}{{if .HasParams}}		{{.MethodName}}: new{{.MethodTypeName}}{{$.TypeParamsUse}}({{$.PkgImptest}}.NewDependencyMethod(ctrl, "{{.MethodName}}")),
{{else}}		{{.MethodName}}: {{$.PkgImptest}}.NewDependencyMethod(ctrl, "{{.MethodName}}"),
{{end}}{{end}}	}
	h := &{{.MockTypeName}}Handle{{.TypeParamsUse}}{
		Method:     methods,
		Controller: ctrl,
	}
	h.Mock = &{{.ImplName}}{{.TypeParamsUse}}{handle: h}
	return h
}

`
	tmplDepHeader = `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	{{.PkgImptest}} "github.com/toejough/imptest"{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`
	tmplDepImplMethod = `// {{.MethodName}} implements {{.InterfaceType}}.{{.MethodName}}.
func (impl *{{.ImplName}}{{.TypeParamsUse}}) {{.MethodName}}({{.Params}}){{.Results}} {
	{{if .HasVariadic}}callArgs := []any{ {{.NonVariadicArgs}} }
	for _, v := range {{.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	{{end}}call := &{{.PkgImptest}}.GenericCall{
		MethodName: "{{.MethodName}}",
		Args: {{if .HasVariadic}}callArgs{{else}}[]any{ {{.Args}} }{{end}},
		ResponseChan: make(chan {{.PkgImptest}}.GenericResponse, 1),
	}
	impl.handle.Controller.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}
	{{if .HasResults}}{{range .ResultVars}}
	var {{.Name}} {{.Type}}
	if len(resp.ReturnValues) > {{.Index}} {
		if value, ok := resp.ReturnValues[{{.Index}}].({{.Type}}); ok {
			{{.Name}} = value
		}
	}
	{{end}}
	return {{.ReturnList}}{{end}}
}

`
	tmplDepImplStruct = `{{if .IsStructType}}// {{.ImplName}} implements {{.MockTypeName}}Interface.
{{else}}// {{.ImplName}} implements {{.InterfaceType}}.
{{end}}type {{.ImplName}}{{.TypeParamsDecl}} struct {
	handle *{{.MockTypeName}}Handle{{.TypeParamsUse}}
}

`
	tmplDepInterfaceMethod = `{{if .IsStructType}}// {{.MockTypeName}}Interface is a generated interface matching the methods of {{.InterfaceName}}.
type {{.MockTypeName}}Interface{{.TypeParamsDecl}} interface {
{{range .Methods}}	{{.MethodName}}({{.Params}}){{.Results}}
{{end}}}

{{end}}`
	tmplDepMethodWrapper = `{{if .HasParams}}// {{.MethodTypeName}} wraps DependencyMethod with typed returns.
type {{.MethodTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyMethod
	// Eventually is the async version of this method for concurrent code.
	Eventually *{{.MethodTypeName}}{{.TypeParamsUse}}
}

// new{{.MethodTypeName}} creates a typed method wrapper with Eventually initialized.
func new{{.MethodTypeName}}{{.TypeParamsDecl}}(dm *{{.PkgImptest}}.DependencyMethod) *{{.MethodTypeName}}{{.TypeParamsUse}} {
	m := &{{.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: dm}
	m.Eventually = &{{.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: dm.Eventually}
	return m
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *{{.MethodTypeName}}{{.TypeParamsUse}}) ExpectCalledWithExactly({{.TypedParams}}) *{{.CallTypeName}}{{.TypeParamsUse}} {
	{{if .HasVariadic}}callArgs := []any{ {{if .NonVariadicArgs}}{{.NonVariadicArgs}}{{end}} }
	for _, v := range {{.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	call := m.DependencyMethod.ExpectCalledWithExactly(callArgs...){{else}}call := m.DependencyMethod.ExpectCalledWithExactly({{.ArgNames}}){{end}}
	return &{{.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *{{.MethodTypeName}}{{.TypeParamsUse}}) ExpectCalledWithMatches(matchers ...any) *{{.CallTypeName}}{{.TypeParamsUse}} {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &{{.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

{{end}}
`
	tmplDepMockStruct = `// {{.MockTypeName}}Handle is the test handle for {{.InterfaceName}}.
type {{.MockTypeName}}Handle{{.TypeParamsDecl}} struct {
	Mock       {{if .IsStructType}}{{.MockTypeName}}Interface{{.TypeParamsUse}}{{else}}{{.InterfaceType}}{{end}}
	Method     *{{.MockTypeName}}Methods{{.TypeParamsUse}}
	Controller *{{.PkgImptest}}.Imp
}

// {{.MockTypeName}}Methods holds method wrappers for setting expectations.
type {{.MockTypeName}}Methods{{.TypeParamsDecl}} struct {
{{range .Methods}}{{if .HasParams}}	{{.MethodName}} *{{.MethodTypeName}}{{$.TypeParamsUse}}
{{else}}	{{.MethodName}} *{{$.PkgImptest}}.DependencyMethod
{{end}}{{end}}}

`
	tmplFuncDepConstructor = `// {{.MockName}} creates a new {{.MockTypeName}}Handle for testing.
func {{.MockName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter) *{{.MockTypeName}}Handle{{.TypeParamsUse}} {
	ctrl := {{.PkgImptest}}.GetOrCreateImp(t)
	h := &{{.MockTypeName}}Handle{{.TypeParamsUse}}{
		Controller: ctrl,
{{if .Method.HasParams}}		Method: new{{.Method.MethodTypeName}}{{.TypeParamsUse}}({{.PkgImptest}}.NewDependencyMethod(ctrl, "{{.FuncName}}")),
{{else}}		Method: {{.PkgImptest}}.NewDependencyMethod(ctrl, "{{.FuncName}}"),
{{end}}	}
	h.Mock = func({{.Method.Params}}){{.Method.Results}} {
		{{if .Method.HasVariadic}}callArgs := []any{ {{.Method.NonVariadicArgs}} }
		for _, v := range {{.Method.VariadicArg}} {
			callArgs = append(callArgs, v)
		}
		{{end}}call := &{{.PkgImptest}}.GenericCall{
			MethodName: "{{.FuncName}}",
			Args: {{if .Method.HasVariadic}}callArgs{{else}}[]any{ {{.Method.Args}} }{{end}},
			ResponseChan: make(chan {{.PkgImptest}}.GenericResponse, 1),
		}
		h.Controller.CallChan <- call
		resp := <-call.ResponseChan
		if resp.Type == "panic" {
			panic(resp.PanicValue)
		}
		{{if .Method.HasResults}}{{range .Method.ResultVars}}
		var {{.Name}} {{.Type}}
		if len(resp.ReturnValues) > {{.Index}} {
			if value, ok := resp.ReturnValues[{{.Index}}].({{.Type}}); ok {
				{{.Name}} = value
			}
		}
		{{end}}
		return {{.Method.ReturnList}}{{end}}
	}
	return h
}

`
	tmplFuncDepMethodWrapper = `{{if .Method.HasParams}}// {{.Method.MethodTypeName}} wraps DependencyMethod with typed returns.
type {{.Method.MethodTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyMethod
	// Eventually is the async version of this method for concurrent code.
	Eventually *{{.Method.MethodTypeName}}{{.TypeParamsUse}}
}

// new{{.Method.MethodTypeName}} creates a typed method wrapper with Eventually initialized.
func new{{.Method.MethodTypeName}}{{.TypeParamsDecl}}(dm *{{.PkgImptest}}.DependencyMethod) *{{.Method.MethodTypeName}}{{.TypeParamsUse}} {
	m := &{{.Method.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: dm}
	m.Eventually = &{{.Method.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: dm.Eventually}
	return m
}

// ExpectCalledWithExactly waits for a call with exactly the specified arguments.
func (m *{{.Method.MethodTypeName}}{{.TypeParamsUse}}) ExpectCalledWithExactly({{.Method.TypedParams}}) *{{.Method.CallTypeName}}{{.TypeParamsUse}} {
	{{if .Method.HasVariadic}}callArgs := []any{ {{if .Method.NonVariadicArgs}}{{.Method.NonVariadicArgs}}{{end}} }
	for _, v := range {{.Method.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	call := m.DependencyMethod.ExpectCalledWithExactly(callArgs...){{else}}call := m.DependencyMethod.ExpectCalledWithExactly({{.Method.ArgNames}}){{end}}
	return &{{.Method.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

// ExpectCalledWithMatches waits for a call with arguments matching the given matchers.
func (m *{{.Method.MethodTypeName}}{{.TypeParamsUse}}) ExpectCalledWithMatches(matchers ...any) *{{.Method.CallTypeName}}{{.TypeParamsUse}} {
	call := m.DependencyMethod.ExpectCalledWithMatches(matchers...)
	return &{{.Method.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

{{end}}
`
	tmplFuncDepMockStruct = `// {{.MockTypeName}}Handle is the test handle for {{.FuncName}} function.
type {{.MockTypeName}}Handle{{.TypeParamsDecl}} struct {
	Mock       {{.FuncSig}}
{{if .Method.HasParams}}	Method     *{{.Method.MethodTypeName}}{{.TypeParamsUse}}
{{else}}	Method     *{{.PkgImptest}}.DependencyMethod
{{end}}	Controller *{{.PkgImptest}}.Imp
}

`
	tmplInterfaceTargetConstructor = `// {{.WrapName}} creates a new wrapper for the given {{.InterfaceType}} implementation.
func {{.WrapName}}(t *testing.T, {{.ImplName}} {{if .IsStructType}}*{{end}}{{.InterfaceType}}) *{{.WrapperType}}Handle {
	h := &{{.WrapperType}}Handle{
		impl:   {{.ImplName}},
		Method: &{{.WrapperType}}Methods{},
	}
{{range .Methods}}	h.Method.{{.MethodName}} = {{.WrapName}}(t, func({{.Params}}){{if .HasResults}} {{.ReturnsType}}{{end}} {
{{if .HasResults}}		{{.ResultVars}} := h.impl.{{.MethodName}}({{.ParamNames}})
		return {{.ReturnsType}}{ {{.ReturnAssignments}} }
{{else}}		h.impl.{{.MethodName}}({{.ParamNames}})
		return {{.ReturnsType}}{}
{{end}}	})
{{end}}	return h
}

`
	tmplInterfaceTargetHeader = `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	"testing"
	{{.PkgImptest}} "github.com/toejough/imptest"{{if .NeedsReflect}}
	{{.PkgReflect}} "reflect"{{end}}{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`
	tmplInterfaceTargetMethodCallHandleStruct = `// {{.CallHandleType}} represents a single call to the wrapped method.
type {{.CallHandleType}} struct {
	*{{.PkgImptest}}.CallableController[{{.ReturnsType}}]
}

`
	tmplInterfaceTargetMethodExpectCompletes = `// ExpectCompletes verifies the method completes without panicking.
func (h *{{.CallHandleType}}) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

`
	tmplInterfaceTargetMethodExpectPanic = `// ExpectPanicEquals verifies the method panics with the expected value.
func (h *{{.CallHandleType}}) ExpectPanicEquals(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectPanicMatches verifies the method panics with a value matching the given matcher.
func (h *{{.CallHandleType}}) ExpectPanicMatches(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

`
	tmplInterfaceTargetMethodExpectReturns = `// ExpectReturnsEqual verifies the method returned the expected values.
func (h *{{.CallHandleType}}) ExpectReturnsEqual({{.ExpectedParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		{{range .ResultChecks}}if !_reflect.DeepEqual(h.Returned.{{.Field}}, {{.Expected}}) {
			h.T.Fatalf("expected return value {{.Index}} to be %v, got %v", {{.Expected}}, h.Returned.{{.Field}})
		}
		{{end}}return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnsMatch verifies the return values match the given matchers.
func (h *{{.CallHandleType}}) ExpectReturnsMatch({{.MatcherParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		{{range .ResultChecks}}ok, msg = {{$.PkgImptest}}.MatchValue(h.Returned.{{.Field}}, {{.Expected}})
		if !ok {
			h.T.Fatalf("return value {{.Index}}: %s", msg)
		}
		{{end}}return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

`
	tmplInterfaceTargetMethodReturns = `type {{.ReturnsType}} struct {
{{range .ResultFields}}	{{.Name}} {{.Type}}
{{end}}}

`
	tmplInterfaceTargetMethodStart = `// Start executes the wrapped method in a goroutine.
func (w *{{.WrapperType}}) Start({{.Params}}) *{{.CallHandleType}} {
	handle := &{{.CallHandleType}}{
		CallableController: {{.PkgImptest}}.NewCallableController[{{.ReturnsType}}](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn({{.ParamNames}})
		handle.ReturnChan <- returns
	}()
	return handle
}

`
	tmplInterfaceTargetMethodWrapperFunc = `func {{.WrapName}}(t *testing.T, fn func({{.Params}}){{if .HasResults}} {{.ReturnsType}}{{end}}) *{{.WrapperType}} {
	return &{{.WrapperType}}{t: t, fn: fn}
}

`
	tmplInterfaceTargetMethodWrapperStruct = `type {{.WrapperType}} struct {
	t *testing.T
	fn func({{.Params}}){{if .HasResults}} {{.ReturnsType}}{{end}}
}

`
	tmplInterfaceTargetWrapperStruct = `// {{.WrapperType}}Handle wraps an implementation of {{.InterfaceType}} to intercept method calls.
type {{.WrapperType}}Handle struct {
	Method *{{.WrapperType}}Methods
	impl   {{if .IsStructType}}*{{end}}{{.InterfaceType}}
}

// {{.WrapperType}}Methods holds method wrappers for all intercepted methods.
type {{.WrapperType}}Methods struct {
{{range .Methods}}	{{.MethodName}} *{{.WrapperType}}
{{end}}}

`
	tmplTargetCallHandleStruct = `// {{.CallHandleType}} represents a single call to the wrapped function.
type {{.CallHandleType}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.CallableController[{{.ReturnsType}}Return{{.TypeParamsUse}}]
	controller        *{{.PkgImptest}}.TargetController
	pendingCompletion *{{.PkgImptest}}.PendingCompletion
	// Eventually is the async version of this call handle for registering non-blocking expectations.
	Eventually *{{.CallHandleType}}Eventually{{.TypeParamsUse}}
}

// {{.CallHandleType}}Eventually wraps a call handle for async expectation registration.
type {{.CallHandleType}}Eventually{{.TypeParamsDecl}} struct {
	h *{{.CallHandleType}}{{.TypeParamsUse}}
}

func (e *{{.CallHandleType}}Eventually{{.TypeParamsUse}}) ensureStarted() *{{.PkgImptest}}.PendingCompletion {
	if e.h.pendingCompletion == nil {
		e.h.pendingCompletion = e.h.controller.RegisterPendingCompletion()
		go func() {
			e.h.WaitForResponse()
			e.h.pendingCompletion.SetCompleted(e.h.Returned, e.h.Panicked)
		}()
	}
	return e.h.pendingCompletion
}

// ExpectReturnsEqual registers an async expectation for return values.
func (e *{{.CallHandleType}}Eventually{{.TypeParamsUse}}) ExpectReturnsEqual(values ...any) {
	e.ensureStarted().ExpectReturnsEqual(values...)
}

// ExpectPanicEquals registers an async expectation for a panic value.
func (e *{{.CallHandleType}}Eventually{{.TypeParamsUse}}) ExpectPanicEquals(value any) {
	e.ensureStarted().ExpectPanicEquals(value)
}

`
	tmplTargetConstructor = `// {{.WrapName}} wraps a function for testing.
func {{.WrapName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter, fn {{.FuncSig}}) *{{.WrapperType}}Handle{{.TypeParamsUse}} {
	ctrl := {{.PkgImptest}}.NewTargetController(t)
	return &{{.WrapperType}}Handle{{.TypeParamsUse}}{
		Method: &{{.WrapperType}}Method{{.TypeParamsUse}}{
			t:          t,
			controller: ctrl,
			callable:   fn,
		},
		Controller: ctrl,
	}
}

`
	tmplTargetExpectCompletes = `// ExpectCompletes verifies the function completes without panicking.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected function to complete, but it panicked with: %v", h.Panicked)
	}
}

`
	tmplTargetExpectPanic = `// ExpectPanicEquals verifies the function panics with the expected value.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectPanicEquals(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected function to panic, but it returned")
}

// ExpectPanicMatches verifies the function panics with a value matching the given matcher.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectPanicMatches(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected function to panic, but it returned")
}

`
	tmplTargetExpectReturns = `// ExpectReturnsEqual verifies the function returned the expected values.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectReturnsEqual({{.ExpectedParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		{{range .ResultChecks}}if !_reflect.DeepEqual(h.Returned.{{.Field}}, {{.Expected}}) {
			h.T.Fatalf("expected return value {{.Index}} to be %v, got %v", {{.Expected}}, h.Returned.{{.Field}})
		}
		{{end}}return
	}

	h.T.Fatalf("expected function to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnsMatch verifies the return values match the given matchers.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectReturnsMatch({{.MatcherParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		{{range .ResultChecks}}ok, msg = {{$.PkgImptest}}.MatchValue(h.Returned.{{.Field}}, {{.Expected}})
		if !ok {
			h.T.Fatalf("return value {{.Index}}: %s", msg)
		}
		{{end}}return
	}

	h.T.Fatalf("expected function to return, but it panicked with: %v", h.Panicked)
}

`
	tmplTargetHeader = `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	{{.PkgImptest}} "github.com/toejough/imptest"{{if .NeedsReflect}}
	{{.PkgReflect}} "reflect"{{end}}{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`
	tmplTargetReturnsStruct = `// {{.ReturnsType}}Return holds the return values from the wrapped function.
type {{.ReturnsType}}Return{{.TypeParamsDecl}} struct {
	{{if .HasResults}}{{range .ResultFields}}{{.Name}} {{.Type}}
	{{end}}{{end}}}

`
	tmplTargetStartMethod = `// Start executes the wrapped function in a goroutine.
func (m *{{.WrapperType}}Method{{.TypeParamsUse}}) Start({{.Params}}) *{{.CallHandleType}}{{.TypeParamsUse}} {
	handle := &{{.CallHandleType}}{{.TypeParamsUse}}{
		CallableController: {{.PkgImptest}}.NewCallableController[{{.ReturnsType}}Return{{.TypeParamsUse}}](m.t),
		controller:         m.controller,
	}
	handle.Eventually = &{{.CallHandleType}}Eventually{{.TypeParamsUse}}{h: handle}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		{{if .HasResults}}{{.ResultVars}} := m.callable({{.ParamNames}})
		handle.ReturnChan <- {{.ReturnsType}}Return{{.TypeParamsUse}}{ {{.ReturnAssignments}} }{{else}}m.callable({{.ParamNames}})
		handle.ReturnChan <- {{.ReturnsType}}Return{{.TypeParamsUse}}{}{{end}}
	}()
	return handle
}

`
	tmplTargetWrapperStruct = `// {{.WrapperType}}Handle is the test handle for a wrapped function.
type {{.WrapperType}}Handle{{.TypeParamsDecl}} struct {
	Method     *{{.WrapperType}}Method{{.TypeParamsUse}}
	Controller *{{.PkgImptest}}.TargetController
}

// {{.WrapperType}}Method wraps a function for testing.
type {{.WrapperType}}Method{{.TypeParamsDecl}} struct {
	t          {{.PkgImptest}}.TestReporter
	controller *{{.PkgImptest}}.TargetController
	callable   {{.FuncSig}}
}

`
)
