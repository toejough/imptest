//nolint:lll // Template strings naturally exceed line length
package generate

// unexported constants.
const (
	tmplDepArgsStruct = `{{if .HasParams}}// {{.ArgsTypeName}} holds typed arguments for {{.MethodName}}.
type {{.ArgsTypeName}}{{.TypeParamsDecl}} struct {
{{range .ParamFields}}	{{.Name}} {{.Type}}
{{end}}}

{{end}}`
	tmplDepCallWrapper = `{{if or .HasParams .HasResults}}// {{.CallTypeName}} wraps DependencyCall with typed GetArgs{{if .HasResults}} and Return{{end}}.
type {{.CallTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyCall
}
{{if .HasParams}}
// GetArgs returns the typed arguments for this call.
func (c *{{.CallTypeName}}{{.TypeParamsUse}}) GetArgs() {{.ArgsTypeName}}{{.TypeParamsUse}} {
	raw := c.RawArgs()
	return {{.ArgsTypeName}}{{.TypeParamsUse}}{
{{range .ParamFields}}		{{.Name}}: raw[{{.Index}}].({{.Type}}),
{{end}}	}
}
{{end}}{{if .HasResults}}
// Return specifies the typed values the mock should return.
func (c *{{.CallTypeName}}{{.TypeParamsUse}}) Return({{.TypedReturnParams}}) {
	c.DependencyCall.Return({{.ReturnParamNames}})
}
{{end}}{{end}}
`
	tmplDepConstructor = `// {{.MockName}} creates a mock {{.InterfaceName}} and returns (mock, expectation handle).
func {{.MockName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter) ({{if .IsStructType}}{{.MockTypeName}}Interface{{.TypeParamsUse}}{{else}}{{.InterfaceType}}{{end}}, *{{.ImpTypeName}}{{.TypeParamsUse}}) {
	ctrl := {{.PkgImptest}}.GetOrCreateImp(t)
	imp := &{{.ImpTypeName}}{{.TypeParamsUse}}{
{{range .Methods}}{{if .HasParams}}		{{.MethodName}}: new{{.MethodTypeName}}{{$.TypeParamsUse}}({{$.PkgImptest}}.NewDependencyMethod(ctrl, "{{.MethodName}}")),
{{else}}		{{.MethodName}}: {{$.PkgImptest}}.NewDependencyMethod(ctrl, "{{.MethodName}}"),
{{end}}{{end}}	}
	mock := &{{.ImplName}}{{.TypeParamsUse}}{ctrl: ctrl}
	return mock, imp
}

`
	tmplDepHeader = `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	{{.PkgImptest}} "github.com/toejough/imptest"{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`
	tmplDepImplMethod = `// {{.MethodName}} implements {{.InterfaceType}}.{{.MethodName}}.
func (impl *{{.ImplName}}{{.TypeParamsUse}}) {{.MethodName}}({{.Params}}){{.Results}} {
	{{if .HasVariadic}}callArgs := []any{ {{.NonVariadicArgs}} }
	for _, v := range {{.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	{{end}}call := &{{.PkgImptest}}.GenericCall{
		MethodName: "{{.MethodName}}",
		Args: {{if .HasVariadic}}callArgs{{else}}[]any{ {{.Args}} }{{end}},
		ResponseChan: make(chan {{.PkgImptest}}.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}
	{{if .HasResults}}{{range .ResultVars}}
	var {{.Name}} {{.Type}}
	if len(resp.ReturnValues) > {{.Index}} {
		if value, ok := resp.ReturnValues[{{.Index}}].({{.Type}}); ok {
			{{.Name}} = value
		}
	}
	{{end}}
	return {{.ReturnList}}{{end}}
}

`
	tmplDepImplStruct = `{{if .IsStructType}}// {{.ImplName}} implements {{.MockTypeName}}Interface.
{{else}}// {{.ImplName}} implements {{.InterfaceType}}.
{{end}}type {{.ImplName}}{{.TypeParamsDecl}} struct {
	ctrl *{{.PkgImptest}}.Imp
}

`
	tmplDepInterfaceMethod = `{{if .IsStructType}}// {{.MockTypeName}}Interface is a generated interface matching the methods of {{.InterfaceName}}.
type {{.MockTypeName}}Interface{{.TypeParamsDecl}} interface {
{{range .Methods}}	{{.MethodName}}({{.Params}}){{.Results}}
{{end}}}

{{end}}`
	tmplDepMethodWrapper = `{{if .HasParams}}// {{.MethodTypeName}} wraps DependencyMethod with typed returns.
type {{.MethodTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyMethod
	// Eventually is the async version of this method for concurrent code.
	Eventually *{{.MethodTypeName}}{{.TypeParamsUse}}
}

// new{{.MethodTypeName}} creates a typed method wrapper with Eventually initialized.
func new{{.MethodTypeName}}{{.TypeParamsDecl}}(dm *{{.PkgImptest}}.DependencyMethod) *{{.MethodTypeName}}{{.TypeParamsUse}} {
	m := &{{.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: dm}
	m.Eventually = &{{.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: dm.Eventually}
	return m
}

// Expect waits for a call with exactly the specified arguments.
func (m *{{.MethodTypeName}}{{.TypeParamsUse}}) Expect({{.TypedParams}}) *{{.CallTypeName}}{{.TypeParamsUse}} {
	{{if .HasVariadic}}callArgs := []any{ {{if .NonVariadicArgs}}{{.NonVariadicArgs}}{{end}} }
	for _, v := range {{.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	call := m.DependencyMethod.Expect(callArgs...){{else}}call := m.DependencyMethod.Expect({{.ArgNames}}){{end}}
	return &{{.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

// Match waits for a call with arguments matching the given matchers.
func (m *{{.MethodTypeName}}{{.TypeParamsUse}}) Match(matchers ...any) *{{.CallTypeName}}{{.TypeParamsUse}} {
	call := m.DependencyMethod.Match(matchers...)
	return &{{.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

{{end}}
`
	tmplDepMockStruct = `// {{.ImpTypeName}} holds method wrappers for setting expectations on {{.InterfaceName}}.
type {{.ImpTypeName}}{{.TypeParamsDecl}} struct {
{{range .Methods}}{{if .HasParams}}	{{.MethodName}} *{{.MethodTypeName}}{{$.TypeParamsUse}}
{{else}}	{{.MethodName}} *{{$.PkgImptest}}.DependencyMethod
{{end}}{{end}}}

`
	tmplFuncDepConstructor = `// {{.MockName}} creates a mock {{.FuncName}} function and returns (mock, expectation handle).
func {{.MockName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter) ({{.FuncSig}}, {{if .Method.HasParams}}*{{.Method.MethodTypeName}}{{.TypeParamsUse}}{{else}}*{{.PkgImptest}}.DependencyMethod{{end}}) {
	ctrl := {{.PkgImptest}}.GetOrCreateImp(t)
{{if .Method.HasParams}}	imp := new{{.Method.MethodTypeName}}{{.TypeParamsUse}}({{.PkgImptest}}.NewDependencyMethod(ctrl, "{{.FuncName}}"))
{{else}}	imp := {{.PkgImptest}}.NewDependencyMethod(ctrl, "{{.FuncName}}")
{{end}}	mock := func({{.Method.Params}}){{.Method.Results}} {
		{{if .Method.HasVariadic}}callArgs := []any{ {{.Method.NonVariadicArgs}} }
		for _, v := range {{.Method.VariadicArg}} {
			callArgs = append(callArgs, v)
		}
		{{end}}call := &{{.PkgImptest}}.GenericCall{
			MethodName: "{{.FuncName}}",
			Args: {{if .Method.HasVariadic}}callArgs{{else}}[]any{ {{.Method.Args}} }{{end}},
			ResponseChan: make(chan {{.PkgImptest}}.GenericResponse, 1),
		}
		ctrl.CallChan <- call
		resp := <-call.ResponseChan
		if resp.Type == "panic" {
			panic(resp.PanicValue)
		}
		{{if .Method.HasResults}}{{range .Method.ResultVars}}
		var {{.Name}} {{.Type}}
		if len(resp.ReturnValues) > {{.Index}} {
			if value, ok := resp.ReturnValues[{{.Index}}].({{.Type}}); ok {
				{{.Name}} = value
			}
		}
		{{end}}
		return {{.Method.ReturnList}}{{end}}
	}
	return mock, imp
}

`
	tmplFuncDepMethodWrapper = `{{if .Method.HasParams}}// {{.Method.MethodTypeName}} wraps DependencyMethod with typed returns.
type {{.Method.MethodTypeName}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.DependencyMethod
	// Eventually is the async version of this method for concurrent code.
	Eventually *{{.Method.MethodTypeName}}{{.TypeParamsUse}}
}

// new{{.Method.MethodTypeName}} creates a typed method wrapper with Eventually initialized.
func new{{.Method.MethodTypeName}}{{.TypeParamsDecl}}(dm *{{.PkgImptest}}.DependencyMethod) *{{.Method.MethodTypeName}}{{.TypeParamsUse}} {
	m := &{{.Method.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: dm}
	m.Eventually = &{{.Method.MethodTypeName}}{{.TypeParamsUse}}{DependencyMethod: dm.Eventually}
	return m
}

// Expect waits for a call with exactly the specified arguments.
func (m *{{.Method.MethodTypeName}}{{.TypeParamsUse}}) Expect({{.Method.TypedParams}}) *{{.Method.CallTypeName}}{{.TypeParamsUse}} {
	{{if .Method.HasVariadic}}callArgs := []any{ {{if .Method.NonVariadicArgs}}{{.Method.NonVariadicArgs}}{{end}} }
	for _, v := range {{.Method.VariadicArg}} {
		callArgs = append(callArgs, v)
	}
	call := m.DependencyMethod.Expect(callArgs...){{else}}call := m.DependencyMethod.Expect({{.Method.ArgNames}}){{end}}
	return &{{.Method.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

// Match waits for a call with arguments matching the given matchers.
func (m *{{.Method.MethodTypeName}}{{.TypeParamsUse}}) Match(matchers ...any) *{{.Method.CallTypeName}}{{.TypeParamsUse}} {
	call := m.DependencyMethod.Match(matchers...)
	return &{{.Method.CallTypeName}}{{.TypeParamsUse}}{DependencyCall: call}
}

{{end}}
`
	tmplFuncDepMockStruct          = `` // No longer needed - function mocks use two-return style
	tmplInterfaceTargetConstructor = `// {{.WrapName}} creates a new wrapper for the given {{.InterfaceType}} implementation.
func {{.WrapName}}(t *testing.T, {{.ImplName}} {{if .IsStructType}}*{{end}}{{.InterfaceType}}) *{{.WrapperType}}Handle {
	h := &{{.WrapperType}}Handle{
		impl: {{.ImplName}},
	}
{{range .Methods}}	h.{{.MethodName}} = {{.WrapName}}(t, func({{.Params}}){{if .HasResults}} {{.ReturnsType}}{{end}} {
{{if .HasResults}}		{{.ResultVars}} := h.impl.{{.MethodName}}({{.ParamNames}})
		return {{.ReturnsType}}{ {{.ReturnAssignments}} }
{{else}}		h.impl.{{.MethodName}}({{.ParamNames}})
		return {{.ReturnsType}}{}
{{end}}	})
{{end}}	return h
}

`
	tmplInterfaceTargetHeader = `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	"testing"
	{{.PkgImptest}} "github.com/toejough/imptest"{{if .NeedsReflect}}
	{{.PkgReflect}} "reflect"{{end}}{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`
	tmplInterfaceTargetMethodCallHandleStruct = `// {{.CallHandleType}} represents a single call to the wrapped method.
type {{.CallHandleType}} struct {
	*{{.PkgImptest}}.CallableController[{{.ReturnsType}}]
}

`
	tmplInterfaceTargetMethodExpectCompletes = `// ExpectCompletes verifies the method completes without panicking.
func (h *{{.CallHandleType}}) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected method to complete, but it panicked with: %v", h.Panicked)
	}
}

`
	tmplInterfaceTargetMethodExpectPanic = `// ExpectPanic verifies the method panics with the expected value.
func (h *{{.CallHandleType}}) ExpectPanic(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

// ExpectPanicMatch verifies the method panics with a value matching the given matcher.
func (h *{{.CallHandleType}}) ExpectPanicMatch(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected method to panic, but it returned")
}

`
	tmplInterfaceTargetMethodExpectReturns = `// ExpectReturn verifies the method returned the expected values.
func (h *{{.CallHandleType}}) ExpectReturn({{.ExpectedParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		{{range .ResultChecks}}if !_reflect.DeepEqual(h.Returned.{{.Field}}, {{.Expected}}) {
			h.T.Fatalf("expected return value {{.Index}} to be %v, got %v", {{.Expected}}, h.Returned.{{.Field}})
		}
		{{end}}return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnMatch verifies the return values match the given matchers.
func (h *{{.CallHandleType}}) ExpectReturnMatch({{.MatcherParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		{{range .ResultChecks}}ok, msg = {{$.PkgImptest}}.MatchValue(h.Returned.{{.Field}}, {{.Expected}})
		if !ok {
			h.T.Fatalf("return value {{.Index}}: %s", msg)
		}
		{{end}}return
	}

	h.T.Fatalf("expected method to return, but it panicked with: %v", h.Panicked)
}

`
	tmplInterfaceTargetMethodReturns = `type {{.ReturnsType}} struct {
{{range .ResultFields}}	{{.Name}} {{.Type}}
{{end}}}

`
	tmplInterfaceTargetMethodStart = `// Start executes the wrapped method in a goroutine.
func (w *{{.WrapperType}}) Start({{.Params}}) *{{.CallHandleType}} {
	handle := &{{.CallHandleType}}{
		CallableController: {{.PkgImptest}}.NewCallableController[{{.ReturnsType}}](w.t),
	}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		returns := w.fn({{.ParamNames}})
		handle.ReturnChan <- returns
	}()
	return handle
}

`
	tmplInterfaceTargetMethodWrapperFunc = `func {{.WrapName}}(t *testing.T, fn func({{.Params}}){{if .HasResults}} {{.ReturnsType}}{{end}}) *{{.WrapperType}} {
	return &{{.WrapperType}}{t: t, fn: fn}
}

`
	tmplInterfaceTargetMethodWrapperStruct = `type {{.WrapperType}} struct {
	t *testing.T
	fn func({{.Params}}){{if .HasResults}} {{.ReturnsType}}{{end}}
}

`
	tmplInterfaceTargetWrapperStruct = `// {{.WrapperType}}Handle wraps an implementation of {{.InterfaceType}} to intercept method calls.
type {{.WrapperType}}Handle struct {
{{range .Methods}}	{{.MethodName}} *{{.WrapperType}}
{{end}}	impl {{if .IsStructType}}*{{end}}{{.InterfaceType}}
}

`
	tmplTargetCallHandleStruct = `// {{.CallHandleType}} represents a single call to the wrapped function.
type {{.CallHandleType}}{{.TypeParamsDecl}} struct {
	*{{.PkgImptest}}.CallableController[{{.ReturnsType}}Return{{.TypeParamsUse}}]
	controller        *{{.PkgImptest}}.TargetController
	pendingCompletion *{{.PkgImptest}}.PendingCompletion
	// Eventually is the async version of this call handle for registering non-blocking expectations.
	Eventually *{{.CallHandleType}}Eventually{{.TypeParamsUse}}
}

// {{.CallHandleType}}Eventually wraps a call handle for async expectation registration.
type {{.CallHandleType}}Eventually{{.TypeParamsDecl}} struct {
	h *{{.CallHandleType}}{{.TypeParamsUse}}
}

func (e *{{.CallHandleType}}Eventually{{.TypeParamsUse}}) ensureStarted() *{{.PkgImptest}}.PendingCompletion {
	if e.h.pendingCompletion == nil {
		e.h.pendingCompletion = e.h.controller.RegisterPendingCompletion()
		go func() {
			e.h.WaitForResponse()
			e.h.pendingCompletion.SetCompleted(e.h.Returned, e.h.Panicked)
		}()
	}
	return e.h.pendingCompletion
}

// ExpectReturn registers an async expectation for return values.
func (e *{{.CallHandleType}}Eventually{{.TypeParamsUse}}) ExpectReturn(values ...any) {
	e.ensureStarted().ExpectReturn(values...)
}

// ExpectPanic registers an async expectation for a panic value.
func (e *{{.CallHandleType}}Eventually{{.TypeParamsUse}}) ExpectPanic(value any) {
	e.ensureStarted().ExpectPanic(value)
}

`
	tmplTargetConstructor = `// {{.WrapName}} wraps a function for testing.
func {{.WrapName}}{{.TypeParamsDecl}}(t {{.PkgImptest}}.TestReporter, fn {{.FuncSig}}) *{{.WrapperType}}Handle{{.TypeParamsUse}} {
	return &{{.WrapperType}}Handle{{.TypeParamsUse}}{
		t:          t,
		controller: {{.PkgImptest}}.NewTargetController(t),
		callable:   fn,
	}
}

`
	tmplTargetExpectCompletes = `// ExpectCompletes verifies the function completes without panicking.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectCompletes() {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		h.T.Fatalf("expected function to complete, but it panicked with: %v", h.Panicked)
	}
}

`
	tmplTargetExpectPanic = `// ExpectPanic verifies the function panics with the expected value.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectPanic(expected any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, expected)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected function to panic, but it returned")
}

// ExpectPanicMatch verifies the function panics with a value matching the given matcher.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectPanicMatch(matcher any) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Panicked != nil {
		ok, msg := {{.PkgImptest}}.MatchValue(h.Panicked, matcher)
		if !ok {
			h.T.Fatalf("panic value: %s", msg)
		}
		return
	}

	h.T.Fatalf("expected function to panic, but it returned")
}

`
	tmplTargetExpectReturns = `// ExpectReturn verifies the function returned the expected values.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectReturn({{.ExpectedParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		{{range .ResultChecks}}if !_reflect.DeepEqual(h.Returned.{{.Field}}, {{.Expected}}) {
			h.T.Fatalf("expected return value {{.Index}} to be %v, got %v", {{.Expected}}, h.Returned.{{.Field}})
		}
		{{end}}return
	}

	h.T.Fatalf("expected function to return, but it panicked with: %v", h.Panicked)
}

// ExpectReturnMatch verifies the return values match the given matchers.
func (h *{{.CallHandleType}}{{.TypeParamsUse}}) ExpectReturnMatch({{.MatcherParams}}) {
	h.T.Helper()
	h.WaitForResponse()

	if h.Returned != nil {
		var ok bool
		var msg string
		{{range .ResultChecks}}ok, msg = {{$.PkgImptest}}.MatchValue(h.Returned.{{.Field}}, {{.Expected}})
		if !ok {
			h.T.Fatalf("return value {{.Index}}: %s", msg)
		}
		{{end}}return
	}

	h.T.Fatalf("expected function to return, but it panicked with: %v", h.Panicked)
}

`
	tmplTargetHeader = `// Code generated by impgen. DO NOT EDIT.

package {{.PkgName}}

import (
	{{.PkgImptest}} "github.com/toejough/imptest"{{if .NeedsReflect}}
	{{.PkgReflect}} "reflect"{{end}}{{if .NeedsQualifier}}
	{{.Qualifier}} "{{.PkgPath}}"{{end}}{{range .AdditionalImports}}
	{{.Alias}} "{{.Path}}"{{end}}
)

`
	tmplTargetReturnsStruct = `// {{.ReturnsType}}Return holds the return values from the wrapped function.
type {{.ReturnsType}}Return{{.TypeParamsDecl}} struct {
	{{if .HasResults}}{{range .ResultFields}}{{.Name}} {{.Type}}
	{{end}}{{end}}}

`
	tmplTargetStartMethod = `// Start executes the wrapped function in a goroutine.
func (w *{{.WrapperType}}Handle{{.TypeParamsUse}}) Start({{.Params}}) *{{.CallHandleType}}{{.TypeParamsUse}} {
	handle := &{{.CallHandleType}}{{.TypeParamsUse}}{
		CallableController: {{.PkgImptest}}.NewCallableController[{{.ReturnsType}}Return{{.TypeParamsUse}}](w.t),
		controller:         w.controller,
	}
	handle.Eventually = &{{.CallHandleType}}Eventually{{.TypeParamsUse}}{h: handle}
	go func() {
		defer func() {
			if r := recover(); r != nil {
				handle.PanicChan <- r
			}
		}()
		{{if .HasResults}}{{.ResultVars}} := w.callable({{.ParamNames}})
		handle.ReturnChan <- {{.ReturnsType}}Return{{.TypeParamsUse}}{ {{.ReturnAssignments}} }{{else}}w.callable({{.ParamNames}})
		handle.ReturnChan <- {{.ReturnsType}}Return{{.TypeParamsUse}}{}{{end}}
	}()
	return handle
}

`
	tmplTargetWrapperStruct = `// {{.WrapperType}}Handle is the test handle for a wrapped function.
type {{.WrapperType}}Handle{{.TypeParamsDecl}} struct {
	t          {{.PkgImptest}}.TestReporter
	controller *{{.PkgImptest}}.TargetController
	callable   {{.FuncSig}}
}

`
)
