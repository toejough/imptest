package run

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"strings"
	"unicode"
)

var errFunctionNotFound = errors.New("function not found")

// Structs

// codeGenerator holds state for code generation.
type codeGenerator struct {
	buf                 bytes.Buffer
	fset                *token.FileSet
	pkgName             string
	impName             string
	mockName            string
	callName            string
	expectCallToName    string
	timedName           string
	identifiedInterface *ast.InterfaceType
	methodNames         []string
}

// Methods on codeGenerator

// forEachMethod iterates over interface methods and calls the callback for each.
func (gen *codeGenerator) forEachMethod(callback func(methodName string, ftype *ast.FuncType)) {
	forEachInterfaceMethod(gen.identifiedInterface, callback)
}

// generateCallAsMethod generates As{Method}() methods that return typed call structs.
func (gen *codeGenerator) generateCallAsMethod() {
	for _, methodName := range gen.methodNames {
		gen.pf("func (c *%s) As%s() *%s { return c.%s }\n\n",
			gen.callName, methodName, gen.methodCallName(methodName), methodName)
	}
}

// generateCallDoneMethod generates the Done() method that checks if any method call is completed.
func (gen *codeGenerator) generateCallDoneMethod() {
	gen.pf(`func (c *%s) Done() bool {
`, gen.callName)

	for _, methodName := range gen.methodNames {
		gen.pf(`	if c.%s != nil {
		return c.%s.done
	}
`, methodName, methodName)
	}

	gen.pf(`	return false
}

`)
}

// generateCallNameMethod generates the Name() method that returns the called method's name.
func (gen *codeGenerator) generateCallNameMethod() {
	gen.pf("func (c *%s) Name() string {\n", gen.callName)

	for _, methodName := range gen.methodNames {
		gen.pf(`	if c.%s != nil {
		return %q
	}
`, methodName, methodName)
	}

	gen.pf(`	return ""
}

`)
}

// generateCallStruct generates the union call struct that can hold any method call.
func (gen *codeGenerator) generateCallStruct() {
	gen.pf("type %s struct {\n", gen.callName)

	for _, methodName := range gen.methodNames {
		gen.pf("\t%s *%s\n", methodName, gen.methodCallName(methodName))
	}

	gen.pf("}\n\n")

	gen.generateCallNameMethod()
	gen.generateCallDoneMethod()
	gen.generateCallAsMethod()
}

// generateHeader writes the package declaration and imports for the generated file.
func (gen *codeGenerator) generateHeader() {
	gen.pf(`package %s

// Code generated by impgen. DO NOT EDIT.

import "sync"
import "testing"
import "time"

`, gen.pkgName)
}

// generateMockStruct generates the mock struct that wraps the implementation.
func (gen *codeGenerator) generateMockStruct() {
	gen.pf(`type %s struct {
	imp *%s
}

`, gen.mockName, gen.impName)
}

// generateMainStruct generates the main implementation struct that handles test call tracking.
func (gen *codeGenerator) generateMainStruct() {
	gen.pf(`type %s struct {
	t *testing.T
	Mock *%s
	callChan chan *%s
	ExpectCallTo *%s
	currentCall *%s
	callQueue []*%s
	queueLock sync.Mutex
}

`, gen.impName, gen.mockName, gen.callName, gen.expectCallToName, gen.callName, gen.callName)
}

// methodCallName returns the call struct name for a method (e.g. "MyImpDoSomethingCall").
func (gen *codeGenerator) methodCallName(methodName string) string {
	return gen.impName + methodName + "Call"
}

// pf writes a formatted string to the buffer (short for "print").
func (gen *codeGenerator) pf(format string, args ...any) {
	fmt.Fprintf(&gen.buf, format, args...)
}

// writeMethodSignature writes the method name and parameters (e.g., "MethodName(a int, b string)").
func (gen *codeGenerator) writeMethodSignature(methodName string, ftype *ast.FuncType, paramNames []string) {
	gen.pf("%s(", methodName)
	gen.writeMethodParams(ftype, paramNames)
	gen.pf(")")
}

// generateMethodStructs generates the call and response structs for each interface method.
func (gen *codeGenerator) generateMethodStructs() {
	gen.forEachMethod(func(methodName string, ftype *ast.FuncType) {
		gen.generateMethodCallStruct(methodName, ftype)
		gen.generateMethodResponseStruct(methodName, ftype)
		gen.generateMethodResponseMethods(methodName, ftype)
	})
}

// generateMethodCallStruct generates the call struct for a specific method, which tracks the method call parameters.
func (gen *codeGenerator) generateMethodCallStruct(methodName string, ftype *ast.FuncType) {
	callName := gen.methodCallName(methodName)
	gen.pf(`type %s struct {
	responseChan chan %sResponse
	done bool
`, callName, callName)

	if hasParams(ftype) {
		gen.generateCallStructParamFields(ftype)
	}

	gen.pf("}\n\n")
}

// generateCallStructParamFields generates the parameter fields for a call struct.
func (gen *codeGenerator) generateCallStructParamFields(ftype *ast.FuncType) {
	totalParams := countFields(ftype.Params)
	unnamedIndex := 0

	for _, param := range ftype.Params.List {
		paramType := exprToString(gen.fset, param.Type)

		if len(param.Names) > 0 {
			gen.generateNamedParamFields(param, paramType, unnamedIndex, totalParams)
		} else {
			gen.generateUnnamedParamField(param, paramType, unnamedIndex, totalParams)
			unnamedIndex++
		}
	}
}

// generateNamedParamFields generates fields for named parameters.
func (gen *codeGenerator) generateNamedParamFields(param *ast.Field, paramType string, unnamedIndex, totalParams int) {
	for i := range param.Names {
		fieldName := getParamFieldName(param, i, unnamedIndex, paramType, totalParams)
		gen.pf("\t%s %s\n", fieldName, paramType)
	}
}

// generateUnnamedParamField generates a field for an unnamed parameter.
func (gen *codeGenerator) generateUnnamedParamField(param *ast.Field, paramType string, unnamedIndex, totalParams int) {
	fieldName := getParamFieldName(param, 0, unnamedIndex, paramType, totalParams)
	gen.pf("\t%s %s\n", fieldName, paramType)
}

// generateMethodResponseStruct generates the response struct for a method, which holds return values or panic data.
func (gen *codeGenerator) generateMethodResponseStruct(methodName string, ftype *ast.FuncType) {
	callName := gen.methodCallName(methodName)
	gen.pf(`type %sResponse struct {
	Type string // "return", "panic", or "resolve"
`, callName)

	if hasResults(ftype) {
		gen.generateResponseStructResultFields(ftype)
	}

	gen.pf(`	PanicValue any
}

`)
}

// generateResponseStructResultFields generates the result fields for a response struct.
func (gen *codeGenerator) generateResponseStructResultFields(ftype *ast.FuncType) {
	returnIndex := 0

	for _, result := range ftype.Results.List {
		resultType := exprToString(gen.fset, result.Type)
		returnIndex = gen.generateResultField(result, resultType, returnIndex)
	}
}

// generateResultField generates a single result field (named or unnamed).
func (gen *codeGenerator) generateResultField(result *ast.Field, resultType string, returnIndex int) int {
	if len(result.Names) > 0 {
		return gen.generateNamedResultFields(result, resultType, returnIndex)
	}

	gen.pf("\tResult%d %s\n", returnIndex, resultType)

	return returnIndex + 1
}

// generateNamedResultFields generates fields for named return values.
func (gen *codeGenerator) generateNamedResultFields(result *ast.Field, resultType string, returnIndex int) int {
	for _, name := range result.Names {
		gen.pf("\t%s %s\n", name.Name, resultType)

		returnIndex++
	}

	return returnIndex
}

// generateMethodResponseMethods generates the InjectResult, InjectResults, InjectPanic, and Resolve methods
// for a call struct.
func (gen *codeGenerator) generateMethodResponseMethods(methodName string, ftype *ast.FuncType) {
	callName := gen.methodCallName(methodName)

	if hasResults(ftype) {
		totalReturns := countFields(ftype.Results)

		if totalReturns == 1 {
			gen.generateInjectResultMethod(callName, ftype)
		} else {
			gen.generateInjectResultsMethod(callName, ftype)
		}

		gen.generateInjectPanicMethod(callName)
	} else {
		gen.generateResolveMethod(callName)
		gen.generateInjectPanicMethod(callName)
	}

	gen.pf("\n")
}

// generateInjectResultMethod generates the InjectResult method for methods with a single return value.
func (gen *codeGenerator) generateInjectResultMethod(methodCallName string, ftype *ast.FuncType) {
	resultType := exprToString(gen.fset, ftype.Results.List[0].Type)
	gen.pf(`func (c *%s) InjectResult(result %s) {
	c.done = true
	c.responseChan <- %sResponse{Type: "return"`, methodCallName, resultType, methodCallName)

	if len(ftype.Results.List[0].Names) > 0 {
		gen.pf(", %s: result", ftype.Results.List[0].Names[0].Name)
	} else {
		gen.pf(", Result0: result")
	}

	gen.pf(`}
}
`)
}

// generateInjectResultsMethod generates the InjectResults method for methods with multiple return values.
func (gen *codeGenerator) generateInjectResultsMethod(methodCallName string, ftype *ast.FuncType) {
	gen.pf("func (c *%s) InjectResults(", methodCallName)

	returnParamNames := gen.writeInjectResultsParams(ftype)

	gen.pf(`) {
	c.done = true
	resp := %sResponse{Type: "return"`, methodCallName)

	gen.writeInjectResultsResponseFields(ftype, returnParamNames)

	gen.pf(`}
	c.responseChan <- resp
}
`)
}

// writeInjectResultsParams writes the parameter list for InjectResults method and returns parameter names.
func (gen *codeGenerator) writeInjectResultsParams(ftype *ast.FuncType) []string {
	returnIndex := 0
	returnParamNames := make([]string, 0)

	for _, result := range ftype.Results.List {
		resultType := exprToString(gen.fset, result.Type)
		returnIndex, returnParamNames = gen.writeInjectResultParam(result, resultType, returnIndex, returnParamNames)
	}

	return returnParamNames
}

// writeInjectResultParam writes a single result parameter (named or unnamed).
func (gen *codeGenerator) writeInjectResultParam(
	result *ast.Field, resultType string, returnIndex int, returnParamNames []string,
) (int, []string) {
	if len(result.Names) > 0 {
		return gen.writeNamedResultParams(result, resultType, returnIndex, returnParamNames)
	}

	if returnIndex > 0 {
		gen.pf(", ")
	}

	paramName := fmt.Sprintf("result%d", returnIndex)
	gen.pf("%s %s", paramName, resultType)
	returnParamNames = append(returnParamNames, paramName)

	return returnIndex + 1, returnParamNames
}

// writeNamedResultParams writes named result parameters.
func (gen *codeGenerator) writeNamedResultParams(
	result *ast.Field, resultType string, returnIndex int, returnParamNames []string,
) (int, []string) {
	for _, name := range result.Names {
		if returnIndex > 0 {
			gen.pf(", ")
		}

		gen.pf("%s %s", name.Name, resultType)
		returnParamNames = append(returnParamNames, name.Name)
		returnIndex++
	}

	return returnIndex, returnParamNames
}

// writeInjectResultsResponseFields writes the response struct field assignments for InjectResults.
func (gen *codeGenerator) writeInjectResultsResponseFields(ftype *ast.FuncType, returnParamNames []string) {
	returnIndex := 0

	for _, result := range ftype.Results.List {
		returnIndex = gen.writeInjectResultResponseField(result, returnParamNames, returnIndex)
	}
}

// writeInjectResultResponseField writes a single response field assignment.
func (gen *codeGenerator) writeInjectResultResponseField(
	result *ast.Field, returnParamNames []string, returnIndex int,
) int {
	if len(result.Names) > 0 {
		for _, name := range result.Names {
			gen.pf(", %s: %s", name.Name, returnParamNames[returnIndex])
			returnIndex++
		}

		return returnIndex
	}

	gen.pf(", Result%d: %s", returnIndex, returnParamNames[returnIndex])

	return returnIndex + 1
}

// generateInjectPanicMethod generates the InjectPanic method for simulating panics.
func (gen *codeGenerator) generateInjectPanicMethod(methodCallName string) {
	gen.pf(`func (c *%s) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- %sResponse{Type: "panic", PanicValue: msg}
}
`, methodCallName, methodCallName)
}

// generateResolveMethod generates the Resolve method for methods with no return values.
func (gen *codeGenerator) generateResolveMethod(methodCallName string) {
	gen.pf(`func (c *%s) Resolve() {
	c.done = true
	c.responseChan <- %sResponse{Type: "resolve"}
}
`, methodCallName, methodCallName)
}

// generateMockMethods generates the mock methods that implement the interface on the mock struct.
func (gen *codeGenerator) generateMockMethods() {
	gen.forEachMethod(func(methodName string, ftype *ast.FuncType) {
		gen.generateMockMethod(methodName, ftype)
	})
}

// generateMockMethod generates a single mock method that creates a call, sends it to the imp, and handles the response.
func (gen *codeGenerator) generateMockMethod(methodName string, ftype *ast.FuncType) {
	callName := gen.methodCallName(methodName)
	paramNames := extractParamNames(ftype)

	gen.pf("func (m *%s) ", gen.mockName)
	gen.writeMethodSignature(methodName, ftype, paramNames)
	gen.pf("%s", renderFieldList(gen.fset, ftype.Results))
	gen.pf(` {
	responseChan := make(chan %sResponse, 1)

	call := &%s{
		responseChan: responseChan,
`, callName, callName)
	gen.writeCallStructFields(ftype, paramNames)
	gen.pf(`	}

	callEvent := &%s{
		%s: call,
	}

	m.imp.callChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

`, gen.callName, methodName)

	gen.writeReturnStatement(ftype)
	gen.pf("}\n\n")
}

// writeMethodParams writes the method parameters in the form "name type, name2 type2".
func (gen *codeGenerator) writeMethodParams(ftype *ast.FuncType, paramNames []string) {
	if !hasParams(ftype) {
		return
	}

	paramNameIndex := 0

	for i, param := range ftype.Params.List {
		if i > 0 {
			gen.pf(", ")
		}

		paramType := exprToString(gen.fset, param.Type)
		paramNameIndex = gen.writeParamForField(param, paramType, paramNames, paramNameIndex)
	}
}

// writeParamForField writes parameters for a single field (which may contain multiple names).
func (gen *codeGenerator) writeParamForField(
	param *ast.Field, paramType string, paramNames []string, paramNameIndex int,
) int {
	if len(param.Names) > 0 {
		return gen.writeNamedParams(param, paramType, paramNameIndex)
	}

	gen.pf("%s %s", paramNames[paramNameIndex], paramType)

	return paramNameIndex + 1
}

// writeNamedParams writes multiple named parameters of the same type.
func (gen *codeGenerator) writeNamedParams(param *ast.Field, paramType string, paramNameIndex int) int {
	for j, name := range param.Names {
		if j > 0 {
			gen.pf(", ")
		}

		gen.pf("%s %s", name.Name, paramType)

		paramNameIndex++
	}

	return paramNameIndex
}

// writeCallStructFields writes the field assignments for initializing a call struct.
func (gen *codeGenerator) writeCallStructFields(ftype *ast.FuncType, paramNames []string) {
	if !hasParams(ftype) {
		return
	}

	totalParams := countFields(ftype.Params)
	paramNameIndex := 0
	unnamedIndex := 0

	for _, param := range ftype.Params.List {
		paramType := exprToString(gen.fset, param.Type)
		paramNameIndex, unnamedIndex = gen.writeCallStructField(
			param, paramType, paramNames, paramNameIndex, unnamedIndex, totalParams,
		)
	}
}

// writeCallStructField writes a single field assignment for a call struct initialization.
func (gen *codeGenerator) writeCallStructField(
	param *ast.Field, paramType string, paramNames []string, paramNameIndex, unnamedIndex, totalParams int,
) (int, int) {
	if len(param.Names) > 0 {
		for i, name := range param.Names {
			fieldName := getParamFieldName(param, i, unnamedIndex, paramType, totalParams)
			gen.pf("\t\t%s: %s,\n", fieldName, name.Name)

			paramNameIndex++
		}

		return paramNameIndex, unnamedIndex
	}

	fieldName := getParamFieldName(param, 0, unnamedIndex, paramType, totalParams)
	gen.pf("\t\t%s: %s,\n", fieldName, paramNames[paramNameIndex])

	return paramNameIndex + 1, unnamedIndex + 1
}

// writeReturnStatement writes the return statement for a mock method.
func (gen *codeGenerator) writeReturnStatement(ftype *ast.FuncType) {
	if !hasResults(ftype) {
		gen.pf("\treturn\n")
		return
	}

	gen.pf("\treturn")
	gen.writeReturnValues(ftype)
	gen.pf("\n")
}

// writeReturnValues writes all return values from the response struct.
func (gen *codeGenerator) writeReturnValues(ftype *ast.FuncType) {
	returnIndex := 0

	for _, result := range ftype.Results.List {
		returnIndex = gen.writeReturnValue(result, returnIndex)
	}
}

// writeReturnValue writes a single return value from the response struct.
func (gen *codeGenerator) writeReturnValue(result *ast.Field, returnIndex int) int {
	if len(result.Names) > 0 {
		for _, name := range result.Names {
			if returnIndex > 0 {
				gen.pf(", ")
			}

			gen.pf(" resp.%s", name.Name)

			returnIndex++
		}

		return returnIndex
	}

	if returnIndex > 0 {
		gen.pf(", ")
	}

	gen.pf(" resp.Result%d", returnIndex)

	return returnIndex + 1
}

// generateExpectCallToStruct generates the struct for expecting specific method calls.
func (gen *codeGenerator) generateExpectCallToStruct() {
	gen.pf(`type %s struct {
	imp *%s
	timeout time.Duration
}

`, gen.expectCallToName, gen.impName)
}

// generateExpectCallToMethods generates expectation methods for each interface method.
func (gen *codeGenerator) generateExpectCallToMethods() {
	gen.forEachMethod(func(methodName string, ftype *ast.FuncType) {
		gen.generateExpectCallToMethod(methodName, ftype)
	})
}

// generateExpectCallToMethod generates a single expectation method that validates and returns a call.
func (gen *codeGenerator) generateExpectCallToMethod(methodName string, ftype *ast.FuncType) {
	callName := gen.methodCallName(methodName)
	paramNames := extractParamNames(ftype)

	gen.pf("func (e *%s) ", gen.expectCallToName)
	gen.writeMethodSignature(methodName, ftype, paramNames)
	gen.pf(" *%s {\n", callName)

	gen.generateValidatorFunction(methodName, ftype, paramNames)

	gen.pf(`	call := e.imp.GetCall(e.timeout, validator)
	return call.As%s()
}

`, methodName)
}

// generateValidatorFunction generates a validator closure that checks method name and parameters.
func (gen *codeGenerator) generateValidatorFunction(methodName string, ftype *ast.FuncType, paramNames []string) {
	gen.pf(`	validator := func(c *%s) bool {
		if c.Name() != %q {
			return false
		}
`, gen.callName, methodName)

	if hasParams(ftype) {
		gen.pf("		methodCall := c.As%s()\n", methodName)
		gen.writeValidatorChecks(ftype, paramNames)
	}

	gen.pf(`		return true
	}

`)
}

// writeValidatorChecks writes parameter validation checks for an expectation method.
func (gen *codeGenerator) writeValidatorChecks(ftype *ast.FuncType, paramNames []string) {
	totalParams := countFields(ftype.Params)
	paramNameIndex := 0
	unnamedIndex := 0

	for _, param := range ftype.Params.List {
		paramType := exprToString(gen.fset, param.Type)
		paramNameIndex, unnamedIndex = gen.writeValidatorCheck(
			param, paramType, paramNames, paramNameIndex, unnamedIndex, totalParams,
		)
	}
}

// writeValidatorCheck writes a single parameter validation check.
func (gen *codeGenerator) writeValidatorCheck(
	param *ast.Field, paramType string, paramNames []string, paramNameIndex, unnamedIndex, totalParams int,
) (int, int) {
	if len(param.Names) > 0 {
		for i, name := range param.Names {
			fieldName := getParamFieldName(param, i, unnamedIndex, paramType, totalParams)
			gen.pf(`		if methodCall.%s != %s {
			return false
		}
`, fieldName, name.Name)

			paramNameIndex++
		}

		return paramNameIndex, unnamedIndex
	}

	fieldName := getParamFieldName(param, 0, unnamedIndex, paramType, totalParams)
	gen.pf(`		if methodCall.%s != %s {
			return false
		}
`, fieldName, paramNames[paramNameIndex])

	return paramNameIndex + 1, unnamedIndex + 1
}

// generateTimedStruct generates the struct and method for timed call expectations.
func (gen *codeGenerator) generateTimedStruct() {
	gen.pf(`type %s struct {
	ExpectCallTo *%s
}

func (i *%s) Within(d time.Duration) *%s {
	return &%s{
		ExpectCallTo: &%s{imp: i, timeout: d},
	}
}

`, gen.timedName, gen.expectCallToName, gen.impName, gen.timedName, gen.timedName, gen.expectCallToName)
}

// generateGetCallMethod generates the GetCall method that retrieves matching calls from queue or channel.
func (gen *codeGenerator) generateGetCallMethod() {
	gen.pf(`func (i *%s) GetCall(d time.Duration, validator func(*%s) bool) *%s {
	i.queueLock.Lock()
	defer i.queueLock.Unlock()

	for index, call := range i.callQueue {
		if validator(call) {
			// Remove from queue
			i.callQueue = append(i.callQueue[:index], i.callQueue[index+1:]...)
			return call
		}
	}

	var timeoutChan <-chan time.Time
	if d > 0 {
		timeoutChan = time.After(d)
	}

	for {
		select {
		case call := <-i.callChan:
			if validator(call) {
				return call
			}
			// Queue it
			i.callQueue = append(i.callQueue, call)
		case <-timeoutChan:
			i.t.Fatalf("timeout waiting for call matching validator")
			return nil
		}
	}
}

`, gen.impName, gen.callName, gen.callName)
}

// generateGetCurrentCallMethod generates the GetCurrentCall method that returns the current or next call.
func (gen *codeGenerator) generateGetCurrentCallMethod() {
	gen.pf(`func (i *%s) GetCurrentCall() *%s {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *%s) bool { return true })
	return i.currentCall
}

`, gen.impName, gen.callName, gen.callName)
}

// generateConstructor generates the New{ImpName} constructor function.
func (gen *codeGenerator) generateConstructor() {
	gen.pf(`func New%s(t *testing.T) *%s {
	imp := &%s{
		t: t,
		callChan: make(chan *%s, 1),
	}
	imp.Mock = &%s{imp: imp}
	imp.ExpectCallTo = &%s{imp: imp}
	return imp
}

`, gen.impName, gen.impName, gen.impName, gen.callName, gen.mockName, gen.expectCallToName)
}

// Functions - Public

// generateImplementationCode generates the complete mock implementation code for an interface.
func generateImplementationCode(
	identifiedInterface *ast.InterfaceType,
	info generatorInfo,
	fset *token.FileSet,
) (string, error) {
	impName := info.impName

	gen := &codeGenerator{
		fset:                fset,
		pkgName:             info.pkgName,
		impName:             impName,
		mockName:            impName + "Mock",
		callName:            impName + "Call",
		expectCallToName:    impName + "ExpectCallTo",
		timedName:           impName + "Timed",
		identifiedInterface: identifiedInterface,
		methodNames:         collectMethodNames(identifiedInterface),
	}

	gen.generateHeader()
	gen.generateMockStruct()
	gen.generateMainStruct()
	gen.generateMethodStructs()
	gen.generateMockMethods()
	gen.generateCallStruct()
	gen.generateExpectCallToStruct()
	gen.generateExpectCallToMethods()
	gen.generateTimedStruct()
	gen.generateGetCallMethod()
	gen.generateGetCurrentCallMethod()
	gen.generateConstructor()

	formatted, err := format.Source(gen.buf.Bytes())
	if err != nil {
		return "", fmt.Errorf("error formatting generated code: %w", err)
	}

	return string(formatted), nil
}

// generateCallableWrapperCode generates a type-safe wrapper for a callable function.
//
//nolint:gocognit,gocyclo,cyclop,funlen,maintidx // Code generation is inherently complex
func generateCallableWrapperCode(
	astFiles []*ast.File,
	info generatorInfo,
	fset *token.FileSet,
	pkgImportPath string,
) (string, error) {
	// Find the function in the AST
	funcDecl, err := findFunctionInAST(astFiles, info.localInterfaceName, pkgImportPath)
	if err != nil {
		return "", err
	}

	// Generate the wrapper code
	var buf bytes.Buffer

	// Package and imports
	fmt.Fprintf(&buf, "// Code generated by impgen. DO NOT EDIT.\n\n")
	fmt.Fprintf(&buf, "package %s\n\n", info.pkgName)

	// Need to import the package if callable uses types from it
	pkgPath, pkgName := getPackageInfo(funcDecl, info.interfaceName)
	if pkgPath != "" {
		fmt.Fprintf(&buf, "import (\n")
		fmt.Fprintf(&buf, "\t\"reflect\"\n")
		fmt.Fprintf(&buf, "\t\"testing\"\n")
		fmt.Fprintf(&buf, "\t%s \"%s\"\n", pkgName, pkgPath)
		fmt.Fprintf(&buf, ")\n\n")
	} else {
		fmt.Fprintf(&buf, "import (\n")
		fmt.Fprintf(&buf, "\t\"reflect\"\n")
		fmt.Fprintf(&buf, "\t\"testing\"\n")
		fmt.Fprintf(&buf, ")\n\n")
	}

	// Return struct (if function has returns)
	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		fmt.Fprintf(&buf, "type %sReturn struct {\n", info.impName)

		resultIdx := 0

		for _, field := range funcDecl.Type.Results.List {
			numNames := len(field.Names)
			if numNames == 0 {
				numNames = 1
			}

			for range numNames {
				fmt.Fprintf(&buf, "\tVal%d ", resultIdx)

				err = printTypeWithQualifier(&buf, fset, field.Type, pkgName)
				if err != nil {
					return "", fmt.Errorf("error printing return type: %w", err)
				}

				fmt.Fprintf(&buf, "\n")

				resultIdx++
			}
		}

		fmt.Fprintf(&buf, "}\n\n")
	}

	// Main struct
	fmt.Fprintf(&buf, "type %s struct {\n", info.impName)
	fmt.Fprintf(&buf, "\tt          testing.TB\n")
	fmt.Fprintf(&buf, "\tcallable   func(")

	// Write parameters with qualifiers
	writeCallableParamsWithQualifiers(&buf, funcDecl.Type.Params, fset, pkgName)
	fmt.Fprintf(&buf, ")")

	// Write return types with qualifiers (just types, no names)
	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		fmt.Fprintf(&buf, " (")
		writeCallableResultTypesWithQualifiers(&buf, funcDecl.Type.Results, fset, pkgName)
		fmt.Fprintf(&buf, ")")
	}

	fmt.Fprintf(&buf, "\n")

	fmt.Fprintf(&buf, "\n")

	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		fmt.Fprintf(&buf, "\treturnChan chan %sReturn\n", info.impName)
	} else {
		fmt.Fprintf(&buf, "\treturnChan chan struct{}\n")
	}

	fmt.Fprintf(&buf, "\tpanicChan  chan any\n")

	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		fmt.Fprintf(&buf, "\treturned   *%sReturn\n", info.impName)
	} else {
		fmt.Fprintf(&buf, "\treturned   *struct{}\n")
	}

	fmt.Fprintf(&buf, "\tpanicked   any\n")
	fmt.Fprintf(&buf, "}\n\n")

	// Constructor
	fmt.Fprintf(&buf, "func New%s(t testing.TB, callable func(", info.impName)
	writeCallableParamsWithQualifiers(&buf, funcDecl.Type.Params, fset, pkgName)
	fmt.Fprintf(&buf, ")")

	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		fmt.Fprintf(&buf, " (")
		writeCallableResultTypesWithQualifiers(&buf, funcDecl.Type.Results, fset, pkgName)
		fmt.Fprintf(&buf, ")")
	}

	fmt.Fprintf(&buf, ") *%s {\n", info.impName)
	fmt.Fprintf(&buf, "\treturn &%s{\n", info.impName)
	fmt.Fprintf(&buf, "\t\tt:        t,\n")
	fmt.Fprintf(&buf, "\t\tcallable: callable,\n")

	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		fmt.Fprintf(&buf, "\t\treturnChan: make(chan %sReturn, 1),\n", info.impName)
	} else {
		fmt.Fprintf(&buf, "\t\treturnChan: make(chan struct{}, 1),\n")
	}

	fmt.Fprintf(&buf, "\t\tpanicChan:  make(chan any, 1),\n")
	fmt.Fprintf(&buf, "\t}\n")
	fmt.Fprintf(&buf, "}\n\n")

	// Start method
	fmt.Fprintf(&buf, "func (s *%s) Start(", info.impName)
	writeCallableParamsWithQualifiers(&buf, funcDecl.Type.Params, fset, pkgName)
	fmt.Fprintf(&buf, ") *%s {\n", info.impName)
	fmt.Fprintf(&buf, "\tgo func() {\n")
	fmt.Fprintf(&buf, "\t\tdefer func() {\n")
	fmt.Fprintf(&buf, "\t\t\tif r := recover(); r != nil {\n")
	fmt.Fprintf(&buf, "\t\t\t\ts.panicChan <- r\n")
	fmt.Fprintf(&buf, "\t\t\t}\n")
	fmt.Fprintf(&buf, "\t\t}()\n\n")

	// Call the function
	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		// Count total return values
		numReturns := 0

		for _, field := range funcDecl.Type.Results.List {
			if len(field.Names) > 0 {
				numReturns += len(field.Names)
			} else {
				numReturns++
			}
		}

		// Generate return variable names
		returnVars := make([]string, numReturns)
		for i := range returnVars {
			returnVars[i] = fmt.Sprintf("ret%d", i)
		}

		fmt.Fprintf(&buf, "\t\t%s := s.callable(", strings.Join(returnVars, ", "))
		writeCallableParamNames(&buf, funcDecl.Type.Params)
		fmt.Fprintf(&buf, ")\n")
		fmt.Fprintf(&buf, "\t\ts.returnChan <- %sReturn{\n", info.impName)

		for i := range returnVars {
			fmt.Fprintf(&buf, "\t\t\tVal%d: %s,\n", i, returnVars[i])
		}

		fmt.Fprintf(&buf, "\t\t}\n")
	} else {
		fmt.Fprintf(&buf, "\t\ts.callable(")
		writeCallableParamNames(&buf, funcDecl.Type.Params)
		fmt.Fprintf(&buf, ")\n")
		fmt.Fprintf(&buf, "\t\ts.returnChan <- struct{}{}\n")
	}

	fmt.Fprintf(&buf, "\t}()\n")
	fmt.Fprintf(&buf, "\treturn s\n")
	fmt.Fprintf(&buf, "}\n\n")

	// ExpectReturnedValues method
	fmt.Fprintf(&buf, "func (s *%s) ExpectReturnedValues(", info.impName)
	writeCallableResultsWithQualifiers(&buf, funcDecl.Type.Results, fset, pkgName)
	fmt.Fprintf(&buf, ") {\n")
	fmt.Fprintf(&buf, "\ts.t.Helper()\n\n")
	fmt.Fprintf(&buf, "\t// Check if we already have a return value or panic\n")
	fmt.Fprintf(&buf, "\tif s.returned != nil {\n")

	// Generate comparisons for cached returns
	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		resultIdx := 0

		for fieldIdx, field := range funcDecl.Type.Results.List {
			numNames := len(field.Names)
			if numNames == 0 {
				numNames = 1
			}

			for nameIdx := range numNames {
				// Use the same naming convention as writeCallableResultsWithQualifiers
				resultName := fmt.Sprintf("v%d", fieldIdx*numNames+nameIdx+1)
				fmt.Fprintf(&buf, "\t\tif s.returned.Val%d != %s {\n", resultIdx, resultName)
				fmt.Fprintf(
					&buf,
					"\t\t\ts.t.Fatalf(\"expected return value %%d to be %%v, got %%v\", %d, %s, s.returned.Val%d)\n",
					resultIdx, resultName, resultIdx,
				)
				fmt.Fprintf(&buf, "\t\t}\n")

				resultIdx++
			}
		}
	}

	fmt.Fprintf(&buf, "\t\treturn\n")
	fmt.Fprintf(&buf, "\t}\n\n")
	fmt.Fprintf(&buf, "\tif s.panicked != nil {\n")
	fmt.Fprintf(&buf, "\t\ts.t.Fatalf(\"expected function to return, but it panicked with: %%v\", s.panicked)\n")
	fmt.Fprintf(&buf, "\t}\n\n")
	fmt.Fprintf(&buf, "\t// Wait for either return or panic\n")
	fmt.Fprintf(&buf, "\tselect {\n")
	fmt.Fprintf(&buf, "\tcase ret := <-s.returnChan:\n")
	fmt.Fprintf(&buf, "\t\ts.returned = &ret\n")

	// Generate comparisons for new returns
	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		resultIdx := 0

		for fieldIdx, field := range funcDecl.Type.Results.List {
			numNames := len(field.Names)
			if numNames == 0 {
				numNames = 1
			}

			for nameIdx := range numNames {
				// Use the same naming convention as writeCallableResultsWithQualifiers
				resultName := fmt.Sprintf("v%d", fieldIdx*numNames+nameIdx+1)
				fmt.Fprintf(&buf, "\t\tif ret.Val%d != %s {\n", resultIdx, resultName)
				fmt.Fprintf(
					&buf,
					"\t\t\ts.t.Fatalf(\"expected return value %%d to be %%v, got %%v\", %d, %s, ret.Val%d)\n",
					resultIdx, resultName, resultIdx,
				)
				fmt.Fprintf(&buf, "\t\t}\n")

				resultIdx++
			}
		}
	}

	fmt.Fprintf(&buf, "\tcase p := <-s.panicChan:\n")
	fmt.Fprintf(&buf, "\t\ts.panicked = p\n")
	fmt.Fprintf(&buf, "\t\ts.t.Fatalf(\"expected function to return, but it panicked with: %%v\", p)\n")
	fmt.Fprintf(&buf, "\t}\n")
	fmt.Fprintf(&buf, "}\n\n")

	// ExpectPanicWith method
	fmt.Fprintf(&buf, "func (s *%s) ExpectPanicWith(expected any) {\n", info.impName)
	fmt.Fprintf(&buf, "\ts.t.Helper()\n\n")
	fmt.Fprintf(&buf, "\t// Check if we already have a return value or panic\n")
	fmt.Fprintf(&buf, "\tif s.panicked != nil {\n")
	fmt.Fprintf(&buf, "\t\tif !reflect.DeepEqual(s.panicked, expected) {\n")
	fmt.Fprintf(&buf, "\t\t\ts.t.Fatalf(\"expected panic with %%v, got %%v\", expected, s.panicked)\n")
	fmt.Fprintf(&buf, "\t\t}\n")
	fmt.Fprintf(&buf, "\t\treturn\n")
	fmt.Fprintf(&buf, "\t}\n\n")
	fmt.Fprintf(&buf, "\tif s.returned != nil {\n")
	fmt.Fprintf(&buf, "\t\ts.t.Fatalf(\"expected function to panic, but it returned\")\n")
	fmt.Fprintf(&buf, "\t}\n\n")
	fmt.Fprintf(&buf, "\t// Wait for either return or panic\n")
	fmt.Fprintf(&buf, "\tselect {\n")
	fmt.Fprintf(&buf, "\tcase ret := <-s.returnChan:\n")
	fmt.Fprintf(&buf, "\t\ts.returned = &ret\n")
	fmt.Fprintf(&buf, "\t\ts.t.Fatalf(\"expected function to panic, but it returned\")\n")
	fmt.Fprintf(&buf, "\tcase p := <-s.panicChan:\n")
	fmt.Fprintf(&buf, "\t\ts.panicked = p\n")
	fmt.Fprintf(&buf, "\t\tif !reflect.DeepEqual(p, expected) {\n")
	fmt.Fprintf(&buf, "\t\t\ts.t.Fatalf(\"expected panic with %%v, got %%v\", expected, p)\n")
	fmt.Fprintf(&buf, "\t\t}\n")
	fmt.Fprintf(&buf, "\t}\n")
	fmt.Fprintf(&buf, "}\n\n")

	// Response struct
	fmt.Fprintf(&buf, "type %sResponse struct {\n", info.impName)
	fmt.Fprintf(&buf, "\tEventType string // \"return\" or \"panic\"\n")

	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		fmt.Fprintf(&buf, "\tReturnVal *%sReturn\n", info.impName)
	}

	fmt.Fprintf(&buf, "\tPanicVal  any\n")
	fmt.Fprintf(&buf, "}\n\n")

	// Type method on Response
	fmt.Fprintf(&buf, "func (r *%sResponse) Type() string {\n", info.impName)
	fmt.Fprintf(&buf, "\treturn r.EventType\n")
	fmt.Fprintf(&buf, "}\n\n")

	// AsReturn method on Response
	fmt.Fprintf(&buf, "func (r *%sResponse) AsReturn() []any {\n", info.impName)

	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		// Count total return values
		numReturns := 0

		for _, field := range funcDecl.Type.Results.List {
			if len(field.Names) > 0 {
				numReturns += len(field.Names)
			} else {
				numReturns++
			}
		}

		fmt.Fprintf(&buf, "\tif r.ReturnVal == nil {\n")
		fmt.Fprintf(&buf, "\t\treturn nil\n")
		fmt.Fprintf(&buf, "\t}\n")
		fmt.Fprintf(&buf, "\treturn []any{")

		for i := range numReturns {
			if i > 0 {
				fmt.Fprintf(&buf, ", ")
			}

			fmt.Fprintf(&buf, "r.ReturnVal.Val%d", i)
		}

		fmt.Fprintf(&buf, "}\n")
	} else {
		fmt.Fprintf(&buf, "\treturn nil\n")
	}

	fmt.Fprintf(&buf, "}\n\n")

	// GetResponse method
	fmt.Fprintf(&buf, "func (s *%s) GetResponse() *%sResponse {\n", info.impName, info.impName)
	fmt.Fprintf(&buf, "\t// Check if we already have a return value or panic\n")
	fmt.Fprintf(&buf, "\tif s.returned != nil {\n")
	fmt.Fprintf(&buf, "\t\treturn &%sResponse{\n", info.impName)
	fmt.Fprintf(&buf, "\t\t\tEventType: \"ReturnEvent\",\n")

	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		fmt.Fprintf(&buf, "\t\t\tReturnVal: s.returned,\n")
	}

	fmt.Fprintf(&buf, "\t\t}\n")
	fmt.Fprintf(&buf, "\t}\n\n")
	fmt.Fprintf(&buf, "\tif s.panicked != nil {\n")
	fmt.Fprintf(&buf, "\t\treturn &%sResponse{\n", info.impName)
	fmt.Fprintf(&buf, "\t\t\tEventType: \"PanicEvent\",\n")
	fmt.Fprintf(&buf, "\t\t\tPanicVal:  s.panicked,\n")
	fmt.Fprintf(&buf, "\t\t}\n")
	fmt.Fprintf(&buf, "\t}\n\n")
	fmt.Fprintf(&buf, "\t// Wait for either return or panic\n")
	fmt.Fprintf(&buf, "\tselect {\n")
	fmt.Fprintf(&buf, "\tcase ret := <-s.returnChan:\n")
	fmt.Fprintf(&buf, "\t\ts.returned = &ret\n")
	fmt.Fprintf(&buf, "\t\treturn &%sResponse{\n", info.impName)
	fmt.Fprintf(&buf, "\t\t\tEventType: \"ReturnEvent\",\n")

	if funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0 {
		fmt.Fprintf(&buf, "\t\t\tReturnVal: &ret,\n")
	}

	fmt.Fprintf(&buf, "\t\t}\n")
	fmt.Fprintf(&buf, "\tcase p := <-s.panicChan:\n")
	fmt.Fprintf(&buf, "\t\ts.panicked = p\n")
	fmt.Fprintf(&buf, "\t\treturn &%sResponse{\n", info.impName)
	fmt.Fprintf(&buf, "\t\t\tEventType: \"PanicEvent\",\n")
	fmt.Fprintf(&buf, "\t\t\tPanicVal:  p,\n")
	fmt.Fprintf(&buf, "\t\t}\n")
	fmt.Fprintf(&buf, "\t}\n")
	fmt.Fprintf(&buf, "}\n\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return "", fmt.Errorf("error formatting generated code: %w", err)
	}

	return string(formatted), nil
}

// Functions - Private

// collectMethodNames extracts all method names from an interface.
func collectMethodNames(iface *ast.InterfaceType) []string {
	var methodNames []string

	forEachInterfaceMethod(iface, func(methodName string, ftype *ast.FuncType) {
		methodNames = append(methodNames, methodName)
	})

	return methodNames
}

// forEachInterfaceMethod iterates over interface methods and calls the callback for each.
func forEachInterfaceMethod(iface *ast.InterfaceType, callback func(methodName string, ftype *ast.FuncType)) {
	for _, field := range iface.Methods.List {
		processFieldMethods(field, callback)
	}
}

// processFieldMethods processes all method names in a field and calls the callback for each valid method.
func processFieldMethods(field *ast.Field, callback func(methodName string, ftype *ast.FuncType)) {
	// Skip embedded interfaces (they have no names)
	if len(field.Names) == 0 {
		return
	}

	// Skip non-function types (shouldn't happen in a valid interface, but be safe)
	ftype, ok := field.Type.(*ast.FuncType)
	if !ok {
		return
	}

	// Process each method name with the same function type
	for _, methodName := range field.Names {
		callback(methodName.Name, ftype)
	}
}

// hasParams returns true if the function type has parameters.
func hasParams(ftype *ast.FuncType) bool {
	return ftype.Params != nil && len(ftype.Params.List) > 0
}

// hasResults returns true if the function type has return values.
func hasResults(ftype *ast.FuncType) bool {
	return ftype.Results != nil && len(ftype.Results.List) > 0
}

// getParamFieldName returns the struct field name for a parameter.
// For named params, returns the name. For unnamed params, generates a name based on type/index.
func getParamFieldName(param *ast.Field, nameIdx int, unnamedIdx int, paramType string, totalParams int) string {
	if len(param.Names) > 0 {
		return param.Names[nameIdx].Name
	}

	return generateParamName(unnamedIdx, paramType, totalParams)
}

// countFields counts the total number of individual fields in a field list.
func countFields(fields *ast.FieldList) int {
	total := 0

	for _, field := range fields.List {
		if len(field.Names) > 0 {
			total += len(field.Names)
		} else {
			total++
		}
	}

	return total
}

// extractParamNames extracts or generates parameter names from a function type.
func extractParamNames(ftype *ast.FuncType) []string {
	paramNames := make([]string, 0)
	if !hasParams(ftype) {
		return paramNames
	}

	paramIndex := 0

	for _, param := range ftype.Params.List {
		paramNames, paramIndex = appendParamNames(param, paramNames, paramIndex)
	}

	return paramNames
}

// appendParamNames appends parameter names to the list, generating names for unnamed parameters.
func appendParamNames(param *ast.Field, paramNames []string, paramIndex int) ([]string, int) {
	if len(param.Names) > 0 {
		for _, name := range param.Names {
			paramNames = append(paramNames, name.Name)
		}

		return paramNames, paramIndex
	}

	paramName := fmt.Sprintf("param%d", paramIndex)
	paramNames = append(paramNames, paramName)

	return paramNames, paramIndex + 1
}

// renderFieldList renders a *ast.FieldList as Go code for return types.
func renderFieldList(fset *token.FileSet, fieldList *ast.FieldList) string {
	if fieldList == nil || len(fieldList.List) == 0 {
		return ""
	}

	var buf bytes.Buffer
	buf.WriteString("(")

	for i, field := range fieldList.List {
		if i > 0 {
			buf.WriteString(", ")
		}

		renderField(fset, field, &buf)
	}

	buf.WriteString(")")

	return buf.String()
}

// renderField renders a single field with its name and type.
func renderField(fset *token.FileSet, field *ast.Field, buf *bytes.Buffer) {
	// Names
	for j, name := range field.Names {
		if j > 0 {
			buf.WriteString(", ")
		}

		buf.WriteString(name.Name)
	}

	// Type
	if len(field.Names) > 0 {
		buf.WriteString(" ")
	}

	buf.WriteString(exprToString(fset, field.Type))
}

// exprToString renders an ast.Expr to Go code.
func exprToString(fset *token.FileSet, expr ast.Expr) string {
	var buf bytes.Buffer
	printer.Fprint(&buf, fset, expr)

	return buf.String()
}

// generateParamName generates a field name for an unnamed parameter
// Uses common conventions: single string -> "S", single int -> "Input", multiple -> "A", "B", "C", etc.
func generateParamName(index int, paramType string, totalParams int) string {
	// Remove common prefixes/suffixes for comparison
	normalized := strings.TrimSpace(paramType)

	// Single parameter cases
	if totalParams == 1 {
		if normalized == "string" {
			return "S"
		}

		if normalized == "int" {
			return "I"
		}
	}

	// Multiple parameters - use A, B, C, etc.
	names := []string{"A", "B", "C", "D", "E", "F", "G", "H"}
	if index < len(names) {
		return names[index]
	}

	// Fallback
	return fmt.Sprintf("Arg%d", index)
}

// findFunctionInAST finds a function or method declaration in the AST files.
// funcName can be a plain function name like "PrintSum" or a method reference like "PingPongPlayer.Play".
//
//nolint:cyclop,nestif // AST searching requires some complexity
func findFunctionInAST(astFiles []*ast.File, funcName string, pkgImportPath string) (*ast.FuncDecl, error) {
	// Check if this is a method reference (TypeName.MethodName)
	typeName, methodName, isMethod := strings.Cut(funcName, ".")

	for _, file := range astFiles {
		for _, decl := range file.Decls {
			funcDecl, ok := decl.(*ast.FuncDecl)
			if !ok {
				continue
			}

			if isMethod {
				// Looking for a method - must have a receiver with matching type and method name
				if funcDecl.Recv == nil || len(funcDecl.Recv.List) == 0 {
					continue
				}

				if funcDecl.Name.Name != methodName {
					continue
				}

				if matchesReceiverType(funcDecl.Recv.List[0].Type, typeName) {
					return funcDecl, nil
				}
			} else {
				// Looking for a plain function - must not have a receiver
				if funcDecl.Recv != nil {
					continue
				}

				if funcDecl.Name.Name == funcName {
					return funcDecl, nil
				}
			}
		}
	}

	return nil, fmt.Errorf("%w: named %q in package %q", errFunctionNotFound, funcName, pkgImportPath)
}

// matchesReceiverType checks if the receiver type expression matches the given type name.
// Handles both value receivers (T) and pointer receivers (*T).
func matchesReceiverType(expr ast.Expr, typeName string) bool {
	switch recv := expr.(type) {
	case *ast.Ident:
		return recv.Name == typeName
	case *ast.StarExpr:
		// Pointer receiver - check the underlying type
		if ident, ok := recv.X.(*ast.Ident); ok {
			return ident.Name == typeName
		}
	}

	return false
}

// writeCallableParamsWithQualifiers writes function parameters to the buffer with package qualifiers.
func writeCallableParamsWithQualifiers(buf *bytes.Buffer, params *ast.FieldList, fset *token.FileSet, pkgName string) {
	if params == nil || len(params.List) == 0 {
		return
	}

	for i, field := range params.List {
		if i > 0 {
			buf.WriteString(", ")
		}

		// Write names if present
		if len(field.Names) > 0 {
			for j, name := range field.Names {
				if j > 0 {
					buf.WriteString(", ")
				}

				buf.WriteString(name.Name)
			}

			buf.WriteString(" ")
		}

		// Write type with qualifier
		_ = printTypeWithQualifier(buf, fset, field.Type, pkgName)
	}
}

// writeCallableResultTypesWithQualifiers writes function return types (without names) with package qualifiers.
func writeCallableResultTypesWithQualifiers(
	buf *bytes.Buffer, results *ast.FieldList, fset *token.FileSet, pkgName string,
) {
	if results == nil || len(results.List) == 0 {
		return
	}

	first := true

	for _, field := range results.List {
		numNames := len(field.Names)
		if numNames == 0 {
			numNames = 1
		}

		for range numNames {
			if !first {
				buf.WriteString(", ")
			}

			first = false

			// Write type with qualifier
			_ = printTypeWithQualifier(buf, fset, field.Type, pkgName)
		}
	}
}

// writeCallableResultsWithQualifiers writes function return values to the buffer with package qualifiers.
func writeCallableResultsWithQualifiers(
	buf *bytes.Buffer, results *ast.FieldList, fset *token.FileSet, pkgName string,
) {
	if results == nil || len(results.List) == 0 {
		return
	}

	for fieldIdx, field := range results.List {
		if fieldIdx > 0 {
			buf.WriteString(", ")
		}

		// Generate parameter names for return values
		numNames := len(field.Names)
		if numNames == 0 {
			numNames = 1
		}

		for nameIdx := range numNames {
			if nameIdx > 0 {
				buf.WriteString(", ")
			}

			// Generate a name
			fmt.Fprintf(buf, "v%d", fieldIdx*numNames+nameIdx+1)
			buf.WriteString(" ")
		}

		// Write type with qualifier
		_ = printTypeWithQualifier(buf, fset, field.Type, pkgName)
	}
}

// writeCallableParamNames writes only the parameter names (for passing to a function call).
func writeCallableParamNames(buf *bytes.Buffer, params *ast.FieldList) {
	if params == nil || len(params.List) == 0 {
		return
	}

	first := true

	for _, field := range params.List {
		if len(field.Names) > 0 {
			for _, name := range field.Names {
				if !first {
					buf.WriteString(", ")
				}

				buf.WriteString(name.Name)

				first = false
			}
		}
	}
}

// writeCallableResultNames writes only the result names (for passing to a function call).
// getPackageInfo extracts package import path and name from the interface name.
// Returns empty strings if no package qualification is present or if the function
// doesn't use any types that require the package import.
func getPackageInfo(funcDecl *ast.FuncDecl, interfaceName string) (pkgPath, pkgName string) {
	// Check if interfaceName contains a package qualifier (e.g., "run.PrintSum")
	if !strings.Contains(interfaceName, ".") {
		return "", ""
	}

	parts := strings.Split(interfaceName, ".")

	// Check if the function signature uses any types that would need the package import
	if !funcUsesExportedTypes(funcDecl) {
		return "", ""
	}

	// For now, assume the package name is the same as the last part of the path
	// This is a simplification - a more robust solution would look up the actual import path
	pkgName = parts[0]
	pkgPath = "github.com/toejough/imptest/UAT/" + pkgName

	return pkgPath, pkgName
}

// funcUsesExportedTypes checks if a function's parameters or return types include
// any exported identifiers that might need package qualification.
func funcUsesExportedTypes(funcDecl *ast.FuncDecl) bool {
	// Check parameters
	if funcDecl.Type.Params != nil {
		for _, field := range funcDecl.Type.Params.List {
			if hasExportedIdent(field.Type) {
				return true
			}
		}
	}

	// Check results
	if funcDecl.Type.Results != nil {
		for _, field := range funcDecl.Type.Results.List {
			if hasExportedIdent(field.Type) {
				return true
			}
		}
	}

	return false
}

// hasExportedIdent recursively checks if an expression contains an exported identifier.
func hasExportedIdent(expr ast.Expr) bool {
	switch typeExpr := expr.(type) {
	case *ast.Ident:
		// Check if it's an exported identifier (starts with uppercase)
		// and not a builtin type
		if unicode.IsUpper(rune(typeExpr.Name[0])) && !isBuiltinType(typeExpr.Name) {
			return true
		}
	case *ast.StarExpr:
		return hasExportedIdent(typeExpr.X)
	case *ast.ArrayType:
		return hasExportedIdent(typeExpr.Elt)
	case *ast.MapType:
		return hasExportedIdent(typeExpr.Key) || hasExportedIdent(typeExpr.Value)
	case *ast.ChanType:
		return hasExportedIdent(typeExpr.Value)
	case *ast.SelectorExpr:
		// Package-qualified type - definitely needs import
		return true
	}

	return false
}

// isBuiltinType checks if a type name is a Go builtin.
func isBuiltinType(name string) bool {
	builtins := map[string]bool{
		"bool": true, "byte": true, "complex64": true, "complex128": true,
		"error": true, "float32": true, "float64": true, "int": true,
		"int8": true, "int16": true, "int32": true, "int64": true,
		"rune": true, "string": true, "uint": true, "uint8": true,
		"uint16": true, "uint32": true, "uint64": true, "uintptr": true,
		"any": true,
	}

	return builtins[name]
}

// printTypeWithQualifier prints a type expression, adding package qualifiers for identifiers that need them.
//
//nolint:cyclop // Code generation is inherently complex
func printTypeWithQualifier(buf *bytes.Buffer, fset *token.FileSet, expr ast.Expr, pkgName string) error {
	switch typeExpr := expr.(type) {
	case *ast.Ident:
		// If we have a package name and the identifier starts with uppercase (exported),
		// it likely needs to be qualified
		if pkgName != "" && len(typeExpr.Name) > 0 && typeExpr.Name[0] >= 'A' && typeExpr.Name[0] <= 'Z' {
			buf.WriteString(pkgName)
			buf.WriteString(".")
		}

		buf.WriteString(typeExpr.Name)
	case *ast.StarExpr:
		// Pointer type
		buf.WriteString("*")
		return printTypeWithQualifier(buf, fset, typeExpr.X, pkgName)
	case *ast.ArrayType:
		// Array or slice type
		buf.WriteString("[")

		if typeExpr.Len != nil {
			printer.Fprint(buf, fset, typeExpr.Len)
		}

		buf.WriteString("]")

		return printTypeWithQualifier(buf, fset, typeExpr.Elt, pkgName)
	default:
		// For other complex types, use printer.Fprint
		err := printer.Fprint(buf, fset, expr)
		if err != nil {
			return fmt.Errorf("error printing type expression: %w", err)
		}
	}

	return nil
}
