// Code generated by impgen. DO NOT EDIT.

package imptest_test

import (
	_fmt "fmt"
	_reflect "reflect"

	_imptest "github.com/toejough/imptest/imptest"

	_testing "testing"

	_time "time"

	imptest "github.com/toejough/imptest/imptest"
)

// TesterImp is the test controller for mocking the interface.
// Create with NewTesterImp(t), then use Mock field to get the mock implementation
// and ExpectCallIs field to set expectations for method calls.
//
// Example:
//
//	imp := NewTesterImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.MethodName().ExpectArgsAre(...).InjectResult(...)
type TesterImp struct {
	*_imptest.Controller[*TesterImpCall]
	Mock         *TesterImpMock
	ExpectCallIs *TesterImpExpectCallIs
	currentCall  *TesterImpCall
}

// NewTesterImp creates a new test controller for mocking the interface.
// The returned controller manages mock expectations and response injection.
// Pass t to enable automatic test failure on unexpected calls or timeouts.
//
// Example:
//
//	imp := NewTesterImp(t)
//	go codeUnderTest(imp.Mock)
//	imp.ExpectCallIs.Method().ExpectArgsAre(...).InjectResult(...)
func NewTesterImp(t *_testing.T) *TesterImp {
	imp := &TesterImp{
		Controller: _imptest.NewController[*TesterImpCall](t),
	}
	imp.Mock = &TesterImpMock{imp: imp}
	imp.ExpectCallIs = &TesterImpExpectCallIs{imp: imp}
	return imp
}

// GetCurrentCall returns the current call being processed.
// If no call is pending, waits indefinitely for the next call.
// Returns the existing current call if it hasn't been completed yet.
func (i *TesterImp) GetCurrentCall() *TesterImpCall {
	if i.currentCall != nil && !i.currentCall.Done() {
		return i.currentCall
	}
	i.currentCall = i.GetCall(0, func(c *TesterImpCall) error { return nil })
	return i.currentCall
}

// Within configures a timeout for expectations and returns a TesterImpTimed for method chaining.
// The timeout applies to subsequent expectation calls.
//
// Example:
//
//	imp.Within(100*_time.Millisecond).ExpectCallIs.Method().ExpectArgsAre(...)
func (i *TesterImp) Within(d _time.Duration) *TesterImpTimed {
	return &TesterImpTimed{
		ExpectCallIs: &TesterImpExpectCallIs{imp: i, timeout: d},
	}
}

// TesterImpCall represents a captured call to any method.
// Only one method field is non-nil at a time, indicating which method was called.
// Use Name() to identify the method and As{{Method}() to access typed call details.
type TesterImpCall struct {
	fatalf *TesterImpFatalfCall
	helper *TesterImpHelperCall
}

// AsFatalf returns the call cast to TesterImpFatalfCall for accessing call details.
// Returns nil if the call was not to Fatalf.
func (c *TesterImpCall) AsFatalf() *TesterImpFatalfCall {
	return c.fatalf
}

// AsHelper returns the call cast to TesterImpHelperCall for accessing call details.
// Returns nil if the call was not to Helper.
func (c *TesterImpCall) AsHelper() *TesterImpHelperCall {
	return c.helper
}

// Done returns true if the call has been completed (response injected).
// Used internally to track call state.
func (c *TesterImpCall) Done() bool {
	if c.fatalf != nil {
		return c.fatalf.done
	}
	if c.helper != nil {
		return c.helper.done
	}
	return false
}

// Name returns the name of the method that was called.
// Returns an empty string if the call struct is invalid.
func (c *TesterImpCall) Name() string {
	if c.fatalf != nil {
		return "Fatalf"
	}
	if c.helper != nil {
		return "Helper"
	}
	return ""
}

// TesterImpExpectCallIs provides methods to set expectations for specific method calls.
// Each method returns a builder for fluent expectation configuration.
// Use Within() on the parent TesterImp to configure timeouts.
type TesterImpExpectCallIs struct {
	imp     *TesterImp
	timeout _time.Duration
}

// Fatalf returns a builder for setting expectations on Fatalf method calls.
func (e *TesterImpExpectCallIs) Fatalf() *TesterImpFatalfBuilder {
	return &TesterImpFatalfBuilder{imp: e.imp, timeout: e.timeout}
}

// Helper returns a builder for setting expectations on Helper method calls.
func (e *TesterImpExpectCallIs) Helper() *TesterImpHelperBuilder {
	return &TesterImpHelperBuilder{imp: e.imp, timeout: e.timeout}
}

// TesterImpFatalfBuilder provides a fluent API for setting expectations on Fatalf calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type TesterImpFatalfBuilder struct {
	imp     *TesterImp
	timeout _time.Duration
}

// ExpectArgsAre waits for a Fatalf call with exactly the specified argument values.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if arguments don't match exactly.
// Uses == for comparable types and reflect.DeepEqual for others.
func (bldr *TesterImpFatalfBuilder) ExpectArgsAre(format string, args ...any) *TesterImpFatalfCall {
	validator := func(callToCheck *TesterImpCall) error {
		if callToCheck.Name() != "Fatalf" {
			return _fmt.Errorf("expected Fatalf, got %q", callToCheck.Name())
		}
		methodCall := callToCheck.AsFatalf()
		if methodCall.format != format {
			return _fmt.Errorf("format mismatch: expected %q, got %q", format, methodCall.format)
		}
		if !_reflect.DeepEqual(methodCall.args, args) {
			return _fmt.Errorf("args mismatch: expected %#v, got %#v", args, methodCall.args)
		}
		return nil
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsFatalf()
}

// ExpectArgsShould waits for a Fatalf call with arguments matching the given matchers.
// Use imptest.Any() to match any value, or imptest.Satisfies(fn) for custom matching.
// Returns the call object for response injection. Fails the test if the call
// doesn't arrive within the timeout or if any matcher fails.
func (bldr *TesterImpFatalfBuilder) ExpectArgsShould(format any, args any) *TesterImpFatalfCall {
	validator := func(callToCheck *TesterImpCall) error {
		if callToCheck.Name() != "Fatalf" {
			return _fmt.Errorf("expected Fatalf, got %q", callToCheck.Name())
		}
		methodCall := callToCheck.AsFatalf()
		var ok bool
		var failureMsg string
		ok, failureMsg = _imptest.MatchValue(methodCall.format, format)
		if !ok {
			if failureMsg != "" {
				return _fmt.Errorf("format matcher failed: %s", failureMsg)
			}
			return _fmt.Errorf("format matcher failed for value %#v", methodCall.format)
		}
		ok, failureMsg = _imptest.MatchValue(methodCall.args, args)
		if !ok {
			if failureMsg != "" {
				return _fmt.Errorf("args matcher failed: %s", failureMsg)
			}
			return _fmt.Errorf("args matcher failed for value %#v", methodCall.args)
		}
		return nil
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	return call.AsFatalf()
}

// InjectPanic waits for a Fatalf call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *TesterImpFatalfBuilder) InjectPanic(msg any) *TesterImpFatalfCall {
	validator := func(callToCheck *TesterImpCall) error {
		if callToCheck.Name() != "Fatalf" {
			return _fmt.Errorf("expected Fatalf, got %q", callToCheck.Name())
		}
		return nil
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsFatalf()
	methodCall.InjectPanic(msg)
	return methodCall
}

// Resolve waits for a Fatalf call and immediately completes it without error.
// This is a shortcut that combines waiting for the call with resolving it.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *TesterImpFatalfBuilder) Resolve() *TesterImpFatalfCall {
	validator := func(callToCheck *TesterImpCall) error {
		if callToCheck.Name() != "Fatalf" {
			return _fmt.Errorf("expected Fatalf, got %q", callToCheck.Name())
		}
		return nil
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsFatalf()
	methodCall.Resolve()
	return methodCall
}

// TesterImpFatalfCall represents a captured call to the Fatalf method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type TesterImpFatalfCall struct {
	responseChan chan TesterImpFatalfCallResponse
	done         bool
	format       string
	args         []any
	t            _imptest.Tester
}

// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *TesterImpFatalfCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- TesterImpFatalfCallResponse{Type: "panic", PanicValue: msg}
}

// Resolve completes a void method call without error.
// Use this to unblock the mock method and allow execution to continue.
// Only applicable to methods with no return values.
func (c *TesterImpFatalfCall) Resolve() {
	c.done = true
	c.responseChan <- TesterImpFatalfCallResponse{Type: "resolve"}
} // InjectPanic causes the mocked method to panic with the given value.

// TesterImpFatalfCallResponse holds the response configuration for the Fatalf method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type TesterImpFatalfCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue any
}

// TesterImpHelperBuilder provides a fluent API for setting expectations on Helper calls.
// Use ExpectArgsAre for exact matching or ExpectArgsShould for matcher-based matching.
type TesterImpHelperBuilder struct {
	imp     *TesterImp
	timeout _time.Duration
}

// InjectPanic waits for a Helper call and causes it to panic with the given value.
// This is a shortcut that combines waiting for the call with injecting a panic.
// Use this to test panic handling in code under test. Returns the call object for further operations.
func (bldr *TesterImpHelperBuilder) InjectPanic(msg any) *TesterImpHelperCall {
	validator := func(callToCheck *TesterImpCall) error {
		if callToCheck.Name() != "Helper" {
			return _fmt.Errorf("expected Helper, got %q", callToCheck.Name())
		}
		return nil
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsHelper()
	methodCall.InjectPanic(msg)
	return methodCall
}

// Resolve waits for a Helper call and immediately completes it without error.
// This is a shortcut that combines waiting for the call with resolving it.
// Returns the call object for further operations. Fails if no call arrives within the timeout.
func (bldr *TesterImpHelperBuilder) Resolve() *TesterImpHelperCall {
	validator := func(callToCheck *TesterImpCall) error {
		if callToCheck.Name() != "Helper" {
			return _fmt.Errorf("expected Helper, got %q", callToCheck.Name())
		}
		return nil
	}

	call := bldr.imp.GetCall(bldr.timeout, validator)
	methodCall := call.AsHelper()
	methodCall.Resolve()
	return methodCall
}

// TesterImpHelperCall represents a captured call to the Helper method.
// Use InjectResult to set the return value, or InjectPanic to cause the method to panic.
type TesterImpHelperCall struct {
	responseChan chan TesterImpHelperCallResponse
	done         bool
	t            _imptest.Tester
}

// Use this to test panic handling in code under test.
// The panic occurs in the goroutine where the mock was called.
func (c *TesterImpHelperCall) InjectPanic(msg any) {
	c.done = true
	c.responseChan <- TesterImpHelperCallResponse{Type: "panic", PanicValue: msg}
}

// Resolve completes a void method call without error.
// Use this to unblock the mock method and allow execution to continue.
// Only applicable to methods with no return values.
func (c *TesterImpHelperCall) Resolve() {
	c.done = true
	c.responseChan <- TesterImpHelperCallResponse{Type: "resolve"}
} // InjectPanic causes the mocked method to panic with the given value.

// TesterImpHelperCallResponse holds the response configuration for the Helper method.
// Set Type to "return" for normal returns, "panic" to cause a panic, or "resolve" for void methods.
type TesterImpHelperCallResponse struct {
	Type       string // "return", "panic", or "resolve"
	PanicValue any
}

// TesterImpMock provides the mock implementation of the interface.
// Pass TesterImpMock to code under test that expects the interface implementation.
// Use the parent TesterImp controller to set expectations and inject responses.
type TesterImpMock struct {
	imp *TesterImp
}

// Fatalf implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *TesterImpMock) Fatalf(format string, args ...any) {
	responseChan := make(chan TesterImpFatalfCallResponse, 1)

	call := &TesterImpFatalfCall{
		responseChan: responseChan,
		format:       format,
		args:         args,
		t:            m.imp.T,
	}

	callEvent := &TesterImpCall{
		fatalf: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

// Helper implements the interface method and records the call for testing.
// The method blocks until a response is injected via the test controller.
func (m *TesterImpMock) Helper() {
	responseChan := make(chan TesterImpHelperCallResponse, 1)

	call := &TesterImpHelperCall{
		responseChan: responseChan,
		t:            m.imp.T,
	}

	callEvent := &TesterImpCall{
		helper: call,
	}

	m.imp.CallChan <- callEvent

	resp := <-responseChan

	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	return
}

// TesterImpTimed provides timeout-configured expectation methods.
// Access via TesterImp.Within(duration) to set a timeout for expectations.
type TesterImpTimed struct {
	ExpectCallIs *TesterImpExpectCallIs
}

// unexported variables.
var (
	// Compile-time verification that TesterImpMock implements imptest.Tester.
	_ imptest.Tester = (*TesterImpMock)(nil)
)
