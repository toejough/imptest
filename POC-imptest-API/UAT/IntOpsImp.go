package main

// Code generated by generate.go. DO NOT EDIT.

type IntOpsImpMock struct {
	imp *IntOpsImp
}

type IntOpsImp struct {
	Mock     *IntOpsImpMock
	callChan chan *IntOpsImpCall
}

type IntOpsImpAddCall struct {
	A int
	B int
}

func (c *IntOpsImpAddCall) InjectResult(result int)     {}
func (c *IntOpsImpAddCall) InjectPanic(msg interface{}) {}

type IntOpsImpFormatCall struct {
	Input int
}

func (c *IntOpsImpFormatCall) InjectResult(result string)  {}
func (c *IntOpsImpFormatCall) InjectPanic(msg interface{}) {}

type IntOpsImpPrintCall struct {
	S string
}

func (c *IntOpsImpPrintCall) Resolve()                    {}
func (c *IntOpsImpPrintCall) InjectPanic(msg interface{}) {}

func (m *IntOpsImpMock) Add(param0 int, param1 int) int {
	call := &IntOpsImpAddCall{
		A: param0,
		B: param1,
	}

	callEvent := &IntOpsImpCall{
		Add: call,
	}

	m.imp.callChan <- callEvent

	// TODO: wait for response and return
	var result int
	returnresult
}

func (m *IntOpsImpMock) Format(param0 int) string {
	call := &IntOpsImpFormatCall{
		Input: param0,
	}

	callEvent := &IntOpsImpCall{
		Format: call,
	}

	m.imp.callChan <- callEvent

	// TODO: wait for response and return
	var result string
	returnresult
}

func (m *IntOpsImpMock) Print(param0 string) {
	call := &IntOpsImpPrintCall{
		S: param0,
	}

	callEvent := &IntOpsImpCall{
		Print: call,
	}

	m.imp.callChan <- callEvent

}

type IntOpsImpCall struct {
	Add    *IntOpsImpAddCall
	Format *IntOpsImpFormatCall
	Print  *IntOpsImpPrintCall
}

func (c *IntOpsImpCall) Name() string { return "" }

func (c *IntOpsImpCall) AsAdd() *IntOpsImpAddCall { return c.Add }

func (c *IntOpsImpCall) AsFormat() *IntOpsImpFormatCall { return c.Format }

func (c *IntOpsImpCall) AsPrint() *IntOpsImpPrintCall { return c.Print }

func (i *IntOpsImp) GetCurrentCall() *IntOpsImpCall {
	return <-i.callChan
}

func NewIntOpsImp(t *testing.T) *IntOpsImp {
	imp := &IntOpsImp{
		callChan: make(chan *IntOpsImpCall, 1),
	}
	imp.Mock = &IntOpsImpMock{imp: imp}
	return imp
}
